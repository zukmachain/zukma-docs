{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"WELCOME TO Welcome to the Zukma Documentation. The Documentation serves as the central source of truth for Zukma. It is a community-focused initiative led by the Zukma team to keep an up-to-date resource on the best information for learning, building, or maintaining on Zukma Network. Warning Work in progress content can change ,and it's not definitive . What is the Zukma Web 3.0 Ecosystem? The Zukma ecosystem consists of blockchains, the main chain Zukma and an innovator blockchain called Zukma Network which holds real economic value and is all about innovating the space of Web 3.0 based DeFi - learn more about Zukma Network here. Zukma is a blockchain network with the core pillars in Decentralize Treasury, cross-chain operability and Web3. The networks have an advanced suite of governance tools and, using the Substrate framework that allows autonomous deployment of upgrades. The Zukma Network are adapting therefore to the growing needs of a DeFi loving community without the risk of Hardfork by blockchain forks. Tip You can read more about our Governance Suite here . By connecting the three pillars (Decentralization, Cross-Chain Operability and Forkless Upgrades) the Zukma ecosystem serves as a foundational layer for a truly decentralized DeFi network, where DeFi users control their data and are not limited by trust bounds within the network. What is our mission? We\u2019re on a mission to truly decentralize finance. We revolutionize the future of DeFi by providing the industry-leading ecosystem, blockchain, exchange and end-to-end financial platform within a community-governed ecosystem. Why do we need Zukma to help achieve true Decentralization? The distribution of funds in the crypto space is still relatively centralized with the majority of funds in the hands of relatively few. Part of this is because the technology is still in its youth and adoption still hasn\u2019t reached the masses, although the path towards real mass adoption is getting clearer by the day. The Problem of centralized funds still persists as a lot of coins and tokens are in the hands of a few big players in the industry. In order to further disperse these financial resources and give everyone a fair chance of participating in an independent market, exchanges mark a pivotal point. A widespread allocation is only possible if there are a lot of different - ideally independent and decentralized - exchanges that grant access to assets with each acting as a sort of contingency for another, avoiding risk of corruption. The requirements for those exchanges are steadily rising and rightfully so. Investors want to be able to voice their concerns when putting their hard-earned money at risk and the weight of their voice has been rather small in the past. It's clear that it's one of the major challenges for exchanges and DeFi projects to empower the individual investors and give them the right to vote on important decisions. With growing desire for participation comes the question on how to meet the needs of the growing crypto community. Zukma Network offers its users' participation through an elaborate voting and consensus mechanism that strives to best represent the interest of each one of their investors through nominating the most trustworthy validators (nodes that supply the blockchain with the hardware necessary) and voting upon a trusted council to ensure long term stability of the chain and the trading D'Apps deployed on its native Zukma Network. Why Zukma? Back in the early 2000s, when the internet was gaining popularity for the first time, the internet featured read-only, static, basic web pages. The online connected world at the time was only the beginning of virtual data, identities, and more. The internet during this time was also called the Web 1.0. As social media platforms and online businesses began to emerge, the internet transformed into the Web 2.0. This upgraded internet, which we still use today, features dynamic, interactive web pages, where users can read and write information plus publish their own for others to see. However, this version of the web comes with downsides, dealing with data control, privacy issues, and the consequences of trust. This is where the WEB3 comes into the picture. The WEB3 enables us to take centralized infrastructure and applications like CEX's and turning them into decentralized, trust-free protocols. The goal is to transform the DeFi space into a decentralized web, where users control their own data and identity in a trust-free environment. Our movement aims to remove intermediaries and build a trustless infrastructure for DeFi. What makes Zukma unique? Cross-Chain Capability Cross-chain liquidity pools bridging multichain assets Automized wrapping service for EVM or Substrate based tokens Multi-Wallet access Low Transaction and Gas Fees Chain transactions fees are going back to liquidity providers Fast Transaction Times 1500+ transactions per second Decentralized Governance Community Funding What can I do with my ZEP? ZEP is the native coin of the Zukma Network and can be used for transaction fees, staking and governance. ZEP has utility in Zukma's democracy. Bonding ZEP is a requirement to create proposals, to second them and to vote on them when they become referendums. How does Zukma work? Zukma Network is maintained by a set of validators that are selected through the Nominated Proof of Stake (NPoS) consensus mechanism which is responsible for producing the blocks and determining finality. Validators and Nominators are rewarded if the validators behave correctly and offer all ZEP holders the opportunity to establish multiple passive income streams. Misbehavior is punished via the Slashing Mechanism. More details on incentives and economics can be reviewed here . Furthermore, Zukma Network has a decentralized governance scheme that can change any Zukma design decision and parameter. To interact with other blockchains that want to benefit from fast transaction times, low transaction fees and cross-chain capability, Zukma establishes bridges that offer a two-way compatibility, meaning that transactions can be made between different blockchains. Why should you use Zukma Network? Whether you're a blockchain developer or if you're interested in taking part of Zukma's community, Zukma offers a platform for everyone. This wiki offers a place for developers and hodlers to utilize tools and for brand-new learners to dive into educational material. Interact with Zukma Network Creating an Account Balance Transfers Staking DApps Bridges Vote for Councilors Make a Proposal Council Candidacy Treasury Set an Identity Become a Nominator Become a Validator Disclaimer: Blockchain technologies are constantly evolving. This paper describes the best possible planned development, however, due to the nature of the technology and the complexity of integrating the world of blockchain. This document may be subject to change. We try to come close to the original plan, but sometimes modifications are necessary to improve the user experience and overcome technological barriers encountered during development. References https://substrate.dev/docs/en/knowledgebase/smart-contracts/ https://substrate.dev/ Written by Zukma Team","title":"<b>WELCOME TO</b>"},{"location":"#welcome-to","text":"Welcome to the Zukma Documentation. The Documentation serves as the central source of truth for Zukma. It is a community-focused initiative led by the Zukma team to keep an up-to-date resource on the best information for learning, building, or maintaining on Zukma Network. Warning Work in progress content can change ,and it's not definitive .","title":"WELCOME TO"},{"location":"#what-is-the-zukma-web-30-ecosystem","text":"The Zukma ecosystem consists of blockchains, the main chain Zukma and an innovator blockchain called Zukma Network which holds real economic value and is all about innovating the space of Web 3.0 based DeFi - learn more about Zukma Network here. Zukma is a blockchain network with the core pillars in Decentralize Treasury, cross-chain operability and Web3. The networks have an advanced suite of governance tools and, using the Substrate framework that allows autonomous deployment of upgrades. The Zukma Network are adapting therefore to the growing needs of a DeFi loving community without the risk of Hardfork by blockchain forks. Tip You can read more about our Governance Suite here . By connecting the three pillars (Decentralization, Cross-Chain Operability and Forkless Upgrades) the Zukma ecosystem serves as a foundational layer for a truly decentralized DeFi network, where DeFi users control their data and are not limited by trust bounds within the network.","title":"What is the Zukma Web 3.0 Ecosystem?"},{"location":"#what-is-our-mission","text":"We\u2019re on a mission to truly decentralize finance. We revolutionize the future of DeFi by providing the industry-leading ecosystem, blockchain, exchange and end-to-end financial platform within a community-governed ecosystem. Why do we need Zukma to help achieve true Decentralization? The distribution of funds in the crypto space is still relatively centralized with the majority of funds in the hands of relatively few. Part of this is because the technology is still in its youth and adoption still hasn\u2019t reached the masses, although the path towards real mass adoption is getting clearer by the day. The Problem of centralized funds still persists as a lot of coins and tokens are in the hands of a few big players in the industry. In order to further disperse these financial resources and give everyone a fair chance of participating in an independent market, exchanges mark a pivotal point. A widespread allocation is only possible if there are a lot of different - ideally independent and decentralized - exchanges that grant access to assets with each acting as a sort of contingency for another, avoiding risk of corruption. The requirements for those exchanges are steadily rising and rightfully so. Investors want to be able to voice their concerns when putting their hard-earned money at risk and the weight of their voice has been rather small in the past. It's clear that it's one of the major challenges for exchanges and DeFi projects to empower the individual investors and give them the right to vote on important decisions. With growing desire for participation comes the question on how to meet the needs of the growing crypto community. Zukma Network offers its users' participation through an elaborate voting and consensus mechanism that strives to best represent the interest of each one of their investors through nominating the most trustworthy validators (nodes that supply the blockchain with the hardware necessary) and voting upon a trusted council to ensure long term stability of the chain and the trading D'Apps deployed on its native Zukma Network.","title":"What is our mission?"},{"location":"#why-zukma","text":"Back in the early 2000s, when the internet was gaining popularity for the first time, the internet featured read-only, static, basic web pages. The online connected world at the time was only the beginning of virtual data, identities, and more. The internet during this time was also called the Web 1.0. As social media platforms and online businesses began to emerge, the internet transformed into the Web 2.0. This upgraded internet, which we still use today, features dynamic, interactive web pages, where users can read and write information plus publish their own for others to see. However, this version of the web comes with downsides, dealing with data control, privacy issues, and the consequences of trust. This is where the WEB3 comes into the picture. The WEB3 enables us to take centralized infrastructure and applications like CEX's and turning them into decentralized, trust-free protocols. The goal is to transform the DeFi space into a decentralized web, where users control their own data and identity in a trust-free environment. Our movement aims to remove intermediaries and build a trustless infrastructure for DeFi.","title":"Why Zukma?"},{"location":"#what-makes-zukma-unique","text":"Cross-Chain Capability Cross-chain liquidity pools bridging multichain assets Automized wrapping service for EVM or Substrate based tokens Multi-Wallet access Low Transaction and Gas Fees Chain transactions fees are going back to liquidity providers Fast Transaction Times 1500+ transactions per second Decentralized Governance Community Funding","title":"What makes Zukma unique?"},{"location":"#what-can-i-do-with-my-zep","text":"ZEP is the native coin of the Zukma Network and can be used for transaction fees, staking and governance. ZEP has utility in Zukma's democracy. Bonding ZEP is a requirement to create proposals, to second them and to vote on them when they become referendums.","title":"What can I do with my ZEP?"},{"location":"#how-does-zukma-work","text":"Zukma Network is maintained by a set of validators that are selected through the Nominated Proof of Stake (NPoS) consensus mechanism which is responsible for producing the blocks and determining finality. Validators and Nominators are rewarded if the validators behave correctly and offer all ZEP holders the opportunity to establish multiple passive income streams. Misbehavior is punished via the Slashing Mechanism. More details on incentives and economics can be reviewed here . Furthermore, Zukma Network has a decentralized governance scheme that can change any Zukma design decision and parameter. To interact with other blockchains that want to benefit from fast transaction times, low transaction fees and cross-chain capability, Zukma establishes bridges that offer a two-way compatibility, meaning that transactions can be made between different blockchains.","title":"How does Zukma work?"},{"location":"#why-should-you-use-zukma-network","text":"Whether you're a blockchain developer or if you're interested in taking part of Zukma's community, Zukma offers a platform for everyone. This wiki offers a place for developers and hodlers to utilize tools and for brand-new learners to dive into educational material.","title":"Why should you use Zukma Network?"},{"location":"#interact-with-zukma-network","text":"","title":"Interact with Zukma Network"},{"location":"#disclaimer","text":"Blockchain technologies are constantly evolving. This paper describes the best possible planned development, however, due to the nature of the technology and the complexity of integrating the world of blockchain. This document may be subject to change. We try to come close to the original plan, but sometimes modifications are necessary to improve the user experience and overcome technological barriers encountered during development.","title":"Disclaimer:"},{"location":"#references","text":"https://substrate.dev/docs/en/knowledgebase/smart-contracts/ https://substrate.dev/ Written by Zukma Team","title":"References"},{"location":"credits/","text":"HONOR TO WHOM HONOR IS DUE This documentation is standing on the shoulders of many brilliant minds within the blockchain universe. Many parts within the docs are closely oriented to existing documentations but slightly tailored to the specifications of Zukma. The entire Zukma Team would like to thank and credit the following projects and by thus honoring their contribution to the blockchain universe: PolkaDot Kusama Moonbeam Edgeware Galital Substrate Truffle Parity Technology Special thanks goes to Edgeware and Truffle for their development guides. Much love and respect , The Zukma Team Written by The Zukma Team","title":"Credits"},{"location":"credits/#honor-to-whom-honor-is-due","text":"This documentation is standing on the shoulders of many brilliant minds within the blockchain universe. Many parts within the docs are closely oriented to existing documentations but slightly tailored to the specifications of Zukma. The entire Zukma Team would like to thank and credit the following projects and by thus honoring their contribution to the blockchain universe: PolkaDot Kusama Moonbeam Edgeware Galital Substrate Truffle Parity Technology Special thanks goes to Edgeware and Truffle for their development guides. Much love and respect , The Zukma Team Written by The Zukma Team","title":"HONOR TO WHOM HONOR IS DUE"},{"location":"deep-dives/Using-Web3js/","text":"Using Web3.js with Zukma","title":"Using Web3.js"},{"location":"deep-dives/Using-Web3js/#using-web3js-with-zukma","text":"","title":"Using Web3.js with Zukma"},{"location":"deep-dives/bridges/","text":"Warning Work in progress content can change and it's not definitive .","title":"Bridges"},{"location":"deep-dives/bridges/#_1","text":"Warning Work in progress content can change and it's not definitive .","title":""},{"location":"deep-dives/evm-pallet/","text":"EVM Pallet The EVM module allows unmodified EVM code to be executed in a Substrate-based blockchain. EVM Engine The EVM module uses SputnikVM as the underlying EVM engine. Execution lifecycle There are a separate set of accounts managed by the EVM module. Substrate based accounts can call the EVM Module to deposit or withdraw balance from the Substrate base-currency into a different balance managed and used by the EVM module. Once a user has populated their balance, they can create and call smart contracts using this module. Substrate accounts and EVM external accounts are mapped via customizable conversion functions. EVM module vs Ethereum network The EVM module should be able to produce nearly identical results compared to the Ethereum mainnet, including gas cost and balance changes. Observable differences include: The available length of block hashes may not be 256 depending on the configuration of the System module in the Substrate runtime. Difficulty and coinbase, which do not make sense in this module and is currently hard coded to zero. We currently do not aim to make unobservable behaviors, such as state root, to be the same. We also don't aim to follow the exact same transaction / receipt format. However, given one Ethereum transaction and one Substrate account's private key, one should be able to convert any Ethereum transaction into a transaction compatible with this module. The gas configurations are configurable. Right now, a pre-defined Istanbul hard fork configuration option is provided.","title":"EVM Pallet"},{"location":"deep-dives/evm-pallet/#evm-pallet","text":"The EVM module allows unmodified EVM code to be executed in a Substrate-based blockchain.","title":"EVM Pallet"},{"location":"deep-dives/evm-pallet/#evm-engine","text":"The EVM module uses SputnikVM as the underlying EVM engine.","title":"EVM Engine"},{"location":"deep-dives/evm-pallet/#execution-lifecycle","text":"There are a separate set of accounts managed by the EVM module. Substrate based accounts can call the EVM Module to deposit or withdraw balance from the Substrate base-currency into a different balance managed and used by the EVM module. Once a user has populated their balance, they can create and call smart contracts using this module. Substrate accounts and EVM external accounts are mapped via customizable conversion functions.","title":"Execution lifecycle"},{"location":"deep-dives/evm-pallet/#evm-module-vs-ethereum-network","text":"The EVM module should be able to produce nearly identical results compared to the Ethereum mainnet, including gas cost and balance changes. Observable differences include: The available length of block hashes may not be 256 depending on the configuration of the System module in the Substrate runtime. Difficulty and coinbase, which do not make sense in this module and is currently hard coded to zero. We currently do not aim to make unobservable behaviors, such as state root, to be the same. We also don't aim to follow the exact same transaction / receipt format. However, given one Ethereum transaction and one Substrate account's private key, one should be able to convert any Ethereum transaction into a transaction compatible with this module. The gas configurations are configurable. Right now, a pre-defined Istanbul hard fork configuration option is provided.","title":"EVM module vs Ethereum network"},{"location":"deep-dives/staking/","text":"STAKING This guide will introduce you to the concept of staking on the Zukma Networks. ZEP are utilizing a {=Proof-of-Stake=} consensus mechanism to agree on processes like block authoring and finality. As the name implies, staking plays an essential role on both networks. In short, you have two options to stake. Either you stake in the form of nomination, or you stake by running a validation. But staking, in general, means that you bind your ZEP or holdings for a specific purpose and time to receive rewards in return. This guide will mainly focus on helping you decide to become a nominator or a validator and give you some examples of the rewards you could expect. Validator The staking system on Zukma is designed to pay out rewards equally to all validators, regardless of their stake. That means the amount of staked coins on a validator does not influence its ability to author or validate more blocks. However, there is a probabilistic component to reward calculation (discussed below), so rewards may not be exactly equal for all validators in a given era. Nominator The rewards for nominators are paid out pro-rata after the validator reward is deducted. That means your share of the total nominator rewards per validator will increase with the number of coins you staked on that specific validator. This system should motivate nominators to stake on lower-staked validators and thus should create a balanced-staked validator set. How does Staking work in Zukma Smart Chain Identify which role you are In staking, you can be either a nominator or a validator. As a nominator, you can nominate validator candidates that you trust to help you earn rewards in the chain's native coin. You can look at the nominator guide to understand your responsibilities as a nominator and at the validator guide to understand what you need to do as a validator. Nomination Period Anyone who wants to become a validator can decide to become a validator candidate at any time. The candidacy is made public to all nominators, who can vote (nominate) for their favorite validator candidates. At the beginning of a new era, the network selects the highest nominated validator candidates, becoming the active set for the forthcoming era. Caution as a Nominator Note that there are no prerequisites to candidate as a validator. Therefore, we strongly advise you to take a close look at the performance and reputation of the validators you want to stake on. Nomination is not a set-and-forget approach Staking Rewards Distribution To explain how rewards are paid to validators and nominators, we need to consider validator and nominator pools . A validator pool consists of the stake of an elected validator together with the nominators backing it. The nominator pool consists of the sum of nominated coins for that validator. As you can see in the illustration below, every validator pool receives essentially the same amount of coins for equal work. The network distributes the coins at the end of each era. However, there is a probabilistic component to staking rewards in era points and tips, but these should average over time. Every validator can set a customized commission, and the rest is paid pro-rata (proportional to stake) to the nominators. Validator If a validator stakes on his validator node, his stake counts as self-nomination and is getting pro-rata rewards from the nominator pool. Notice in particular that the validator is rewarded twice: once in commission fees for validating (if their commission rate is above 0%) and once for nominating itself with their stake. If a validator's commission is set to 100%, no coins will be paid out to any nominations in the nominator pool. Rewards Mechanism By now, two concepts should be clear: Every validator pool is rewarded equally regardless of the total stake captured by that validator pool Smaller validator pools tend to reward nominators more per coin then pools with more stake. Notice that the reward mechanism gives nominators economic incentives to favor smaller validator pools. The reason behind that is to prevent a concentration of power among a small set of validators. Furthermore, it is in alignment with the principle of risk and reward. The smaller the validator pool, the higher the risk that the validator may have a bad reputation or inferior performance and the higher the reward per staked coin. Notice that there is no limitation of nominators that can stake on a validator, but there is a limitation of nominators a validator can pay rewards to. This condition is called oversubscribed . That said, once a payout on an oversubscribed validator takes place, only the top number of nominators are considered. So pay attention to signs of oversubscription. Warning for Validators and Nominators We also remark that when the network slashes a validator slot for misbehavior (e.g. validator offline, Equivocation, etc.) the slashed amount is a fixed percentage (and NOT a fixed amount), which means that validator pools with more stake get slashed more coins. Again, this is done to give nominators an economic incentive to shift their preferences and support less popular validators they consider trustworthy. Another point to note is that each validator candidate is free to set their desired commission fee (as a percentage of rewards) to cover operational costs. Since the network pays all validator pools the same, validator pools with lower commission fees pay more to nominators than pools with higher fees. Thus, each validator can choose between increasing their fees to earn more or decreasing their fees to attract more nominators and increase their chances of being elected. In the long term, we expect that all validators will need to be cost-efficient to remain competitive. Validators with a higher reputation will charge slightly higher commission fees (which is fair). Accounts To add an extra layer of protection, we advise creating two types of accounts: Controller Account Stash Account The Stash account is your cold wallet which holds your funds and delegates some functions to the controller account. A cold wallet can be completely offline and is usually used to store crypto. With this system of two wallets, we want to minimize the touchpoints with your stash account to minimize potential risks. The Controller account is your hot wallet and acts on behalf of your stash account. The controller is entitled to signal decisions about nominating and validating. For instance, it sets preferences for payout account and commission if you are a validator; the controller also sets your session key if you have enough funds to pay for the transaction fees of cause. Validator and Nominators As we learned, validator slots are limited, and they do most of the heavy lifting: they produce new block candidates in BABE (block production mechanism), vote, and reach a consensus in GRANDPA (block finality mechanism). In essence, validators validate the state transition function of the blockchain. Nominators, on the other hand, have far fewer responsibilities. These include monitoring their validators' performance (uptime), keeping an eye on changing commission rates (a validator can change commission at any time), and general health monitoring of their own and their validators' account. Expertise needed While not set-it-and-forget-it, the experience needed to become a nominator is less than the expertise required to be a reliable validator. Slashing Slashing is a critical concept to protect the network. The network has two fundamental requirements that it expects from every validator: Be online Stay honest Slashing will happen if the system detects that a validator misbehaves (e.g., goes offline, attacks the network, or runs modified software) in the network. The validator and its nominators will get slashed in relation to the offense by losing a percentage of their bonded/staked coins. The network will add any slashed coin to the Treasury. The rationale for this (rather than burning or distributing them as rewards) is that the Council may revert slashes by simply paying out from the Treasury. The option to revert slashes would be helpful in situations such as a faulty runtime causing slashing or forcing validators offline through no fault of their own. In the case of legitimate slashing, it moves tokens away from malicious validators to those building the ecosystem through the normal Treasury process. Slashing It is essential to realize that slashing occurs for active validations. Each validator is considered its entity for purposes of slashing, just as they are for staking rewards. What are some root causes for getting slashed? We group the root causes into three distinct clusters: Liveliness Equivocation Misconduct Liveliness Liveliness is concerned about the ability of the validator to be online and responsive. If a validator misses producing a block or sending a heartbeat signal during an era, the validator will be considered offline and put on chill. In that case, no slashing of coins occurs, but since the validator did not contribute any work, no block rewards are paid to the validator pool. Equivocation Multiple signing in the consensus mechanism protocols. To elaborate a bit further: The network expects that only one validator validates a block by pointing to the block and signing it. If multiple validators claim to have signed the most recent block we have a case of Equivocation, where other validators essentially duplicates the effort of an honest validator. In the case of Equivocation the penality is calculated in a manner that takes into account the likelihood of being an coordinated attack or not. The penalties are calculated by the following formula let x = offenders, n = total number of validators in the active set penality = MIN((3*x/n)^2 , 1) Example 01 Example 02 Example 03 Assume that there are 100 validators in the active set, and one of them equivocates in a slot. This is unlikely to be an attack on the network, but much more likely to be a misconfiguration of a validator x = 1, n = 100 penality = MIN((3*1/100)^2 , 1) = MIN(0,0009, 1) = 0,0009 = 0,09% The slash will apply to this validator, and the validator will be chilled. Now assume that there is a group of 5 validators, and all of them have an issue in the same slot. x = 5, n = 100 penality = MIN((3*5/100)^2 , 1) = MIN(0,0225, 1) = 0,0225 = 2,25% The slash will be applied to the 5 validators pools and their nominators. All slashed validators will also be chilled. Now assume that there is a group of 20 validators, and all of them have an issue in the same slot. x = 20, n = 100 penality = MIN((3*20/100)^2 , 1) = MIN(0,36, 1) = 0,36 = 36,0% The slash will be applied to the 20 validator pools and their nominators. All slashed validators will also be chilled. Misconduct Misconducts are behaviors that pose a security or monetary risk to the network or can cause mass collisions. Therefore, misconducts are the highest punished behavior in the Zukma and Zukma Smart Chain networks. Reported and confirmed slashes in that category can lead to the transfer of the funds inside the validator pool to the Treasury and could ultimately be burned. Warning If a validator is reported for any one of the offenses, they will be removed from the validator set (chilled), and they will not be paid while they are out. They will be considered inactive immediately and will lose their nominators. They need to re-issue intent to validate and again gather support from nominators. Slashing Consequences Isolated Event >10% of validators offending >33% of validators offending Liveliness Chill, no slash Chill, plus penalties that increase linearly with the number of corresponding validators that are offline Slash increases, requires 44% to attain a maximum slash of 7% Equivocation Chill, plus slash of 0,01% (assuming 300 active validators) Slash, increases in a linear manner Maximum slash of 100% Misconduct 100% Slash 100% Slash 100% Slash Warning All slashes include the loss of all nominators! Chilling Chilling is the act of stepping back from any nominating or validating. It can be done by a validator or nominator at any time themselves, taking effect in the next era. It can also specifically mean removing a validator from the active validator set by another validator, disqualifying them from the set of electable candidates in the next NPoS cycle. Chilling may be voluntary and validator-initiated, e.g. if there is a planned outage in the validator's surroundings or hosting provider, and the validator wants to exit to protect themselves against slashing. When voluntary, chilling will keep the validator active in the current session but will move them to the inactive set in the next. The validator will not lose their nominators. When used as part of a punishment (initiated externally), being chilled carries an implied penalty of being un-nominated. It also disables the validator for the remainder of the current era and removes the offending validator from the next election. Potential causes for liveliness slashes Let's look at events that can cause a slash under Liveliness. To break this down, we differentiate between two scenarios: You have an existing server You install a new server or migrate to a new server Existing Server Potential causes are: - Server is offline - Firewall or network connectivity prevents communication to the network - SDD is full and prevents further syncing New Server / Migration Potential causes are: - The validator instance may not be started with the -- validator flag - If you switch servers you may not have applied the correct session key - Your node might not be fully synchronized How to mitigate the risk of being slashed on Liveliness? Let's have a look into what operators can do to reduce the risk of getting slashed under Liveliness. Monitoring Using monitoring tools like grafana and prometheus, together with PagerDuty for alerts Trigger alerts when the service is unreachable or when blocks are stalled (e.g, 100 blocks) Checklists Ensure that session-keys are verified on the destination server Ensure that the --validator flag exists Understand server migration wait times. It takes at least 2 eras before new keys are applied Potential causes for equivocation slashes Equivocation slashes are caused if multiple validators claim to have signed the same block. This can be caused by: If you cloned a validator to be used as a backup or during the migration of your validator to a new server. Using a failover system to provide \"zero-downtime\" Copying the keystore folder when trying to copy the database How to mitigate the risk of being slashed on Equivocation? Never copy your Keystore folder to another server If your server went offline spontaneously, do not panic and attempt to restore a cloned server to minimize downtime Use a backup server, if it is not fully synced use a snapshot to do so quickly using 7zz for extraction. Apply a freshly generated set of keys from this server to the stash It is better to be chilled with no loss than attempt a zero downtime maneuver and get slashed Potential causes for unintentional misconduct In this paragraph, we assume that Misconduct is conducted unintentionally and want to provide some reasons for a slash under unintentional Misconduct. Using a binary from a third-party location that might be altered Compromised server in which an unwanted third party alters code in an undesired manner How to mitigate the risk of being slashed on unintentional Misconduct? Always download the source files and binaries from the official Zukma server Verify the hash of the downloaded binaries Use the \"secure validator\" server setup on the w3f rep or adhere to its principles Basic security advice applies, use a firewall, manage user access, use SSH certificate access etc. Avoid using your server as a general-purpose machine. Greater interaction = greater risk. Warning Work in progress content can change and it's not definitive .","title":"Staking"},{"location":"deep-dives/staking/#staking","text":"This guide will introduce you to the concept of staking on the Zukma Networks. ZEP are utilizing a {=Proof-of-Stake=} consensus mechanism to agree on processes like block authoring and finality. As the name implies, staking plays an essential role on both networks. In short, you have two options to stake. Either you stake in the form of nomination, or you stake by running a validation. But staking, in general, means that you bind your ZEP or holdings for a specific purpose and time to receive rewards in return. This guide will mainly focus on helping you decide to become a nominator or a validator and give you some examples of the rewards you could expect. Validator The staking system on Zukma is designed to pay out rewards equally to all validators, regardless of their stake. That means the amount of staked coins on a validator does not influence its ability to author or validate more blocks. However, there is a probabilistic component to reward calculation (discussed below), so rewards may not be exactly equal for all validators in a given era. Nominator The rewards for nominators are paid out pro-rata after the validator reward is deducted. That means your share of the total nominator rewards per validator will increase with the number of coins you staked on that specific validator. This system should motivate nominators to stake on lower-staked validators and thus should create a balanced-staked validator set.","title":"STAKING"},{"location":"deep-dives/staking/#how-does-staking-work-in-zukma-smart-chain","text":"","title":"How does Staking work in Zukma Smart Chain"},{"location":"deep-dives/staking/#identify-which-role-you-are","text":"In staking, you can be either a nominator or a validator. As a nominator, you can nominate validator candidates that you trust to help you earn rewards in the chain's native coin. You can look at the nominator guide to understand your responsibilities as a nominator and at the validator guide to understand what you need to do as a validator.","title":"Identify which role you are"},{"location":"deep-dives/staking/#nomination-period","text":"Anyone who wants to become a validator can decide to become a validator candidate at any time. The candidacy is made public to all nominators, who can vote (nominate) for their favorite validator candidates. At the beginning of a new era, the network selects the highest nominated validator candidates, becoming the active set for the forthcoming era. Caution as a Nominator Note that there are no prerequisites to candidate as a validator. Therefore, we strongly advise you to take a close look at the performance and reputation of the validators you want to stake on. Nomination is not a set-and-forget approach","title":"Nomination Period"},{"location":"deep-dives/staking/#staking-rewards-distribution","text":"To explain how rewards are paid to validators and nominators, we need to consider validator and nominator pools . A validator pool consists of the stake of an elected validator together with the nominators backing it. The nominator pool consists of the sum of nominated coins for that validator. As you can see in the illustration below, every validator pool receives essentially the same amount of coins for equal work. The network distributes the coins at the end of each era. However, there is a probabilistic component to staking rewards in era points and tips, but these should average over time. Every validator can set a customized commission, and the rest is paid pro-rata (proportional to stake) to the nominators. Validator If a validator stakes on his validator node, his stake counts as self-nomination and is getting pro-rata rewards from the nominator pool. Notice in particular that the validator is rewarded twice: once in commission fees for validating (if their commission rate is above 0%) and once for nominating itself with their stake. If a validator's commission is set to 100%, no coins will be paid out to any nominations in the nominator pool.","title":"Staking Rewards Distribution"},{"location":"deep-dives/staking/#rewards-mechanism","text":"By now, two concepts should be clear: Every validator pool is rewarded equally regardless of the total stake captured by that validator pool Smaller validator pools tend to reward nominators more per coin then pools with more stake. Notice that the reward mechanism gives nominators economic incentives to favor smaller validator pools. The reason behind that is to prevent a concentration of power among a small set of validators. Furthermore, it is in alignment with the principle of risk and reward. The smaller the validator pool, the higher the risk that the validator may have a bad reputation or inferior performance and the higher the reward per staked coin. Notice that there is no limitation of nominators that can stake on a validator, but there is a limitation of nominators a validator can pay rewards to. This condition is called oversubscribed . That said, once a payout on an oversubscribed validator takes place, only the top number of nominators are considered. So pay attention to signs of oversubscription. Warning for Validators and Nominators We also remark that when the network slashes a validator slot for misbehavior (e.g. validator offline, Equivocation, etc.) the slashed amount is a fixed percentage (and NOT a fixed amount), which means that validator pools with more stake get slashed more coins. Again, this is done to give nominators an economic incentive to shift their preferences and support less popular validators they consider trustworthy. Another point to note is that each validator candidate is free to set their desired commission fee (as a percentage of rewards) to cover operational costs. Since the network pays all validator pools the same, validator pools with lower commission fees pay more to nominators than pools with higher fees. Thus, each validator can choose between increasing their fees to earn more or decreasing their fees to attract more nominators and increase their chances of being elected. In the long term, we expect that all validators will need to be cost-efficient to remain competitive. Validators with a higher reputation will charge slightly higher commission fees (which is fair).","title":"Rewards Mechanism"},{"location":"deep-dives/staking/#accounts","text":"To add an extra layer of protection, we advise creating two types of accounts: Controller Account Stash Account The Stash account is your cold wallet which holds your funds and delegates some functions to the controller account. A cold wallet can be completely offline and is usually used to store crypto. With this system of two wallets, we want to minimize the touchpoints with your stash account to minimize potential risks. The Controller account is your hot wallet and acts on behalf of your stash account. The controller is entitled to signal decisions about nominating and validating. For instance, it sets preferences for payout account and commission if you are a validator; the controller also sets your session key if you have enough funds to pay for the transaction fees of cause.","title":"Accounts"},{"location":"deep-dives/staking/#validator-and-nominators","text":"As we learned, validator slots are limited, and they do most of the heavy lifting: they produce new block candidates in BABE (block production mechanism), vote, and reach a consensus in GRANDPA (block finality mechanism). In essence, validators validate the state transition function of the blockchain. Nominators, on the other hand, have far fewer responsibilities. These include monitoring their validators' performance (uptime), keeping an eye on changing commission rates (a validator can change commission at any time), and general health monitoring of their own and their validators' account. Expertise needed While not set-it-and-forget-it, the experience needed to become a nominator is less than the expertise required to be a reliable validator.","title":"Validator and Nominators"},{"location":"deep-dives/staking/#slashing","text":"Slashing is a critical concept to protect the network. The network has two fundamental requirements that it expects from every validator: Be online Stay honest Slashing will happen if the system detects that a validator misbehaves (e.g., goes offline, attacks the network, or runs modified software) in the network. The validator and its nominators will get slashed in relation to the offense by losing a percentage of their bonded/staked coins. The network will add any slashed coin to the Treasury. The rationale for this (rather than burning or distributing them as rewards) is that the Council may revert slashes by simply paying out from the Treasury. The option to revert slashes would be helpful in situations such as a faulty runtime causing slashing or forcing validators offline through no fault of their own. In the case of legitimate slashing, it moves tokens away from malicious validators to those building the ecosystem through the normal Treasury process. Slashing It is essential to realize that slashing occurs for active validations. Each validator is considered its entity for purposes of slashing, just as they are for staking rewards.","title":"Slashing"},{"location":"deep-dives/staking/#what-are-some-root-causes-for-getting-slashed","text":"We group the root causes into three distinct clusters: Liveliness Equivocation Misconduct Liveliness Liveliness is concerned about the ability of the validator to be online and responsive. If a validator misses producing a block or sending a heartbeat signal during an era, the validator will be considered offline and put on chill. In that case, no slashing of coins occurs, but since the validator did not contribute any work, no block rewards are paid to the validator pool. Equivocation Multiple signing in the consensus mechanism protocols. To elaborate a bit further: The network expects that only one validator validates a block by pointing to the block and signing it. If multiple validators claim to have signed the most recent block we have a case of Equivocation, where other validators essentially duplicates the effort of an honest validator. In the case of Equivocation the penality is calculated in a manner that takes into account the likelihood of being an coordinated attack or not. The penalties are calculated by the following formula let x = offenders, n = total number of validators in the active set penality = MIN((3*x/n)^2 , 1) Example 01 Example 02 Example 03 Assume that there are 100 validators in the active set, and one of them equivocates in a slot. This is unlikely to be an attack on the network, but much more likely to be a misconfiguration of a validator x = 1, n = 100 penality = MIN((3*1/100)^2 , 1) = MIN(0,0009, 1) = 0,0009 = 0,09% The slash will apply to this validator, and the validator will be chilled. Now assume that there is a group of 5 validators, and all of them have an issue in the same slot. x = 5, n = 100 penality = MIN((3*5/100)^2 , 1) = MIN(0,0225, 1) = 0,0225 = 2,25% The slash will be applied to the 5 validators pools and their nominators. All slashed validators will also be chilled. Now assume that there is a group of 20 validators, and all of them have an issue in the same slot. x = 20, n = 100 penality = MIN((3*20/100)^2 , 1) = MIN(0,36, 1) = 0,36 = 36,0% The slash will be applied to the 20 validator pools and their nominators. All slashed validators will also be chilled. Misconduct Misconducts are behaviors that pose a security or monetary risk to the network or can cause mass collisions. Therefore, misconducts are the highest punished behavior in the Zukma and Zukma Smart Chain networks. Reported and confirmed slashes in that category can lead to the transfer of the funds inside the validator pool to the Treasury and could ultimately be burned. Warning If a validator is reported for any one of the offenses, they will be removed from the validator set (chilled), and they will not be paid while they are out. They will be considered inactive immediately and will lose their nominators. They need to re-issue intent to validate and again gather support from nominators.","title":"What are some root causes for getting slashed?"},{"location":"deep-dives/staking/#slashing-consequences","text":"Isolated Event >10% of validators offending >33% of validators offending Liveliness Chill, no slash Chill, plus penalties that increase linearly with the number of corresponding validators that are offline Slash increases, requires 44% to attain a maximum slash of 7% Equivocation Chill, plus slash of 0,01% (assuming 300 active validators) Slash, increases in a linear manner Maximum slash of 100% Misconduct 100% Slash 100% Slash 100% Slash Warning All slashes include the loss of all nominators!","title":"Slashing Consequences"},{"location":"deep-dives/staking/#chilling","text":"Chilling is the act of stepping back from any nominating or validating. It can be done by a validator or nominator at any time themselves, taking effect in the next era. It can also specifically mean removing a validator from the active validator set by another validator, disqualifying them from the set of electable candidates in the next NPoS cycle. Chilling may be voluntary and validator-initiated, e.g. if there is a planned outage in the validator's surroundings or hosting provider, and the validator wants to exit to protect themselves against slashing. When voluntary, chilling will keep the validator active in the current session but will move them to the inactive set in the next. The validator will not lose their nominators. When used as part of a punishment (initiated externally), being chilled carries an implied penalty of being un-nominated. It also disables the validator for the remainder of the current era and removes the offending validator from the next election.","title":"Chilling"},{"location":"deep-dives/staking/#potential-causes-for-liveliness-slashes","text":"Let's look at events that can cause a slash under Liveliness. To break this down, we differentiate between two scenarios: You have an existing server You install a new server or migrate to a new server Existing Server Potential causes are: - Server is offline - Firewall or network connectivity prevents communication to the network - SDD is full and prevents further syncing New Server / Migration Potential causes are: - The validator instance may not be started with the -- validator flag - If you switch servers you may not have applied the correct session key - Your node might not be fully synchronized","title":"Potential causes for liveliness slashes"},{"location":"deep-dives/staking/#how-to-mitigate-the-risk-of-being-slashed-on-liveliness","text":"Let's have a look into what operators can do to reduce the risk of getting slashed under Liveliness. Monitoring Using monitoring tools like grafana and prometheus, together with PagerDuty for alerts Trigger alerts when the service is unreachable or when blocks are stalled (e.g, 100 blocks) Checklists Ensure that session-keys are verified on the destination server Ensure that the --validator flag exists Understand server migration wait times. It takes at least 2 eras before new keys are applied","title":"How to mitigate the risk of being slashed on Liveliness?"},{"location":"deep-dives/staking/#potential-causes-for-equivocation-slashes","text":"Equivocation slashes are caused if multiple validators claim to have signed the same block. This can be caused by: If you cloned a validator to be used as a backup or during the migration of your validator to a new server. Using a failover system to provide \"zero-downtime\" Copying the keystore folder when trying to copy the database","title":"Potential causes for equivocation slashes"},{"location":"deep-dives/staking/#how-to-mitigate-the-risk-of-being-slashed-on-equivocation","text":"Never copy your Keystore folder to another server If your server went offline spontaneously, do not panic and attempt to restore a cloned server to minimize downtime Use a backup server, if it is not fully synced use a snapshot to do so quickly using 7zz for extraction. Apply a freshly generated set of keys from this server to the stash It is better to be chilled with no loss than attempt a zero downtime maneuver and get slashed","title":"How to mitigate the risk of being slashed on Equivocation?"},{"location":"deep-dives/staking/#potential-causes-for-unintentional-misconduct","text":"In this paragraph, we assume that Misconduct is conducted unintentionally and want to provide some reasons for a slash under unintentional Misconduct. Using a binary from a third-party location that might be altered Compromised server in which an unwanted third party alters code in an undesired manner","title":"Potential causes for unintentional misconduct"},{"location":"deep-dives/staking/#how-to-mitigate-the-risk-of-being-slashed-on-unintentional-misconduct","text":"Always download the source files and binaries from the official Zukma server Verify the hash of the downloaded binaries Use the \"secure validator\" server setup on the w3f rep or adhere to its principles Basic security advice applies, use a firewall, manage user access, use SSH certificate access etc. Avoid using your server as a general-purpose machine. Greater interaction = greater risk. Warning Work in progress content can change and it's not definitive .","title":"How to mitigate the risk of being slashed on unintentional Misconduct?"},{"location":"deep-dives/substrate_keys/","text":"Substrate Keys Public and private keys are an essential aspect of most crypto-systems and an essential component that enables blockchains to exist. Account Keys Account keys are keys that are meant to control funds. They can be either: The vanilla ed25519 implementation using Schnorr signatures. The Schnorrkel/Ristretto sr25519 variant using Schnorr signatures. ECDSA signatures on secp256k1 There are no differences in security between ed25519 and sr25519 for simple signatures. We expect ed25519 to be much better supported by commercial HSMs for the foreseeable future. At the same time, r25519 makes implementing more complex protocols safer. In particular, sr25519 comes with safer version of many protocols like HDKD common in the Bitcoin and Ethereum ecosystem. \"Controller\" and \"Stash\" Keys When we talk about \"controller\" and \"stash\" keys, we usually talk about them in the context of running a validator or nominating ZEP. Still, they are valuable concepts for all users to know. Both keys are types of account keys. They are distinguished by their intended use, not by an underlying cryptographic difference. When creating new controller or stash keys, all cryptography supported by account keys is an available option. The controller key is a semi-online key that will be in the user's direct control and used to submit manual extrinsics. This means that validators and nominators will use the controller key to start or stop validating or nominating. Warning Controller keys should hold some ZEP to pay for fees, but You should not use them to hodl massive amounts or life savings since the blockchain will expose them to the internet with relative frequency. You should treat them carefully and occasionally replaced them with new ones. The stash key is a key that will, in most cases, be a cold wallet, existing on a piece of paper in a safe or protected by layers of hardware security. It should rarely if ever, be exposed to the internet or used to submit extrinsics. The stash key is intended to hold a large amount of funds. You can compare it to a savings account at a bank, which ideally is only ever touched in urgent conditions. Or, perhaps a more apt metaphor is to think of it as buried treasure, hidden on some random island and only known by the pirate who initially hid it. Since the stash key is kept offline, it must be set to bond its funds to a particular controller. For non-spending actions, the controller has the funds of the stash behind it. For example, in nominating, staking, or voting, the controller, can indicate its preference with the weight of the stash. It will never be able to move or claim the funds in the stash key. However, if someone does obtain your controller key, they could use it for slashable behavior, so you should still protect it and change it regularly. Session Keys Session keys are active or \"hot\" keys that a validator must keep online to perform network operations. Session keys are typically generated by the client, e.g., your Zukma Node instance on your server, although they don't have to be. The session keys are not meant to control funds, and you should only use them for their intended purpose. You can change them regularly; your controller account only needs to create a certificate by signing a session public key and broadcast this certificate via an extrinsic. Our blockchain uses three session keys: - GRANDPA: ed25519 - BABE: sr25519 - I'm Online: sr25519 Summary Account keys are essential to blockchains because they allow you to control your funds. The blockchain publishes your public keys to the network, as the name implies. Your wallet address is an excellent example of a public key. Your private key, in contrast, should be protected and kept secret at all times because, with the private key, anybody could move your funds. Our blockchain uses controller keys (a second wallet) to speak for your main wallet's stash keys (public and private keys) that control your funds. However, the controller keys are limited to just acting on behalf but are never capable of making a transaction. This Setup of a \"hot\" wallet (controller) that you use to engage with the network and the \"cold\" wallet (stash) that holds the funds grants you an extra layer of security. Finally, Session keys are generated by the validator node itself and used by the validator to perform network actions continuously. You can change session keys at any time.","title":"Keys"},{"location":"deep-dives/substrate_keys/#substrate-keys","text":"Public and private keys are an essential aspect of most crypto-systems and an essential component that enables blockchains to exist.","title":"Substrate Keys"},{"location":"deep-dives/substrate_keys/#account-keys","text":"Account keys are keys that are meant to control funds. They can be either: The vanilla ed25519 implementation using Schnorr signatures. The Schnorrkel/Ristretto sr25519 variant using Schnorr signatures. ECDSA signatures on secp256k1 There are no differences in security between ed25519 and sr25519 for simple signatures. We expect ed25519 to be much better supported by commercial HSMs for the foreseeable future. At the same time, r25519 makes implementing more complex protocols safer. In particular, sr25519 comes with safer version of many protocols like HDKD common in the Bitcoin and Ethereum ecosystem.","title":"Account Keys"},{"location":"deep-dives/substrate_keys/#controller-and-stash-keys","text":"When we talk about \"controller\" and \"stash\" keys, we usually talk about them in the context of running a validator or nominating ZEP. Still, they are valuable concepts for all users to know. Both keys are types of account keys. They are distinguished by their intended use, not by an underlying cryptographic difference. When creating new controller or stash keys, all cryptography supported by account keys is an available option. The controller key is a semi-online key that will be in the user's direct control and used to submit manual extrinsics. This means that validators and nominators will use the controller key to start or stop validating or nominating. Warning Controller keys should hold some ZEP to pay for fees, but You should not use them to hodl massive amounts or life savings since the blockchain will expose them to the internet with relative frequency. You should treat them carefully and occasionally replaced them with new ones. The stash key is a key that will, in most cases, be a cold wallet, existing on a piece of paper in a safe or protected by layers of hardware security. It should rarely if ever, be exposed to the internet or used to submit extrinsics. The stash key is intended to hold a large amount of funds. You can compare it to a savings account at a bank, which ideally is only ever touched in urgent conditions. Or, perhaps a more apt metaphor is to think of it as buried treasure, hidden on some random island and only known by the pirate who initially hid it. Since the stash key is kept offline, it must be set to bond its funds to a particular controller. For non-spending actions, the controller has the funds of the stash behind it. For example, in nominating, staking, or voting, the controller, can indicate its preference with the weight of the stash. It will never be able to move or claim the funds in the stash key. However, if someone does obtain your controller key, they could use it for slashable behavior, so you should still protect it and change it regularly.","title":"\"Controller\" and \"Stash\" Keys"},{"location":"deep-dives/substrate_keys/#session-keys","text":"Session keys are active or \"hot\" keys that a validator must keep online to perform network operations. Session keys are typically generated by the client, e.g., your Zukma Node instance on your server, although they don't have to be. The session keys are not meant to control funds, and you should only use them for their intended purpose. You can change them regularly; your controller account only needs to create a certificate by signing a session public key and broadcast this certificate via an extrinsic. Our blockchain uses three session keys: - GRANDPA: ed25519 - BABE: sr25519 - I'm Online: sr25519","title":"Session Keys"},{"location":"deep-dives/substrate_keys/#summary","text":"Account keys are essential to blockchains because they allow you to control your funds. The blockchain publishes your public keys to the network, as the name implies. Your wallet address is an excellent example of a public key. Your private key, in contrast, should be protected and kept secret at all times because, with the private key, anybody could move your funds. Our blockchain uses controller keys (a second wallet) to speak for your main wallet's stash keys (public and private keys) that control your funds. However, the controller keys are limited to just acting on behalf but are never capable of making a transaction. This Setup of a \"hot\" wallet (controller) that you use to engage with the network and the \"cold\" wallet (stash) that holds the funds grants you an extra layer of security. Finally, Session keys are generated by the validator node itself and used by the validator to perform network actions continuously. You can change session keys at any time.","title":"Summary"},{"location":"dev-guides/","text":"Smart Contracts On Zukma you have two out-of-the-box solutions to kickstart your Smart Contract development. The EVM (Ethereum Virtual Machine) pallet, which presents an Ethereum compatibility layer The Contracts pallet, which is a FRAME library for Wasm based smart contracts EVM Contracts by Frontier Frontier is the Ethereum compatibility layer for Substrate chains. It enables Zukma to run Ethereum contacts (EVM) natively, that means for instance that all existing Ethereum RPC methods work, so none of your dapps will break. Furthermore, it allows you to run your EVM smart contract natively in Substrate, tightly integrated with the rest of the Substrate ecosystem. Read more in our EVM Pallet Deep Dive! Contracts Pallet The experience of deploying to an EVM-based chain may be more familiar to developers that have written smart contracts before. However, the Contracts pallet makes some notable improvements to the design of the EVM: Wasm. The Contracts pallet uses WebAssembly as its compilation target. Any language that compiles to Wasm can potentially be used to write smart contracts. Nevertheless, it is better to have a dedicated domain-specific language, and for that reason Parity offers the ink! language. Rent. Contracts must pay rent or else hold a deposit suitably large enough in order to justify its existence on-chain. When a contract does not uphold this, it may create what's called a tombstone which is a reference to the contract. In some conditions, the contract will be deleted outright along with its storage if it does not maintain these requirements. Caching. Contracts are cached by default and therefore means they only need to be deployed once and afterward be instantiated as many times as you want. This helps to keep the storage load on the chain down to the minimum. On top of this, when a contract is no longer being used and the existential deposit is drained, the code will be erased from storage (known as reaping). Ink! ink! is a domain specific language for writing smart contracts in Rust and compiles to Wasm code. As it states in its README, it is still in an experimental phase so brave developers should be aware that they might have a bumpy - but workable - development experience. There are some projects that have built projects in ink! with a decent level of complexity such as Plasm's Plasma contracts , so it is mature enough to start building interesting things. For interested developers, they can get started writing smart contracts using ink! by studying the examples that were already written. These can be used as guideposts to writing more complex logic that will be deployable on smart contract parachains. ink! has laid much of the groundwork for a new smart contract stack that is based on a Wasm virtual machine and compatible with Substrate chains. Parity Tech ink! Contracts pallet Written by Zukma Team","title":"<b>Smart Contracts</b>"},{"location":"dev-guides/#smart-contracts","text":"On Zukma you have two out-of-the-box solutions to kickstart your Smart Contract development. The EVM (Ethereum Virtual Machine) pallet, which presents an Ethereum compatibility layer The Contracts pallet, which is a FRAME library for Wasm based smart contracts","title":"Smart Contracts"},{"location":"dev-guides/#evm-contracts-by-frontier","text":"Frontier is the Ethereum compatibility layer for Substrate chains. It enables Zukma to run Ethereum contacts (EVM) natively, that means for instance that all existing Ethereum RPC methods work, so none of your dapps will break. Furthermore, it allows you to run your EVM smart contract natively in Substrate, tightly integrated with the rest of the Substrate ecosystem. Read more in our EVM Pallet Deep Dive!","title":"EVM Contracts by Frontier"},{"location":"dev-guides/#contracts-pallet","text":"The experience of deploying to an EVM-based chain may be more familiar to developers that have written smart contracts before. However, the Contracts pallet makes some notable improvements to the design of the EVM: Wasm. The Contracts pallet uses WebAssembly as its compilation target. Any language that compiles to Wasm can potentially be used to write smart contracts. Nevertheless, it is better to have a dedicated domain-specific language, and for that reason Parity offers the ink! language. Rent. Contracts must pay rent or else hold a deposit suitably large enough in order to justify its existence on-chain. When a contract does not uphold this, it may create what's called a tombstone which is a reference to the contract. In some conditions, the contract will be deleted outright along with its storage if it does not maintain these requirements. Caching. Contracts are cached by default and therefore means they only need to be deployed once and afterward be instantiated as many times as you want. This helps to keep the storage load on the chain down to the minimum. On top of this, when a contract is no longer being used and the existential deposit is drained, the code will be erased from storage (known as reaping).","title":"Contracts Pallet"},{"location":"dev-guides/#ink","text":"ink! is a domain specific language for writing smart contracts in Rust and compiles to Wasm code. As it states in its README, it is still in an experimental phase so brave developers should be aware that they might have a bumpy - but workable - development experience. There are some projects that have built projects in ink! with a decent level of complexity such as Plasm's Plasma contracts , so it is mature enough to start building interesting things. For interested developers, they can get started writing smart contracts using ink! by studying the examples that were already written. These can be used as guideposts to writing more complex logic that will be deployable on smart contract parachains. ink! has laid much of the groundwork for a new smart contract stack that is based on a Wasm virtual machine and compatible with Substrate chains. Parity Tech ink! Contracts pallet Written by Zukma Team","title":"Ink!"},{"location":"dev-guides/Tutorials/","text":"Tutorials The previous section has given you a mental model and shown the requisite resources to help you determine and start building your project as smart contract today. It's time to head over to the tutorial section which will teach you how to build EVM based smart contracts. The EVM Tutorial , will cover: Setting up an Zukma node Setting up Metamask to work with Zukma Using Remix as an Ethereum IDE to compile, deploy, and call a contract Using Truffle to deploy a contract to Kusari Using Web3.js to interact with Zukma contracts programmatically We would love for you to give feedback in these early stages, so please feel free to join our Discord Server and engage with the community! How to participate in the Zukma Smart Contracts Developers Squad? Technical Chats Telegram DApps Channel Written by Zukma Team","title":"**Tutorials**"},{"location":"dev-guides/Tutorials/#tutorials","text":"The previous section has given you a mental model and shown the requisite resources to help you determine and start building your project as smart contract today. It's time to head over to the tutorial section which will teach you how to build EVM based smart contracts. The EVM Tutorial , will cover: Setting up an Zukma node Setting up Metamask to work with Zukma Using Remix as an Ethereum IDE to compile, deploy, and call a contract Using Truffle to deploy a contract to Kusari Using Web3.js to interact with Zukma contracts programmatically We would love for you to give feedback in these early stages, so please feel free to join our Discord Server and engage with the community!","title":"Tutorials"},{"location":"dev-guides/Tutorials/#how-to-participate-in-the-zukma-smart-contracts-developers-squad","text":"Technical Chats Telegram DApps Channel Written by Zukma Team","title":"How to participate in the Zukma Smart Contracts Developers Squad?"},{"location":"dev-guides/Tutorials/evm-tutorial/","text":"Zukma and EVM Zukma has a pallet that allows developers to write EVM smart-contracts. This means that you can use Zukma as you would with Ethereum. Zukma is fully compatible with Ethereum's Web3 API and EVM. Here, we'll walk through a few subtle differences between Zukma and Ethereum. Namely, Zukma has a Nominated Proof of Stake (NPOS) consensus mechanism. This shouldn't affect you if you're building a DeFi or NFT based application. See our related documentation on proof-of-stake. In the following sections we detail Zukma<>EVM Compatibility. Full-Ethereum API and Tooling Compatibility If you're moving some portion of your smart contracts, state, or considering porting your full set of contracts off Ethereum to Zukma, it should 'just work'. That is the full set of your application, contracts, and tooling will remain the same. Zukma will be able to support: Solidity and Serpent Based Smart Contracts Ecosystem Tools (e.g., block explorers, front-end development libraries, wallets--i.e Metamask) Development Tools (e.g., Truffle, Remix, MetaMask, ethers, web3js) Ethereum Tokens via Bridges (e.g., token movement, state visibility, message passing) You can view our tutorials to get a better feel for building Ethereum smart contracts on Zukma, and how to directly offload or migrate your Ethereum application onto Zukma. As previously mentioned, Zukma is Nominated Proof of Stake (NPOS). This does mean that smart contracts that rely on components of Ethereum's API that touch on Proof of Work--difficulty, uncles, hash-rate won't work as expected on Zukma. For those values, we have constant values set at the runtime level. Existing Ethereum contracts that rely on Proof of Work internals (e.g., mining pool contracts) will almost certainly not work as expected on Zukma. How Zukma achieves Ethereum Compatibility We achieve Ethereum compatibility with three integrated components. If you're a smart contract developer, this may just be of passing interest. Pallet Ethereum: which allows for full Ethereum Block Processing SputnikEVM: You can view the full documentation here: EVM: which allows you to deploy","title":"<b>Zukma and EVM</b>"},{"location":"dev-guides/Tutorials/evm-tutorial/#zukma-and-evm","text":"Zukma has a pallet that allows developers to write EVM smart-contracts. This means that you can use Zukma as you would with Ethereum. Zukma is fully compatible with Ethereum's Web3 API and EVM. Here, we'll walk through a few subtle differences between Zukma and Ethereum. Namely, Zukma has a Nominated Proof of Stake (NPOS) consensus mechanism. This shouldn't affect you if you're building a DeFi or NFT based application. See our related documentation on proof-of-stake. In the following sections we detail Zukma<>EVM Compatibility.","title":"Zukma and EVM"},{"location":"dev-guides/Tutorials/evm-tutorial/#full-ethereum-api-and-tooling-compatibility","text":"If you're moving some portion of your smart contracts, state, or considering porting your full set of contracts off Ethereum to Zukma, it should 'just work'. That is the full set of your application, contracts, and tooling will remain the same. Zukma will be able to support: Solidity and Serpent Based Smart Contracts Ecosystem Tools (e.g., block explorers, front-end development libraries, wallets--i.e Metamask) Development Tools (e.g., Truffle, Remix, MetaMask, ethers, web3js) Ethereum Tokens via Bridges (e.g., token movement, state visibility, message passing) You can view our tutorials to get a better feel for building Ethereum smart contracts on Zukma, and how to directly offload or migrate your Ethereum application onto Zukma. As previously mentioned, Zukma is Nominated Proof of Stake (NPOS). This does mean that smart contracts that rely on components of Ethereum's API that touch on Proof of Work--difficulty, uncles, hash-rate won't work as expected on Zukma. For those values, we have constant values set at the runtime level. Existing Ethereum contracts that rely on Proof of Work internals (e.g., mining pool contracts) will almost certainly not work as expected on Zukma.","title":"Full-Ethereum API and Tooling Compatibility"},{"location":"dev-guides/Tutorials/evm-tutorial/#how-zukma-achieves-ethereum-compatibility","text":"We achieve Ethereum compatibility with three integrated components. If you're a smart contract developer, this may just be of passing interest. Pallet Ethereum: which allows for full Ethereum Block Processing SputnikEVM: You can view the full documentation here: EVM: which allows you to deploy","title":"How Zukma achieves Ethereum Compatibility"},{"location":"dev-guides/Tutorials/evm-tutorial/Tutorial/using-mm/","text":"Connect to the Zukma Network via MetaMask In this section we will show you step by step how to connect to the Zukma network via the Meta Mask browser extension. Install MetaMask To install MetaMask please visit your preferred browser plug-in store. We recommend to either use a Chrome, Brave or Firefox browser. MetaMask Download click here Please create a new wallet and make sure to secure your private key and your seed phrase! Warning The private key gives direct access to your funds, so make sure to store these in a secure place. Connect to the Zukma Network Now let's connect MetaMask to the EVM side of the Zukma Network. Add a new network Enter the network data Select the Zukma Network 1) Add a new Network 2) Add Network Data Network Name: Zukma Smart Chain New RPC URL: https://rpc.zukma.org Chain ID: 77 Currency Symbol: ZEP Explorer: https://evm.zukma.org/ 3) Select the Zukma Network Success Congrats, you connected your MetaMask account to the Zukma Network! Written by Zukma Team","title":"Connect to Zukma"},{"location":"dev-guides/Tutorials/evm-tutorial/Tutorial/using-mm/#connect-to-the-zukma-network-via-metamask","text":"In this section we will show you step by step how to connect to the Zukma network via the Meta Mask browser extension.","title":"Connect to the Zukma Network via MetaMask"},{"location":"dev-guides/Tutorials/evm-tutorial/Tutorial/using-mm/#install-metamask","text":"To install MetaMask please visit your preferred browser plug-in store. We recommend to either use a Chrome, Brave or Firefox browser. MetaMask Download click here Please create a new wallet and make sure to secure your private key and your seed phrase! Warning The private key gives direct access to your funds, so make sure to store these in a secure place.","title":"Install MetaMask"},{"location":"dev-guides/Tutorials/evm-tutorial/Tutorial/using-mm/#connect-to-the-zukma-network","text":"Now let's connect MetaMask to the EVM side of the Zukma Network. Add a new network Enter the network data Select the Zukma Network","title":"Connect to the Zukma Network"},{"location":"dev-guides/Tutorials/evm-tutorial/Tutorial/using-mm/#1-add-a-new-network","text":"","title":"1) Add a new Network"},{"location":"dev-guides/Tutorials/evm-tutorial/Tutorial/using-mm/#2-add-network-data","text":"Network Name: Zukma Smart Chain New RPC URL: https://rpc.zukma.org Chain ID: 77 Currency Symbol: ZEP Explorer: https://evm.zukma.org/","title":"2) Add Network Data"},{"location":"dev-guides/Tutorials/evm-tutorial/Tutorial/using-mm/#3-select-the-zukma-network","text":"Success Congrats, you connected your MetaMask account to the Zukma Network! Written by Zukma Team","title":"3) Select the Zukma Network"},{"location":"dev-guides/Tutorials/evm-tutorial/Tutorial/using-truffle/","text":"Deploy with Truffle In this section we will show you how to utilize the Truffle Suite to develop Smart Contracts for Zukma. Tuffle, in short, is a solidity suite that helps you to test your code. Let's start with installing the technical requirements. Installing Technical Requirements To use Truffle we need to install NodeJS v8.9.4 or later and we need a running eth-client. Note Since Zukma is fully Ethereum compatible you can use Ganache as the preferred eth-client Please go ahead and install NodeJS and Ganache. NodeJS Ganache After you installed NodeJS and Ganache, you can execute the following command in your Terminal to install Truffle npm install -g truffle Creating a Project In this guide we will utilize the MetaCoin Truffle Box, which is a Truffle project template. The MetaCoin Box allows us to create an ERC-20 token on Zukma that can be transferred between accounts. Create a new folder for your Truffle project and navigate into it: mkdir MetaCoin cd MetaCoin Download und unbox the MetaCoin Box truffle unbox metacoin Hint You can use the truffe unbox <box-name> command to download and unbox any truffle box Hint If you want to start from scratch please use truffle init Once you unboxed MetaCoin, you will be greeted with a project structure like this: contracts/ : Directory for Solidity Contracts migrations/ : Directory for scriptable deployment files test/ : Directory for test files for testing your application and contracts truffle.js : Truffle configuration file Exploring the Project Open the contracts/MetaCoin.sol file in a text editor. This is a smart contract (written in Solidity) that creates a MetaCoin token. Note that this also references another Solidity file contracts/ConvertLib.sol in the same directory. Open the contracts/Migrations.sol file. This is a separate Solidity file that manages and updates the status of your deployed smart contract. This file comes with every Truffle project, and is usually not edited. Open the migrations/1_initial_migration.js file. This file is the migration (deployment) script for the Migrations contract found in the Migrations.sol file. Open the migrations/2_deploy_contracts.js file. This file is the migration script for the MetaCoin contract. (Migration scripts are run in order, so the file beginning with 2 will be run after the file beginning with 1.) Open the test/TestMetaCoin.sol file. This is a test file written in Solidity which ensures that your contract is working as expected. Open the test/metacoin.js file. This is a test file written in JavaScript which performs a similar function to the Solidity test above. Open the truffle-config.js file. This is the Truffle configuration file, for setting network information and other project-related settings. The file is blank, but this is okay, as we'll be using a Truffle command that has some defaults built-in. Hint We will adjust the truffle-config.js later to deploy the Token to Ganache and later to Zukma Testing Testing your smart contracts is an important step in the development pipeline. To run a test of the MetaCoin contract open up a terminal and run the solidity test: Run the Solidity Test truffle test ./test/TestMetaCoin.sol you will see the following output: TestMetaCoin \u221a testInitialBalanceUsingDeployedContract (607ms) \u221a testInitialBalanceWithNewMetaCoin (457ms) 2 passing (16s) *Run the Javascript Test truffle test ./test/metacoin.js You will see the following output: Contract: MetaCoin \u221a should put 10000 MetaCoin in the first account (126ms) \u221a should call a function that depends on a linked library (258ms) \u221a should send coin correctly (976ms) 3 passing (1s) Success The solidity and javascript test were successfull! Compiling the Smart Contract After the successfull test we are ready to compile the smart contracts within the contracts/ folder. truffle compile You will see the following output: Compiling your contracts... =========================== > Compiling .\\contracts\\ConvertLib.sol > Compiling .\\contracts\\MetaCoin.sol > Compiling .\\contracts\\Migrations.sol > Artifacts written to .\\build\\contracts > Compiled successfully using: Migrating with Ganache To migrate or upload your smart contract to the Ganache Blockchain you need to tell truffle where it to deploy the contract. We do this by adjusting the truffle-config.js file as follows: Open truffle-config.js in a text editor and replace the content with the following: module . exports = { networks : { development : { host : \"127.0.0.1\" , port : 7545 , network_id : \"*\" } } }; Save and close the file Launch Ganache Mirgrate to Ganache Now that we told truffle where to migrate the contracts we can migrate. truffle migrate You will see the following output: Compiling your contracts... =========================== > Compiling .\\contracts\\ConvertLib.sol > Compiling .\\contracts\\MetaCoin.sol > Compiling .\\contracts\\Migrations.sol > Artifacts written to C:\\Users\\john\\Documents\\zukma\\EVM-Tutorial\\build\\contracts > Compiled successfully using: - solc: 0.5.16+commit.9c3226ce.Emscripten.clang PS C:\\Users\\john\\Documents\\zukma\\EVM-Tutorial> truffle migrate Compiling your contracts... =========================== > Compiling .\\contracts\\ConvertLib.sol > Compiling .\\contracts\\MetaCoin.sol > Compiling .\\contracts\\Migrations.sol > Artifacts written to C:\\Users\\john\\Documents\\zukma\\EVM-Tutorial\\build\\contracts > Compiled successfully using: - solc: 0.5.16+commit.9c3226ce.Emscripten.clang Starting migrations... ====================== > Network name: 'development' > Network id: 5777 > Block gas limit: 6721975 (0x6691b7) 1_initial_migration.js ====================== Deploying 'Migrations' ---------------------- > transaction hash: 0x7f94b5d6852bae542f3c2d89e335a309243e54da0bbe96a3c1b863b40a4f547b > Blocks: 0 Seconds: 0 > contract address: 0x475D507822741736A110e25698612C9Eb4ECc635 > block number: 1 > block timestamp: 1634129141 > account: 0x456ad8e2CBF08FCde3C75D169ddF9C20e00F51F4 > balance: 99.9967165 > gas used: 164175 (0x2814f) > gas price: 20 gwei > value sent: 0 ETH > total cost: 0.0032835 ETH > Saving migration to chain. > Saving artifacts ------------------------------------- > Total cost: 0.0032835 ETH 2_deploy_contracts.js ===================== Deploying 'ConvertLib' ---------------------- > transaction hash: 0x0644f4e5186e058e18565b13db350ff8f0158c1f5a8f551741b55d11c76fea7d > Blocks: 0 Seconds: 0 > contract address: 0x0Da4E500c4419860688284687efdF743337FE8ab > block number: 3 > block timestamp: 1634129143 > account: 0x456ad8e2CBF08FCde3C75D169ddF9C20e00F51F4 > balance: 99.99396028 > gas used: 95470 (0x174ee) > gas price: 20 gwei > value sent: 0 ETH > total cost: 0.0019094 ETH Linking ------- * Contract: MetaCoin <--> Library: ConvertLib (at address: 0x0Da4E500c4419860688284687efdF743337FE8ab) Deploying 'MetaCoin' -------------------- > transaction hash: 0xed1abbaf5d5cf4260c69cbec427b9a1b924302cf08b9e7d8e20920b5410bb927 > Blocks: 0 Seconds: 0 > contract address: 0x2E2EB10E302b2551C2788baBAe0d5981c18b4DDf > block number: 4 > block timestamp: 1634129144 > account: 0x456ad8e2CBF08FCde3C75D169ddF9C20e00F51F4 > balance: 99.98822922 > gas used: 286553 (0x45f59) > gas price: 20 gwei > value sent: 0 ETH > total cost: 0.00573106 ETH > Saving migration to chain. > Saving artifacts ------------------------------------- > Total cost: 0.00764046 ETH Summary ======= > Total deployments: 3 > Final cost: 0.01092396 ETH This shows the transaction IDs and addresses of your deployed contracts . It also includes a cost summary and real-time status updates. Hint Hint: Your transaction IDs and contract addresses may be different from the above. In Ganache, click the \"Transactions\" button to see that the transactions have been processed. Success You deployed a smart contract to the Ganache Blockchain! Migrate to Zukma To deploy the smart contracts to Zukma, we need to make some adjustments. First of all we need to install the truffle HDWallet package as follows: npm install @truffle/hdwallet-provider HD Wallet is basically an instance of your wallet e.g., MetaMask that has access to the Zukma Network. Since a contract deployment involves transactions, you need to have your private key or your seed phrase ready. Open the truffle-config.js file and replace its content with the following code: const HDWalletProvider = require ( \"@truffle/hdwallet-provider\" ); const privKey = ' YOUR PRIVATE KEY GOES HERE ' ; module . exports = { compilers : { solc : { version : \"^0.6.0\" , } }, networks : { Zukma : { provider : () => new HDWalletProvider ({ privateKeys : [ privKey ], providerOrUrl : \"https://rpc.zukma.org\" , }), network_id : 142 , }, } } Save the file. You notice a few facts from here, our chainId is 142 and we are using solc version above ^0.6.0. Hint Make sure that the wallet which is attached to the private key you provided earlier is funded sufficiently to pay for the gas needed to deploy the smart contracts. Migrate your Contracts to Zukma To deploy the smart contracts within your project you need to execute the following command: truffle --network development migrate You should see the following output: Compiling your contracts... =========================== \u221a Fetching solc version list from solc-bin. Attempt #1 \u221a Downloading compiler. Attempt #1. > Compiling .\\contracts\\ConvertLib.sol > Compiling .\\contracts\\MetaCoin.sol > Compiling .\\contracts\\Migrations.sol \u221a Fetching solc version list from solc-bin. Attempt #1 > Artifacts written to C:\\Users\\john\\Documents\\zukma\\EVM-Tutorial\\build\\contracts > Compiled successfully using: - solc: 0.6.12+commit.27d51765.Emscripten.clang Starting migrations... ====================== > Network name: 'Zukma Smart Chain' > Network id: 77 > Block gas limit: 30000000 (0x1c9c380) 1_initial_migration.js ====================== Deploying 'Migrations' ---------------------- > transaction hash: 0x69c148fd82661cafb34a7c3df6d4efa714ed9a4553104def2c26a95cde4e1d6f > Blocks: 1 Seconds: 4 > contract address: 0x37b35EAab7C6a52Fb6cd23CcBadc18CF075F6dF6 > block number: 113067 > block timestamp: 1634138652 > account: 0xd3e849B097f7cFe0fdD381e778012759a972d250 > balance: 99.99204025 > gas used: 159195 (0x26ddb) > gas price: 50 gwei > value sent: 0 ETH > total cost: 0.00795975 ETH > Saving migration to chain. > Saving artifacts ------------------------------------- > Total cost: 0.00795975 ETH 2_deploy_contracts.js ===================== Deploying 'ConvertLib' ---------------------- > transaction hash: 0xc5b4688c876ee566e2ae53b76dbbdbb820e3f71faf0360d0a9aabe32d2b9b8a5 > Blocks: 0 Seconds: 4 > contract address: 0xBd41c64fB0531ad8579984F521A23c9B27AC25C5 > block number: 113069 > block timestamp: 1634138664 > account: 0xd3e849B097f7cFe0fdD381e778012759a972d250 > balance: 99.98513905 > gas used: 95686 (0x175c6) > gas price: 50 gwei > value sent: 0 ETH > total cost: 0.0047843 ETH Linking ------- * Contract: MetaCoin <--> Library: ConvertLib (at address: 0xBd41c64fB0531ad8579984F521A23c9B27AC25C5) Deploying 'MetaCoin' -------------------- > transaction hash: 0x9dacc10950ae2b6386f0c75a6d86fe88e337442a2adbb7cadceb5fd85a1e763f > Blocks: 1 Seconds: 4 > contract address: 0x32C3681dB7b86852555475D9E91620Dfc51D3A73 > block number: 113070 > block timestamp: 1634138670 > account: 0xd3e849B097f7cFe0fdD381e778012759a972d250 > balance: 99.970821 > gas used: 286361 (0x45e99) > gas price: 50 gwei > value sent: 0 ETH > total cost: 0.01431805 ETH > Saving migration to chain. > Saving artifacts ------------------------------------- > Total cost: 0.01910235 ETH Summary ======= > Total deployments: 3 > Final cost: 0.0270621 ETH Success Congrats, you deployed your first smart contracts on the Zukma Network! Check Deployment on Network Explorer To verfiy the successfull deployment head over to the EVM Testnet Explorer and search for your Contract Address . Interact with the Contract Since we didn't connect the logic of the smart contracts with a front end we need to interact with our contracts via the console. You can do this in the following ways: Invoke the truffle console: truffle console You will see the following prompt: truffle(development)> Begin by establishing both the deployed MetaCoin contract instance and your Zukma wallet Hint It is normal to get an undefined as response from the console after you executed one command let instance = await MetaCoin.deployed() let accounts = await web3.eth.getAccounts() Check the metacoin balance of the account that deployed the contract: let balance = await instance.getBalance(accounts[0]) balance.toNumber() See how much ether that balance is worth (and note that the contract defines a metacoin to be worth 2 ether): let ether = await instance.getBalanceInEth(accounts[0]) ether.toNumber() Transfer some metacoin from one account to another: instance.sendCoin( TARGET ADDRESS , 500) You should see the following result: { tx: '0x3a81b73b5f9b22ba739b2ba1072ac2b51efa2c5655c4d64f4147937bf5b627ae', receipt: { blockHash: '0x848addd30c96393e5d1f3dddfd633f0d2ffba0b97b15d2a566eba76d7863f63c', blockNumber: 113352, contractAddress: null, cumulativeGasUsed: 47314, from: '0xd3e849b097f7cfe0fdd381e778012759a972d250', gasUsed: 47314, logs: [ [Object] ], logsBloom: '0x00000000000000000000000000000000000000000000000000000008000000000000100001000000000000000000000000000000000000000000000000000000000000000000000000000008000000000000000000000000000000000000000400000000000000000000000000000000000000000000000000000010000000000000000000000000004000000000000004000000000000000000000000000000000004000000000000000000000000000000000000000000000000000000000000000202000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000008000000000000', status: true, to: '0x32c3681db7b86852555475d9e91620dfc51d3a73', transactionHash: '0x3a81b73b5f9b22ba739b2ba1072ac2b51efa2c5655c4d64f4147937bf5b627ae', transactionIndex: 0, rawLogs: [ [Object] ] }, logs: [ { address: '0x32C3681dB7b86852555475D9E91620Dfc51D3A73', blockHash: '0x848addd30c96393e5d1f3dddfd633f0d2ffba0b97b15d2a566eba76d7863f63c', blockNumber: 113352, logIndex: 0, removed: false, transactionHash: '0x3a81b73b5f9b22ba739b2ba1072ac2b51efa2c5655c4d64f4147937bf5b627ae', transactionIndex: 0, transactionLogIndex: '0x0', id: 'log_cdcbe184', event: 'Transfer', args: [Result] } ] } Check the balance of the account that received the metacoin: let received = await instance.getBalance( TARGET ADDRESS ) received.toNumber() Check the balance of the account that sent the metacoin: let newBalance = await instance.getBalance(accounts[0]) newBalance.toNumber() Success Congrats, you succesfully depolyed 3 smart contracts to Zukma via Truffle and Meta Mask! Continue Learning Please check Truffle's fantastic docs, guides and tutorials : Truffle Written by Zukma Team","title":"Deploy with Truffle"},{"location":"dev-guides/Tutorials/evm-tutorial/Tutorial/using-truffle/#deploy-with-truffle","text":"In this section we will show you how to utilize the Truffle Suite to develop Smart Contracts for Zukma. Tuffle, in short, is a solidity suite that helps you to test your code. Let's start with installing the technical requirements.","title":"Deploy with Truffle"},{"location":"dev-guides/Tutorials/evm-tutorial/Tutorial/using-truffle/#installing-technical-requirements","text":"To use Truffle we need to install NodeJS v8.9.4 or later and we need a running eth-client. Note Since Zukma is fully Ethereum compatible you can use Ganache as the preferred eth-client Please go ahead and install NodeJS and Ganache. NodeJS Ganache After you installed NodeJS and Ganache, you can execute the following command in your Terminal to install Truffle npm install -g truffle","title":"Installing Technical Requirements"},{"location":"dev-guides/Tutorials/evm-tutorial/Tutorial/using-truffle/#creating-a-project","text":"In this guide we will utilize the MetaCoin Truffle Box, which is a Truffle project template. The MetaCoin Box allows us to create an ERC-20 token on Zukma that can be transferred between accounts. Create a new folder for your Truffle project and navigate into it: mkdir MetaCoin cd MetaCoin Download und unbox the MetaCoin Box truffle unbox metacoin Hint You can use the truffe unbox <box-name> command to download and unbox any truffle box Hint If you want to start from scratch please use truffle init Once you unboxed MetaCoin, you will be greeted with a project structure like this: contracts/ : Directory for Solidity Contracts migrations/ : Directory for scriptable deployment files test/ : Directory for test files for testing your application and contracts truffle.js : Truffle configuration file","title":"Creating a Project"},{"location":"dev-guides/Tutorials/evm-tutorial/Tutorial/using-truffle/#exploring-the-project","text":"Open the contracts/MetaCoin.sol file in a text editor. This is a smart contract (written in Solidity) that creates a MetaCoin token. Note that this also references another Solidity file contracts/ConvertLib.sol in the same directory. Open the contracts/Migrations.sol file. This is a separate Solidity file that manages and updates the status of your deployed smart contract. This file comes with every Truffle project, and is usually not edited. Open the migrations/1_initial_migration.js file. This file is the migration (deployment) script for the Migrations contract found in the Migrations.sol file. Open the migrations/2_deploy_contracts.js file. This file is the migration script for the MetaCoin contract. (Migration scripts are run in order, so the file beginning with 2 will be run after the file beginning with 1.) Open the test/TestMetaCoin.sol file. This is a test file written in Solidity which ensures that your contract is working as expected. Open the test/metacoin.js file. This is a test file written in JavaScript which performs a similar function to the Solidity test above. Open the truffle-config.js file. This is the Truffle configuration file, for setting network information and other project-related settings. The file is blank, but this is okay, as we'll be using a Truffle command that has some defaults built-in. Hint We will adjust the truffle-config.js later to deploy the Token to Ganache and later to Zukma","title":"Exploring the Project"},{"location":"dev-guides/Tutorials/evm-tutorial/Tutorial/using-truffle/#testing","text":"Testing your smart contracts is an important step in the development pipeline. To run a test of the MetaCoin contract open up a terminal and run the solidity test:","title":"Testing"},{"location":"dev-guides/Tutorials/evm-tutorial/Tutorial/using-truffle/#run-the-solidity-test","text":"truffle test ./test/TestMetaCoin.sol you will see the following output: TestMetaCoin \u221a testInitialBalanceUsingDeployedContract (607ms) \u221a testInitialBalanceWithNewMetaCoin (457ms) 2 passing (16s)","title":"Run the Solidity Test"},{"location":"dev-guides/Tutorials/evm-tutorial/Tutorial/using-truffle/#run-the-javascript-test","text":"truffle test ./test/metacoin.js You will see the following output: Contract: MetaCoin \u221a should put 10000 MetaCoin in the first account (126ms) \u221a should call a function that depends on a linked library (258ms) \u221a should send coin correctly (976ms) 3 passing (1s) Success The solidity and javascript test were successfull!","title":"*Run the Javascript Test"},{"location":"dev-guides/Tutorials/evm-tutorial/Tutorial/using-truffle/#compiling-the-smart-contract","text":"After the successfull test we are ready to compile the smart contracts within the contracts/ folder. truffle compile You will see the following output: Compiling your contracts... =========================== > Compiling .\\contracts\\ConvertLib.sol > Compiling .\\contracts\\MetaCoin.sol > Compiling .\\contracts\\Migrations.sol > Artifacts written to .\\build\\contracts > Compiled successfully using:","title":"Compiling the Smart Contract"},{"location":"dev-guides/Tutorials/evm-tutorial/Tutorial/using-truffle/#migrating-with-ganache","text":"To migrate or upload your smart contract to the Ganache Blockchain you need to tell truffle where it to deploy the contract. We do this by adjusting the truffle-config.js file as follows: Open truffle-config.js in a text editor and replace the content with the following: module . exports = { networks : { development : { host : \"127.0.0.1\" , port : 7545 , network_id : \"*\" } } }; Save and close the file","title":"Migrating with Ganache"},{"location":"dev-guides/Tutorials/evm-tutorial/Tutorial/using-truffle/#launch-ganache","text":"","title":"Launch Ganache"},{"location":"dev-guides/Tutorials/evm-tutorial/Tutorial/using-truffle/#mirgrate-to-ganache","text":"Now that we told truffle where to migrate the contracts we can migrate. truffle migrate You will see the following output: Compiling your contracts... =========================== > Compiling .\\contracts\\ConvertLib.sol > Compiling .\\contracts\\MetaCoin.sol > Compiling .\\contracts\\Migrations.sol > Artifacts written to C:\\Users\\john\\Documents\\zukma\\EVM-Tutorial\\build\\contracts > Compiled successfully using: - solc: 0.5.16+commit.9c3226ce.Emscripten.clang PS C:\\Users\\john\\Documents\\zukma\\EVM-Tutorial> truffle migrate Compiling your contracts... =========================== > Compiling .\\contracts\\ConvertLib.sol > Compiling .\\contracts\\MetaCoin.sol > Compiling .\\contracts\\Migrations.sol > Artifacts written to C:\\Users\\john\\Documents\\zukma\\EVM-Tutorial\\build\\contracts > Compiled successfully using: - solc: 0.5.16+commit.9c3226ce.Emscripten.clang Starting migrations... ====================== > Network name: 'development' > Network id: 5777 > Block gas limit: 6721975 (0x6691b7) 1_initial_migration.js ====================== Deploying 'Migrations' ---------------------- > transaction hash: 0x7f94b5d6852bae542f3c2d89e335a309243e54da0bbe96a3c1b863b40a4f547b > Blocks: 0 Seconds: 0 > contract address: 0x475D507822741736A110e25698612C9Eb4ECc635 > block number: 1 > block timestamp: 1634129141 > account: 0x456ad8e2CBF08FCde3C75D169ddF9C20e00F51F4 > balance: 99.9967165 > gas used: 164175 (0x2814f) > gas price: 20 gwei > value sent: 0 ETH > total cost: 0.0032835 ETH > Saving migration to chain. > Saving artifacts ------------------------------------- > Total cost: 0.0032835 ETH 2_deploy_contracts.js ===================== Deploying 'ConvertLib' ---------------------- > transaction hash: 0x0644f4e5186e058e18565b13db350ff8f0158c1f5a8f551741b55d11c76fea7d > Blocks: 0 Seconds: 0 > contract address: 0x0Da4E500c4419860688284687efdF743337FE8ab > block number: 3 > block timestamp: 1634129143 > account: 0x456ad8e2CBF08FCde3C75D169ddF9C20e00F51F4 > balance: 99.99396028 > gas used: 95470 (0x174ee) > gas price: 20 gwei > value sent: 0 ETH > total cost: 0.0019094 ETH Linking ------- * Contract: MetaCoin <--> Library: ConvertLib (at address: 0x0Da4E500c4419860688284687efdF743337FE8ab) Deploying 'MetaCoin' -------------------- > transaction hash: 0xed1abbaf5d5cf4260c69cbec427b9a1b924302cf08b9e7d8e20920b5410bb927 > Blocks: 0 Seconds: 0 > contract address: 0x2E2EB10E302b2551C2788baBAe0d5981c18b4DDf > block number: 4 > block timestamp: 1634129144 > account: 0x456ad8e2CBF08FCde3C75D169ddF9C20e00F51F4 > balance: 99.98822922 > gas used: 286553 (0x45f59) > gas price: 20 gwei > value sent: 0 ETH > total cost: 0.00573106 ETH > Saving migration to chain. > Saving artifacts ------------------------------------- > Total cost: 0.00764046 ETH Summary ======= > Total deployments: 3 > Final cost: 0.01092396 ETH This shows the transaction IDs and addresses of your deployed contracts . It also includes a cost summary and real-time status updates. Hint Hint: Your transaction IDs and contract addresses may be different from the above. In Ganache, click the \"Transactions\" button to see that the transactions have been processed. Success You deployed a smart contract to the Ganache Blockchain!","title":"Mirgrate to Ganache"},{"location":"dev-guides/Tutorials/evm-tutorial/Tutorial/using-truffle/#migrate-to-zukma","text":"To deploy the smart contracts to Zukma, we need to make some adjustments. First of all we need to install the truffle HDWallet package as follows: npm install @truffle/hdwallet-provider HD Wallet is basically an instance of your wallet e.g., MetaMask that has access to the Zukma Network. Since a contract deployment involves transactions, you need to have your private key or your seed phrase ready. Open the truffle-config.js file and replace its content with the following code: const HDWalletProvider = require ( \"@truffle/hdwallet-provider\" ); const privKey = ' YOUR PRIVATE KEY GOES HERE ' ; module . exports = { compilers : { solc : { version : \"^0.6.0\" , } }, networks : { Zukma : { provider : () => new HDWalletProvider ({ privateKeys : [ privKey ], providerOrUrl : \"https://rpc.zukma.org\" , }), network_id : 142 , }, } } Save the file. You notice a few facts from here, our chainId is 142 and we are using solc version above ^0.6.0. Hint Make sure that the wallet which is attached to the private key you provided earlier is funded sufficiently to pay for the gas needed to deploy the smart contracts.","title":"Migrate to Zukma"},{"location":"dev-guides/Tutorials/evm-tutorial/Tutorial/using-truffle/#migrate-your-contracts-to-zukma","text":"To deploy the smart contracts within your project you need to execute the following command: truffle --network development migrate You should see the following output: Compiling your contracts... =========================== \u221a Fetching solc version list from solc-bin. Attempt #1 \u221a Downloading compiler. Attempt #1. > Compiling .\\contracts\\ConvertLib.sol > Compiling .\\contracts\\MetaCoin.sol > Compiling .\\contracts\\Migrations.sol \u221a Fetching solc version list from solc-bin. Attempt #1 > Artifacts written to C:\\Users\\john\\Documents\\zukma\\EVM-Tutorial\\build\\contracts > Compiled successfully using: - solc: 0.6.12+commit.27d51765.Emscripten.clang Starting migrations... ====================== > Network name: 'Zukma Smart Chain' > Network id: 77 > Block gas limit: 30000000 (0x1c9c380) 1_initial_migration.js ====================== Deploying 'Migrations' ---------------------- > transaction hash: 0x69c148fd82661cafb34a7c3df6d4efa714ed9a4553104def2c26a95cde4e1d6f > Blocks: 1 Seconds: 4 > contract address: 0x37b35EAab7C6a52Fb6cd23CcBadc18CF075F6dF6 > block number: 113067 > block timestamp: 1634138652 > account: 0xd3e849B097f7cFe0fdD381e778012759a972d250 > balance: 99.99204025 > gas used: 159195 (0x26ddb) > gas price: 50 gwei > value sent: 0 ETH > total cost: 0.00795975 ETH > Saving migration to chain. > Saving artifacts ------------------------------------- > Total cost: 0.00795975 ETH 2_deploy_contracts.js ===================== Deploying 'ConvertLib' ---------------------- > transaction hash: 0xc5b4688c876ee566e2ae53b76dbbdbb820e3f71faf0360d0a9aabe32d2b9b8a5 > Blocks: 0 Seconds: 4 > contract address: 0xBd41c64fB0531ad8579984F521A23c9B27AC25C5 > block number: 113069 > block timestamp: 1634138664 > account: 0xd3e849B097f7cFe0fdD381e778012759a972d250 > balance: 99.98513905 > gas used: 95686 (0x175c6) > gas price: 50 gwei > value sent: 0 ETH > total cost: 0.0047843 ETH Linking ------- * Contract: MetaCoin <--> Library: ConvertLib (at address: 0xBd41c64fB0531ad8579984F521A23c9B27AC25C5) Deploying 'MetaCoin' -------------------- > transaction hash: 0x9dacc10950ae2b6386f0c75a6d86fe88e337442a2adbb7cadceb5fd85a1e763f > Blocks: 1 Seconds: 4 > contract address: 0x32C3681dB7b86852555475D9E91620Dfc51D3A73 > block number: 113070 > block timestamp: 1634138670 > account: 0xd3e849B097f7cFe0fdD381e778012759a972d250 > balance: 99.970821 > gas used: 286361 (0x45e99) > gas price: 50 gwei > value sent: 0 ETH > total cost: 0.01431805 ETH > Saving migration to chain. > Saving artifacts ------------------------------------- > Total cost: 0.01910235 ETH Summary ======= > Total deployments: 3 > Final cost: 0.0270621 ETH Success Congrats, you deployed your first smart contracts on the Zukma Network!","title":"Migrate your Contracts to Zukma"},{"location":"dev-guides/Tutorials/evm-tutorial/Tutorial/using-truffle/#check-deployment-on-network-explorer","text":"To verfiy the successfull deployment head over to the EVM Testnet Explorer and search for your Contract Address .","title":"Check Deployment on Network Explorer"},{"location":"dev-guides/Tutorials/evm-tutorial/Tutorial/using-truffle/#interact-with-the-contract","text":"Since we didn't connect the logic of the smart contracts with a front end we need to interact with our contracts via the console. You can do this in the following ways: Invoke the truffle console: truffle console You will see the following prompt: truffle(development)> Begin by establishing both the deployed MetaCoin contract instance and your Zukma wallet Hint It is normal to get an undefined as response from the console after you executed one command let instance = await MetaCoin.deployed() let accounts = await web3.eth.getAccounts() Check the metacoin balance of the account that deployed the contract: let balance = await instance.getBalance(accounts[0]) balance.toNumber() See how much ether that balance is worth (and note that the contract defines a metacoin to be worth 2 ether): let ether = await instance.getBalanceInEth(accounts[0]) ether.toNumber() Transfer some metacoin from one account to another: instance.sendCoin( TARGET ADDRESS , 500) You should see the following result: { tx: '0x3a81b73b5f9b22ba739b2ba1072ac2b51efa2c5655c4d64f4147937bf5b627ae', receipt: { blockHash: '0x848addd30c96393e5d1f3dddfd633f0d2ffba0b97b15d2a566eba76d7863f63c', blockNumber: 113352, contractAddress: null, cumulativeGasUsed: 47314, from: '0xd3e849b097f7cfe0fdd381e778012759a972d250', gasUsed: 47314, logs: [ [Object] ], logsBloom: '0x00000000000000000000000000000000000000000000000000000008000000000000100001000000000000000000000000000000000000000000000000000000000000000000000000000008000000000000000000000000000000000000000400000000000000000000000000000000000000000000000000000010000000000000000000000000004000000000000004000000000000000000000000000000000004000000000000000000000000000000000000000000000000000000000000000202000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000008000000000000', status: true, to: '0x32c3681db7b86852555475d9e91620dfc51d3a73', transactionHash: '0x3a81b73b5f9b22ba739b2ba1072ac2b51efa2c5655c4d64f4147937bf5b627ae', transactionIndex: 0, rawLogs: [ [Object] ] }, logs: [ { address: '0x32C3681dB7b86852555475D9E91620Dfc51D3A73', blockHash: '0x848addd30c96393e5d1f3dddfd633f0d2ffba0b97b15d2a566eba76d7863f63c', blockNumber: 113352, logIndex: 0, removed: false, transactionHash: '0x3a81b73b5f9b22ba739b2ba1072ac2b51efa2c5655c4d64f4147937bf5b627ae', transactionIndex: 0, transactionLogIndex: '0x0', id: 'log_cdcbe184', event: 'Transfer', args: [Result] } ] } Check the balance of the account that received the metacoin: let received = await instance.getBalance( TARGET ADDRESS ) received.toNumber() Check the balance of the account that sent the metacoin: let newBalance = await instance.getBalance(accounts[0]) newBalance.toNumber() Success Congrats, you succesfully depolyed 3 smart contracts to Zukma via Truffle and Meta Mask!","title":"Interact with the Contract"},{"location":"dev-guides/Tutorials/evm-tutorial/Tutorial/using-truffle/#continue-learning","text":"Please check Truffle's fantastic docs, guides and tutorials : Truffle Written by Zukma Team","title":"Continue Learning"},{"location":"dev-guides/Tutorials/evm-tutorial/evm-tools-and-res/eth-libs/","text":"Ethereum Libraries Warning Proceed with caution! This page is work in progress! For a web app to interact with the Ethereum blockchain (i.e., read blockchain data and send transactions to the network), it must connect to an Ethereum node. For this purpose, every Ethereum client implements the JSON-RPC specification so that applications can rely on a uniform set of endpoints. If you want to use JavaScript to connect with an Ethereum node, it's possible to use vanilla JavaScript. Still, several convenience libraries exist within the ecosystem that makes this much more accessible. With these libraries, developers can write intuitive, one-line methods to initialize JSON RPC requests (under the hood) that interact with Ethereum. Why use a library? These libraries take away much of the complexity of interacting directly with an Ethereum node. They also provide utility functions (e.g., converting ETH to Gwei). As a developer, you can spend less time dealing with the intricacies of Ethereum clients and more time focused on the unique functionality of your application. Web3.js Library Web3.js is a collection of libraries that allows programmers to interact with these on-chain components by facilitating a connection to Ethereum nodes.\u200c In Ethereum, nodes provide low-level interfaces for users to submit transactions. A node can receive transactions through a JSON RPC interface. JSON RPC is a textual encoding format allowing running processes to receive data. Nodes participating in the Ethereum network may expose this interface in different ways, depending on its configuration and the underlying software implementation. Common options include HTTP connections, IPC or WebSockets.\u200c For the full user documentation, and API reference for web3.js, click here . Ethers.js Library The ethers.js library provides tools to interact with Ethereum Nodes with JavaScript, similar to web3.js. Zukma has an Ethereum-like API available that is fully compatible with Ethereum-style JSON RPC invocations. Therefore, developers can leverage this compatibility and use the ethers.js library to interact with a Zukma node as if they were doing so on Ethereum. Setup Ethers.js with Zukma To get started with the ethers.js library, install it using the following command: npm install ethers Once done, the simplest setup to start using the library and its methods is the following: const ethers = require ( 'ethers' ); // Variables definition const privKey = '0xPRIVKEY' ; // Define Providerconst provider = new ethers . providers . StaticJsonRpcProvider ( 'RPC_URL' , { chainId : ChainId , name : 'NETWORK_NAME' }); // Create Walletlet wallet = new ethers . Wallet ( privKey , provider ); Different methods are available inside provider and wallet. Depending on which network you want to connect to, you can set the RPC_URL, ChainID, NETWORK_NAME to the following values: Zukma Development Node RRC URL: http://localhost:9933 ChainID: 77 Network Name: dev Zukma Testnet RPC URL: https://rpc.zukma.org ChainID: 77 Network Name: Zukma Web3.py Library Web3.py is a set of libraries that allow developers to interact with Ethereum nodes using HTTP, IPC, or WebSocket protocols with Python. Zukma has an Ethereum-like API available that is fully compatible with Ethereum-style JSON RPC invocations. Therefore, developers can leverage this compatibility and use the web3.py library to interact with a Zukma node as if they were doing so on Ethereum. Setup Web3.py with Zukma To get started with the web3.py library, install it using the following command: pip3 install web3 Once done, the simplest setup to start using the library and its methods is the following: from web3 import Web3 RPC_URL = 'https://rpc-testnet.zukma.org/rpc' web3 = Web3 ( Web3 . HTTPProvider ( 'RPC_URL' )) Written by Zukma Team","title":"Libraries"},{"location":"dev-guides/Tutorials/evm-tutorial/evm-tools-and-res/eth-libs/#ethereum-libraries","text":"Warning Proceed with caution! This page is work in progress! For a web app to interact with the Ethereum blockchain (i.e., read blockchain data and send transactions to the network), it must connect to an Ethereum node. For this purpose, every Ethereum client implements the JSON-RPC specification so that applications can rely on a uniform set of endpoints. If you want to use JavaScript to connect with an Ethereum node, it's possible to use vanilla JavaScript. Still, several convenience libraries exist within the ecosystem that makes this much more accessible. With these libraries, developers can write intuitive, one-line methods to initialize JSON RPC requests (under the hood) that interact with Ethereum.","title":"Ethereum Libraries"},{"location":"dev-guides/Tutorials/evm-tutorial/evm-tools-and-res/eth-libs/#why-use-a-library","text":"These libraries take away much of the complexity of interacting directly with an Ethereum node. They also provide utility functions (e.g., converting ETH to Gwei). As a developer, you can spend less time dealing with the intricacies of Ethereum clients and more time focused on the unique functionality of your application.","title":"Why use a library?"},{"location":"dev-guides/Tutorials/evm-tutorial/evm-tools-and-res/eth-libs/#web3js-library","text":"Web3.js is a collection of libraries that allows programmers to interact with these on-chain components by facilitating a connection to Ethereum nodes.\u200c In Ethereum, nodes provide low-level interfaces for users to submit transactions. A node can receive transactions through a JSON RPC interface. JSON RPC is a textual encoding format allowing running processes to receive data. Nodes participating in the Ethereum network may expose this interface in different ways, depending on its configuration and the underlying software implementation. Common options include HTTP connections, IPC or WebSockets.\u200c For the full user documentation, and API reference for web3.js, click here .","title":"Web3.js Library"},{"location":"dev-guides/Tutorials/evm-tutorial/evm-tools-and-res/eth-libs/#ethersjs-library","text":"The ethers.js library provides tools to interact with Ethereum Nodes with JavaScript, similar to web3.js. Zukma has an Ethereum-like API available that is fully compatible with Ethereum-style JSON RPC invocations. Therefore, developers can leverage this compatibility and use the ethers.js library to interact with a Zukma node as if they were doing so on Ethereum.","title":"Ethers.js Library"},{"location":"dev-guides/Tutorials/evm-tutorial/evm-tools-and-res/eth-libs/#setup-ethersjs-with-zukma","text":"To get started with the ethers.js library, install it using the following command: npm install ethers Once done, the simplest setup to start using the library and its methods is the following: const ethers = require ( 'ethers' ); // Variables definition const privKey = '0xPRIVKEY' ; // Define Providerconst provider = new ethers . providers . StaticJsonRpcProvider ( 'RPC_URL' , { chainId : ChainId , name : 'NETWORK_NAME' }); // Create Walletlet wallet = new ethers . Wallet ( privKey , provider ); Different methods are available inside provider and wallet. Depending on which network you want to connect to, you can set the RPC_URL, ChainID, NETWORK_NAME to the following values: Zukma Development Node RRC URL: http://localhost:9933 ChainID: 77 Network Name: dev Zukma Testnet RPC URL: https://rpc.zukma.org ChainID: 77 Network Name: Zukma","title":"Setup Ethers.js with Zukma"},{"location":"dev-guides/Tutorials/evm-tutorial/evm-tools-and-res/eth-libs/#web3py-library","text":"Web3.py is a set of libraries that allow developers to interact with Ethereum nodes using HTTP, IPC, or WebSocket protocols with Python. Zukma has an Ethereum-like API available that is fully compatible with Ethereum-style JSON RPC invocations. Therefore, developers can leverage this compatibility and use the web3.py library to interact with a Zukma node as if they were doing so on Ethereum.","title":"Web3.py Library"},{"location":"dev-guides/Tutorials/evm-tutorial/evm-tools-and-res/eth-libs/#setup-web3py-with-zukma","text":"To get started with the web3.py library, install it using the following command: pip3 install web3 Once done, the simplest setup to start using the library and its methods is the following: from web3 import Web3 RPC_URL = 'https://rpc-testnet.zukma.org/rpc' web3 = Web3 ( Web3 . HTTPProvider ( 'RPC_URL' )) Written by Zukma Team","title":"Setup Web3.py with Zukma"},{"location":"dev-guides/Tutorials/evm-tutorial/evm-tools-and-res/evm-balances/","text":"EVM Balances The \"EVM\" module in Substrate provides support for executing Ethereum contracts on a substrate chain. To perform any gas or balance-related actions on the EVM, the calling account must have a EVM balance. Balance Conversion To use Ethereum contracts on a Substrate chain, the chain must have a protocol that support thes following requirements: A (32-byte) Substrate address must have a corresponding (20-byte) Ethereum address. Each (20-byte) Ethereum address must have its balance maintained. Step 1 The EVM pallet satisfies step 1 by cutting the source Substrate address into an Ethereum address, taking the first 20 bytes. Step 2 To maintain the balances of the cut-down EVM addresses, the Zukma utilizes the Substrate balances pallet. The balances pallet converts a corresponding 20-byte address into an substrate address (32-byte). Note that these reconverted 32-byte addresses have no inherent relationship to the original truncated Substrate address. Example Consider the following 32-byte substrate address: 0x1234567890ABCDEF1234567890ABCDEF1234567890ABCDEF1234567890ABCDEF Truncate the address to build an EVM Pallet representation: 0x1234567890ABCDEF1234567890ABCDEF12345678 The balance of 0x1234567890ABCDEF1234567890ABCDEF12345678 comes from the balances pallet The balances pallet manages uses a 32-byte representation of 0x1234567890ABCDEF1234567890ABCDEF12345678 This representation is generated by hashing 0x1234567890ABCDEF1234567890ABCDEF12345678 with a specific EVM prefix The prefix is: (0x65766D3A) The balances module performs: HASH(0x65766D3A0x1234567890ABCDEF1234567890ABCDEF12345678) end gets = 32-byte EVM representation of truncated address: 0xAF8536395A1EEC8EDA6FB9CF36739ECF75BECF6FEA04CEEC108BBB6AA15B7CB3 The balance of 0xAF8536395A1EEC8EDA6FB9CF36739ECF75BECF6FEA04CEEC108BBB6AA15B7CB3 in the balances pallet is used for EVM-related operations. Note Note that these actions are not reversible: we cannot convert from an EVM address back to its Ethereum address, nor can we convert from an Ethereum address back to its \"source\" Substrate address. Managing Ethereum Balances on Substrate Two operations are possible: We can \"deposit\" funds from a Substrate account into its corresponding Ethereum account and We can \"withdraw\" funds from an Ethereum account back into the source Substrate account. Deposits Since the EVM address that represents an Ethereum address is computed deterministically by hashing, as shown above, we can perform a standard balance transfer from our source Substrate account to the EVM address to seed the Ethereum account with funds. This can be performed by calling balances::transfer(prefixAndHash(truncate(account)).signAndSend(account) , where account is the source substrate account. truncate() takes the substrate source address (32-bytes) and produces the 20-byte Ethereum address. Finally, prefixAndHash() applies the evm: prefix and performs the hash to convert the Ethereum address back into a 32-byte Substrate address. Withdrawals Since the EVM address is computed deterministically, via hashing, we do not have a private key for it, so we cannot perform a balance transfer from it via normal means. As a result, the EVM module provides a unique function withdraw to transfer funds back from an Ethereum account to the source Substrate account. This can be performed by calling evm::withdraw(truncate(account), value).signAndSend(account) where account is the source Substrate account, and truncate takes the first 20 bytes as the Ethereum address. Ethereum Balances An EVM address can be given a balance at genesis, or by sending balance directly to the \"substrate-ethereum address equivalent\" as you would normally do between accounts. Zukma handles Ethereum balances as if they were running on the Ethereum blockchain. That includes that gas is subtracted from the balance (you can access the quantity of gas used from the transaction receipt returned by the EVM module through web3 or truffle), and transfers work as expected. The balance of the 20-byte Ethereum address and the 32-byte EVM address should be identical, when compared: web3.eth.getBalance(ethAddress) should equal system::balances(prefixAndHash(ethAddress)).freeBalance , where ethAddress is the 20-byte Ethereum address, and prefixAndHash applies the evm: prefix and takes the hash, as explained above. Warning Each EVM address is deterministically mapped to another substrate address which maintains its balance within the balances pallet, and which can be used to sent funds directly via a basic transfer. This substrate address is equivalent to the 20-byte EVM address for all intents and purposes, and is a deterministic computation from the original substrate address \u2014 it can be used in other pallets freely as a \"proxy\" for the EVM address. However, it does not have a private key, so it cannot sign. Funds must be withdrawn from an EVM account (20-byte address) via the pallet_evm::withdraw function, as the \"substrate-ethereum equivalent\" does not have a known private key from which to send transactions. Written by Zukma Team","title":"EVM Balances"},{"location":"dev-guides/Tutorials/evm-tutorial/evm-tools-and-res/evm-balances/#evm-balances","text":"The \"EVM\" module in Substrate provides support for executing Ethereum contracts on a substrate chain. To perform any gas or balance-related actions on the EVM, the calling account must have a EVM balance.","title":"EVM Balances"},{"location":"dev-guides/Tutorials/evm-tutorial/evm-tools-and-res/evm-balances/#balance-conversion","text":"To use Ethereum contracts on a Substrate chain, the chain must have a protocol that support thes following requirements: A (32-byte) Substrate address must have a corresponding (20-byte) Ethereum address. Each (20-byte) Ethereum address must have its balance maintained. Step 1 The EVM pallet satisfies step 1 by cutting the source Substrate address into an Ethereum address, taking the first 20 bytes. Step 2 To maintain the balances of the cut-down EVM addresses, the Zukma utilizes the Substrate balances pallet. The balances pallet converts a corresponding 20-byte address into an substrate address (32-byte). Note that these reconverted 32-byte addresses have no inherent relationship to the original truncated Substrate address. Example Consider the following 32-byte substrate address: 0x1234567890ABCDEF1234567890ABCDEF1234567890ABCDEF1234567890ABCDEF Truncate the address to build an EVM Pallet representation: 0x1234567890ABCDEF1234567890ABCDEF12345678 The balance of 0x1234567890ABCDEF1234567890ABCDEF12345678 comes from the balances pallet The balances pallet manages uses a 32-byte representation of 0x1234567890ABCDEF1234567890ABCDEF12345678 This representation is generated by hashing 0x1234567890ABCDEF1234567890ABCDEF12345678 with a specific EVM prefix The prefix is: (0x65766D3A) The balances module performs: HASH(0x65766D3A0x1234567890ABCDEF1234567890ABCDEF12345678) end gets = 32-byte EVM representation of truncated address: 0xAF8536395A1EEC8EDA6FB9CF36739ECF75BECF6FEA04CEEC108BBB6AA15B7CB3 The balance of 0xAF8536395A1EEC8EDA6FB9CF36739ECF75BECF6FEA04CEEC108BBB6AA15B7CB3 in the balances pallet is used for EVM-related operations. Note Note that these actions are not reversible: we cannot convert from an EVM address back to its Ethereum address, nor can we convert from an Ethereum address back to its \"source\" Substrate address.","title":"Balance Conversion"},{"location":"dev-guides/Tutorials/evm-tutorial/evm-tools-and-res/evm-balances/#managing-ethereum-balances-on-substrate","text":"Two operations are possible: We can \"deposit\" funds from a Substrate account into its corresponding Ethereum account and We can \"withdraw\" funds from an Ethereum account back into the source Substrate account.","title":"Managing Ethereum Balances on Substrate"},{"location":"dev-guides/Tutorials/evm-tutorial/evm-tools-and-res/evm-balances/#deposits","text":"Since the EVM address that represents an Ethereum address is computed deterministically by hashing, as shown above, we can perform a standard balance transfer from our source Substrate account to the EVM address to seed the Ethereum account with funds. This can be performed by calling balances::transfer(prefixAndHash(truncate(account)).signAndSend(account) , where account is the source substrate account. truncate() takes the substrate source address (32-bytes) and produces the 20-byte Ethereum address. Finally, prefixAndHash() applies the evm: prefix and performs the hash to convert the Ethereum address back into a 32-byte Substrate address.","title":"Deposits"},{"location":"dev-guides/Tutorials/evm-tutorial/evm-tools-and-res/evm-balances/#withdrawals","text":"Since the EVM address is computed deterministically, via hashing, we do not have a private key for it, so we cannot perform a balance transfer from it via normal means. As a result, the EVM module provides a unique function withdraw to transfer funds back from an Ethereum account to the source Substrate account. This can be performed by calling evm::withdraw(truncate(account), value).signAndSend(account) where account is the source Substrate account, and truncate takes the first 20 bytes as the Ethereum address.","title":"Withdrawals"},{"location":"dev-guides/Tutorials/evm-tutorial/evm-tools-and-res/evm-balances/#ethereum-balances","text":"An EVM address can be given a balance at genesis, or by sending balance directly to the \"substrate-ethereum address equivalent\" as you would normally do between accounts. Zukma handles Ethereum balances as if they were running on the Ethereum blockchain. That includes that gas is subtracted from the balance (you can access the quantity of gas used from the transaction receipt returned by the EVM module through web3 or truffle), and transfers work as expected. The balance of the 20-byte Ethereum address and the 32-byte EVM address should be identical, when compared: web3.eth.getBalance(ethAddress) should equal system::balances(prefixAndHash(ethAddress)).freeBalance , where ethAddress is the 20-byte Ethereum address, and prefixAndHash applies the evm: prefix and takes the hash, as explained above. Warning Each EVM address is deterministically mapped to another substrate address which maintains its balance within the balances pallet, and which can be used to sent funds directly via a basic transfer. This substrate address is equivalent to the 20-byte EVM address for all intents and purposes, and is a deterministic computation from the original substrate address \u2014 it can be used in other pallets freely as a \"proxy\" for the EVM address. However, it does not have a private key, so it cannot sign. Funds must be withdrawn from an EVM account (20-byte address) via the pallet_evm::withdraw function, as the \"substrate-ethereum equivalent\" does not have a known private key from which to send transactions. Written by Zukma Team","title":"Ethereum Balances"},{"location":"dev-guides/Tutorials/evm-tutorial/evm-tools-and-res/waffle/","text":"Waffle Tool Waffle is a popular development framework for testing Solidity smart contracts. Since Zukma is Ethereum compatible, with a few lines of extra configuration, you can use Zukma as you usually would with Ethereum to develop on Zukma. Configure Waffle to Connect to Zukma Assuming you already have a JavaScript project, install Waffle: npm install ethereum-waffle To configure Waffle to run tests against a Zukma development node or the Zukma Testnet, within your tests create a custom provider and add network configurations: Javascript describe ( 'Test Contract' , () => { // Use custom provider to connect to Zukma or Edgeware development node const ZukmaProvider = new ethers . providers . JsonRpcProvider (( 'https://rpc.zukma.org' ) const devProvider = new ethers . providers . JsonRpcProvider ( 'http://localhost:9933/' ); }) Written by Zukma Team","title":"Tools"},{"location":"dev-guides/Tutorials/evm-tutorial/evm-tools-and-res/waffle/#waffle-tool","text":"Waffle is a popular development framework for testing Solidity smart contracts. Since Zukma is Ethereum compatible, with a few lines of extra configuration, you can use Zukma as you usually would with Ethereum to develop on Zukma. Configure Waffle to Connect to Zukma Assuming you already have a JavaScript project, install Waffle: npm install ethereum-waffle To configure Waffle to run tests against a Zukma development node or the Zukma Testnet, within your tests create a custom provider and add network configurations: Javascript describe ( 'Test Contract' , () => { // Use custom provider to connect to Zukma or Edgeware development node const ZukmaProvider = new ethers . providers . JsonRpcProvider (( 'https://rpc.zukma.org' ) const devProvider = new ethers . providers . JsonRpcProvider ( 'http://localhost:9933/' ); }) Written by Zukma Team","title":"Waffle Tool"},{"location":"get-started/","text":"GET STARTED It's time to get started on the Zukma network! Please check out our recommended list for getting started. Brand new to blockchain? For brand-new learners of Blockchain technology: The Blockchain Fundamentals MOOC cours is a great introduction to start familiarizing yourself with blockchain concepts such as cryptography and networks, and how these play into things like decentralization and cryptocurrency. Hint This is recommended for users with backgrounds of all levels, and the course is free! Brand new to Zukma? For brand-new learners of Zukma, check-out: Reading the Zukma Overview page Reading our articles on Medium Creating a Zukma Account Using Zukma endpoints Claiming Zukma ZEP coins Running a Validator on Zukma Staking as a Nominator on Zukma Developing on Zukma? For developers who want to leverage on Zukma's unique advantages, please visit: The developer guide Written by Zukma Team","title":"<b>GET STARTED</b>"},{"location":"get-started/#get-started","text":"It's time to get started on the Zukma network! Please check out our recommended list for getting started.","title":"GET STARTED"},{"location":"get-started/#brand-new-to-blockchain","text":"For brand-new learners of Blockchain technology: The Blockchain Fundamentals MOOC cours is a great introduction to start familiarizing yourself with blockchain concepts such as cryptography and networks, and how these play into things like decentralization and cryptocurrency. Hint This is recommended for users with backgrounds of all levels, and the course is free!","title":"Brand new to blockchain?"},{"location":"get-started/#brand-new-to-zukma","text":"For brand-new learners of Zukma, check-out: Reading the Zukma Overview page Reading our articles on Medium Creating a Zukma Account Using Zukma endpoints Claiming Zukma ZEP coins Running a Validator on Zukma Staking as a Nominator on Zukma","title":"Brand new to Zukma?"},{"location":"get-started/#developing-on-zukma","text":"For developers who want to leverage on Zukma's unique advantages, please visit: The developer guide Written by Zukma Team","title":"Developing on Zukma?"},{"location":"get-started/claims/","text":"CLAIMS If you held the ZEP ERC-20 token or ZEP coins until now , you are entitled to swap ZEP on the Zukma Network Crosschain. Hint Watch our YouTube Walkthrough You can claim ZEP by visiting our Dashboard Swap Chain Function . Hint You can check if you are already to Swap by investigating the transaction hash Crosschain Written by Zukma Team","title":"Claims"},{"location":"get-started/claims/#claims","text":"If you held the ZEP ERC-20 token or ZEP coins until now , you are entitled to swap ZEP on the Zukma Network Crosschain. Hint Watch our YouTube Walkthrough You can claim ZEP by visiting our Dashboard Swap Chain Function . Hint You can check if you are already to Swap by investigating the transaction hash Crosschain Written by Zukma Team","title":"CLAIMS"},{"location":"get-started/endpoints/","text":"ZUKMA ENDPOINTS When interacting with the Zukma network via our substrate explorer app or other UIs and programmatic methods, you'd ideally be running your own node ( text guide ). Granted, that's not something everyone wants to do, so convenience trumps ideals in most cases. To facilitate this convenience, Zukma has several public endpoints you can use for your DApps. Zukma Tech Archive Node Zukma Tech, the company that develops the Zukma Rust client, maintains an archive node at endpoint https://rpc.zukma.org/ To connect to the Zukma Tech node, use the endpoint in your JavaScript DApps like so: const { ApiPromise , WsProvider } = require ( '@polkadot/api' ) ( async () => { const provider = new WsProvider ( 'wss://ws.zukma.org' ) const api = await ApiPromise . create ({ provider }) // ... or in Zukma Substrate Explorer by clicking on the top-left corner of the screen and opening up the LIVE NETWORKS group and selecting Zukma and via Zukma Written by Zukma Team","title":"Endpoints"},{"location":"get-started/endpoints/#zukma-endpoints","text":"When interacting with the Zukma network via our substrate explorer app or other UIs and programmatic methods, you'd ideally be running your own node ( text guide ). Granted, that's not something everyone wants to do, so convenience trumps ideals in most cases. To facilitate this convenience, Zukma has several public endpoints you can use for your DApps.","title":"ZUKMA ENDPOINTS"},{"location":"get-started/endpoints/#zukma-tech-archive-node","text":"Zukma Tech, the company that develops the Zukma Rust client, maintains an archive node at endpoint https://rpc.zukma.org/ To connect to the Zukma Tech node, use the endpoint in your JavaScript DApps like so: const { ApiPromise , WsProvider } = require ( '@polkadot/api' ) ( async () => { const provider = new WsProvider ( 'wss://ws.zukma.org' ) const api = await ApiPromise . create ({ provider }) // ... or in Zukma Substrate Explorer by clicking on the top-left corner of the screen and opening up the LIVE NETWORKS group and selecting Zukma and via Zukma Written by Zukma Team","title":"Zukma Tech Archive Node"},{"location":"get-started/faucet/","text":"HOW TO GET ZUKMA COINS? If you are interested in obtaining ZEP for building orpP research, you can apply through the Treasury or receive a tip for doing something cool in the community. Please reach out to us on: Twitter Telegram Written by Zukma Team","title":"Faucet"},{"location":"get-started/faucet/#how-to-get-zukma-coins","text":"If you are interested in obtaining ZEP for building orpP research, you can apply through the Treasury or receive a tip for doing something cool in the community. Please reach out to us on: Twitter Telegram Written by Zukma Team","title":" HOW TO GET ZUKMA COINS?"},{"location":"get-started/internal-transfer/","text":"INTERNAL TRANSFER OF BALANCES Cheers Friends, This guide will teach you how to send your funds from our \"substrate\" side to our Ethereum-Virtual-Machine (EVM). Remember, the EVM side of our chain allows you to interact with many eth-based smart contracts and projects that eventually will move to Zukma. Moreover, our cross-chain bridges will be attached to our EVM module, so for you to utilize cross-chain trades, you must use the EVM. That said, let me tell you how we tackle this. First, I will walk you through the process to get started right away. Second, I will elaborate a bit more on the concept so that the interested lads can read up. PART 1 - WALKTHROUGH Hint You can access the WALLETS function here: Visit Dashboard You can watch me walk you through the process in this video: Visit YouTube The transfer is done in four (4) steps: Choose an account to send the ZEP from Choose an account that will receive the ZEP Specify amount Confirmation STEP 01 - Choose an account to send the ZEP from Hint Make sure you have selected the \"Wallets\" function of our DApp (see picture below) Hint In the wallet list find the wallet to send from and click the button send on the right side. This account needs to hold the funds you wish to transfer. STEP 02 - Choose an account that will receive the ZEP Hint Click on Send To Account field and select an account you want to transfer the funds to from the dropdown menu. STEP 03 - Specify amount Set the amount of ZEP you want to send in the Amount field. Hint Do not use MAX button to send all your funds. A small amount of ZEP is needed to pay the gas fees STEP 04 - Confirmation Click Make Transfer button and double check the Sending From Account and Amount values are correct. Warning It is generally advised to test a transaction with a small amount, especially if you are not familiar with the wallets so far. The correct transfer of funds is your sole responsibility! No refunds are possible. Hint Open the substrate or EVM explorer to be prepared to check that the transfer went through successfully. Substrate Explorer EVM Explorer Confirm the transfer by hitting the Sign and Submit button. Hint Sign with your substrate account. Hint If everything went fine, you are going to see a success message at the button of the page Hint Now head over to the substrate explorer to check if the DApp successfully wrote the transfer into a block Success Congrats, you successfully swapped ZEP from the substrate to the EVM side. Feel free to reverse the swap and use the wallets function to your needs. PART 2 - WHAT HAPPENS IN THE BACKGROUND Many may ask themselves whether Zukma is a single chain when it has both an ethereum and substrate side at the same time? Well, to make a long story short... Zukma is one single chain BUT it runs an ethereum simulation in parallel. How does this work? To answer this question, we need to look at the node architecture. Nodes are the pillars of our distributed network, and they run all the necessary code. I want to direct your focus to the SUBSTRATE RUNTIME module of the Substrate Node. The Runtime hosts all the code that makes Zukma unique, and it's composed of code pallets. As you can see, the democracy function of our chain is also a code pallet and allows our community to govern the chain. Likewise, the staking pallet enables our community to run validators and stake as nominators. Like those pallets, the EVM is another pallet that allows our community to interact with eth-based smart contracts and cross-chain bridges. By performing the transfer described in step 01, we are transferring coins from the SUBSTRATE RUNTIME ENVIRONMENT into the EVM pallet and vice versa, that's it :D. As briefly touched on earlier, the EVM side opens up many new opportunities for you to utilize your ZEP coins. Written by Zukma Team","title":"EVM <-> Substrate Transfers"},{"location":"get-started/internal-transfer/#internal-transfer-of-balances","text":"Cheers Friends, This guide will teach you how to send your funds from our \"substrate\" side to our Ethereum-Virtual-Machine (EVM). Remember, the EVM side of our chain allows you to interact with many eth-based smart contracts and projects that eventually will move to Zukma. Moreover, our cross-chain bridges will be attached to our EVM module, so for you to utilize cross-chain trades, you must use the EVM. That said, let me tell you how we tackle this. First, I will walk you through the process to get started right away. Second, I will elaborate a bit more on the concept so that the interested lads can read up.","title":"INTERNAL TRANSFER OF BALANCES"},{"location":"get-started/internal-transfer/#part-1-walkthrough","text":"Hint You can access the WALLETS function here: Visit Dashboard You can watch me walk you through the process in this video: Visit YouTube The transfer is done in four (4) steps: Choose an account to send the ZEP from Choose an account that will receive the ZEP Specify amount Confirmation","title":" PART 1 - WALKTHROUGH "},{"location":"get-started/internal-transfer/#step-01-choose-an-account-to-send-the-zep-from","text":"Hint Make sure you have selected the \"Wallets\" function of our DApp (see picture below) Hint In the wallet list find the wallet to send from and click the button send on the right side. This account needs to hold the funds you wish to transfer.","title":" STEP 01 - Choose an account to send the ZEP from "},{"location":"get-started/internal-transfer/#step-02-choose-an-account-that-will-receive-the-zep","text":"Hint Click on Send To Account field and select an account you want to transfer the funds to from the dropdown menu.","title":" STEP 02 - Choose an account that will receive the ZEP "},{"location":"get-started/internal-transfer/#step-03-specify-amount","text":"Set the amount of ZEP you want to send in the Amount field. Hint Do not use MAX button to send all your funds. A small amount of ZEP is needed to pay the gas fees","title":" STEP 03 - Specify amount "},{"location":"get-started/internal-transfer/#step-04-confirmation","text":"Click Make Transfer button and double check the Sending From Account and Amount values are correct. Warning It is generally advised to test a transaction with a small amount, especially if you are not familiar with the wallets so far. The correct transfer of funds is your sole responsibility! No refunds are possible. Hint Open the substrate or EVM explorer to be prepared to check that the transfer went through successfully. Substrate Explorer EVM Explorer Confirm the transfer by hitting the Sign and Submit button. Hint Sign with your substrate account. Hint If everything went fine, you are going to see a success message at the button of the page Hint Now head over to the substrate explorer to check if the DApp successfully wrote the transfer into a block Success Congrats, you successfully swapped ZEP from the substrate to the EVM side. Feel free to reverse the swap and use the wallets function to your needs.","title":" STEP 04 - Confirmation "},{"location":"get-started/internal-transfer/#part-2-what-happens-in-the-background","text":"Many may ask themselves whether Zukma is a single chain when it has both an ethereum and substrate side at the same time? Well, to make a long story short... Zukma is one single chain BUT it runs an ethereum simulation in parallel. How does this work? To answer this question, we need to look at the node architecture. Nodes are the pillars of our distributed network, and they run all the necessary code. I want to direct your focus to the SUBSTRATE RUNTIME module of the Substrate Node. The Runtime hosts all the code that makes Zukma unique, and it's composed of code pallets. As you can see, the democracy function of our chain is also a code pallet and allows our community to govern the chain. Likewise, the staking pallet enables our community to run validators and stake as nominators. Like those pallets, the EVM is another pallet that allows our community to interact with eth-based smart contracts and cross-chain bridges. By performing the transfer described in step 01, we are transferring coins from the SUBSTRATE RUNTIME ENVIRONMENT into the EVM pallet and vice versa, that's it :D. As briefly touched on earlier, the EVM side opens up many new opportunities for you to utilize your ZEP coins. Written by Zukma Team","title":" PART 2 - WHAT HAPPENS IN THE BACKGROUND "},{"location":"get-started/transfer-balances/","text":"TRANSFER BALANCES Balance transfers are used to send ZEP balances from one account to another account. To start transferring balances, we will begin by using our Substrate Explorer App . Hint This guide assumes that you've already created an account and have some funds that are ready to be transferred. Zukma Subtrate Explorer App Let's begin by opening Substrate Explorer App . There are two ways to make a balance transfer: By using the \"Transfer\" tab in the \"Accounts\" dropdown Clicking the \"send\" button while in the \"Accounts\" page Using the Transfer Tab Click on the \"Transfer\" tab in the \"Accounts\" dropdown. Now a pop-up window will appear on the page. The pop-up asks you to enter 3 inputs: \"send from account\": Your account with funds that you will send from. \"send to address\": The address of the account that will receive the funds. \"amount\": The amount of tokens you will transfer. After setting your inputs correctly, click the \"Make Transfer\" button and confirm. Once the transfer is included in a block you will see a green notification in the top-right corner of your screen. Keep-Alive Checks At an extrinsic level, there are two main ways to transfer funds from one account to another. These are transfer and transfer_keep_alive . transfer will allow you to send ZEP regardless of the consequence; transfer_keep_alive will not allow you to send an amount that would allow the sending account to be removed due to it going below the existential deposit. By default, Substrate Explorer App will use transfer_keep_alive , ensuring that the account you send from cannot drop below the existential deposit (0.001666 ZEP). However, it may be that you do not want to keep this account alive (for example, because you are moving all of your funds to a different address). In this case, click on the \"keep-alive\" toggle at the bottom of the pop-up window. The label should switch from \"Transfer with account keep-alive checks\"( transfer_keep_alive will be used) to \"Normal transfer without keep-alive checks\" ( transfer extrinsic will be used). As a common use case for using normal transfers is to entirely clear out the account, a second toggle will appear if you have the keep-alive check turned off that will send all the tokens in the account, minus a transaction fee, to the destination address. Attempting to send less than the existential deposit to an account with 0 ZEP will always fail, no matter if the keep-alive check is on or not. For instance, attempting to transfer 0.001 ZEP to an account you just generated (and thus has no ZEP) will fail, since 0.001 ZEP is less than the existential deposit of 0.001666 ZEP and the account cannot be initialized with such a low balance. Warning Even if the transfer fails due to a keep-alive check, the transaction fee will be deducted from the sending account if you attempt to transfer. Existing Reference Error If you are trying to reap an account and you recieve an error similar to \"There is an existing reference count on the sender account. As such the account cannot be reaped from the state\", then you have existing references to this account that must first be removed before it can be reaped. References may still exist from: Bonded coins (most likely) Unpurged session keys (if you were previously a validator) Coin locks Existing recovery info Existing assets Bonded Coins If you have coins that are bonded, you will need to unbond them before you can reap your account. Follow the instructions at Unbonding and Rebonding to check if you have bonded coins, stop nominating (if necessary) and unbond your coins. Purging Session Keys If you used this account to set up a validator and you did not purge your keys before unbonding your coins, you need to purge your keys. You can do this by seeing the How to Stop Validating page. This can also be checked by checking session.nextKeys in the chain state for an existing key. Checking for Locks You can check for locks by querying system.account(AccountId) under Developer > Chain state . Select your account, then click the \"+\" button next to the dropdowns, and check the relative data JSON object. If you see a non-zero value for anything other than free , you have locks on your account that need to get resolved. You can also check for locks by navigating to Accounts > Accounts in Substrate Explorer App . Then, click the dropdown arrow of the relevant account under the 'balances' column. If it shows that some tokens are in a 'locked' state, you can see why by hovering over the information icon next to it. Existing Recovery Info Currently, Zukma does not use the Recovery Pallet , so this is probably not the reason for your coins having existing references. On Zukma, you can check if recovery has been set up by checking the recovery.recoverable(AccountId) chain state. This can be found under Developer > Chain state in Substrate Explorer App . Existing Non-ZEP Assets Currently, Zukma does not use the Assets Pallet , so this is probably not the reason for your tokens having existing references. From the Accounts Page Navigate to the \"Accounts\" page by selecting the \"Accounts\" tab from the \"Accounts\" dropdown located on the top navigational menu of Substrate Explorer App . You will see a list of accounts you have loaded. Click the \"Send\" button in the row for the account you will like to send funds from. Now you will see the same pop-up window as if using the \"Transfer\" tab. Fill in the inputs correctly and hit \"Make Transfer\" then confirm the balance transfer. You will see a green notification in the top-right corner of the screen when the transfer is included in a block. Written by Zukma Team","title":"Transfer Balances"},{"location":"get-started/transfer-balances/#transfer-balances","text":"Balance transfers are used to send ZEP balances from one account to another account. To start transferring balances, we will begin by using our Substrate Explorer App . Hint This guide assumes that you've already created an account and have some funds that are ready to be transferred.","title":"TRANSFER BALANCES"},{"location":"get-started/transfer-balances/#zukma-subtrate-explorer-app","text":"Let's begin by opening Substrate Explorer App . There are two ways to make a balance transfer: By using the \"Transfer\" tab in the \"Accounts\" dropdown Clicking the \"send\" button while in the \"Accounts\" page","title":"Zukma Subtrate Explorer App"},{"location":"get-started/transfer-balances/#using-the-transfer-tab","text":"Click on the \"Transfer\" tab in the \"Accounts\" dropdown. Now a pop-up window will appear on the page. The pop-up asks you to enter 3 inputs: \"send from account\": Your account with funds that you will send from. \"send to address\": The address of the account that will receive the funds. \"amount\": The amount of tokens you will transfer. After setting your inputs correctly, click the \"Make Transfer\" button and confirm. Once the transfer is included in a block you will see a green notification in the top-right corner of your screen.","title":"Using the Transfer Tab"},{"location":"get-started/transfer-balances/#keep-alive-checks","text":"At an extrinsic level, there are two main ways to transfer funds from one account to another. These are transfer and transfer_keep_alive . transfer will allow you to send ZEP regardless of the consequence; transfer_keep_alive will not allow you to send an amount that would allow the sending account to be removed due to it going below the existential deposit. By default, Substrate Explorer App will use transfer_keep_alive , ensuring that the account you send from cannot drop below the existential deposit (0.001666 ZEP). However, it may be that you do not want to keep this account alive (for example, because you are moving all of your funds to a different address). In this case, click on the \"keep-alive\" toggle at the bottom of the pop-up window. The label should switch from \"Transfer with account keep-alive checks\"( transfer_keep_alive will be used) to \"Normal transfer without keep-alive checks\" ( transfer extrinsic will be used). As a common use case for using normal transfers is to entirely clear out the account, a second toggle will appear if you have the keep-alive check turned off that will send all the tokens in the account, minus a transaction fee, to the destination address. Attempting to send less than the existential deposit to an account with 0 ZEP will always fail, no matter if the keep-alive check is on or not. For instance, attempting to transfer 0.001 ZEP to an account you just generated (and thus has no ZEP) will fail, since 0.001 ZEP is less than the existential deposit of 0.001666 ZEP and the account cannot be initialized with such a low balance. Warning Even if the transfer fails due to a keep-alive check, the transaction fee will be deducted from the sending account if you attempt to transfer.","title":"Keep-Alive Checks"},{"location":"get-started/transfer-balances/#existing-reference-error","text":"If you are trying to reap an account and you recieve an error similar to \"There is an existing reference count on the sender account. As such the account cannot be reaped from the state\", then you have existing references to this account that must first be removed before it can be reaped. References may still exist from: Bonded coins (most likely) Unpurged session keys (if you were previously a validator) Coin locks Existing recovery info Existing assets","title":"Existing Reference Error"},{"location":"get-started/transfer-balances/#bonded-coins","text":"If you have coins that are bonded, you will need to unbond them before you can reap your account. Follow the instructions at Unbonding and Rebonding to check if you have bonded coins, stop nominating (if necessary) and unbond your coins.","title":"Bonded Coins"},{"location":"get-started/transfer-balances/#purging-session-keys","text":"If you used this account to set up a validator and you did not purge your keys before unbonding your coins, you need to purge your keys. You can do this by seeing the How to Stop Validating page. This can also be checked by checking session.nextKeys in the chain state for an existing key.","title":"Purging Session Keys"},{"location":"get-started/transfer-balances/#checking-for-locks","text":"You can check for locks by querying system.account(AccountId) under Developer > Chain state . Select your account, then click the \"+\" button next to the dropdowns, and check the relative data JSON object. If you see a non-zero value for anything other than free , you have locks on your account that need to get resolved. You can also check for locks by navigating to Accounts > Accounts in Substrate Explorer App . Then, click the dropdown arrow of the relevant account under the 'balances' column. If it shows that some tokens are in a 'locked' state, you can see why by hovering over the information icon next to it.","title":"Checking for Locks"},{"location":"get-started/transfer-balances/#existing-recovery-info","text":"Currently, Zukma does not use the Recovery Pallet , so this is probably not the reason for your coins having existing references. On Zukma, you can check if recovery has been set up by checking the recovery.recoverable(AccountId) chain state. This can be found under Developer > Chain state in Substrate Explorer App .","title":"Existing Recovery Info"},{"location":"get-started/transfer-balances/#existing-non-zep-assets","text":"Currently, Zukma does not use the Assets Pallet , so this is probably not the reason for your tokens having existing references.","title":"Existing Non-ZEP Assets"},{"location":"get-started/transfer-balances/#from-the-accounts-page","text":"Navigate to the \"Accounts\" page by selecting the \"Accounts\" tab from the \"Accounts\" dropdown located on the top navigational menu of Substrate Explorer App . You will see a list of accounts you have loaded. Click the \"Send\" button in the row for the account you will like to send funds from. Now you will see the same pop-up window as if using the \"Transfer\" tab. Fill in the inputs correctly and hit \"Make Transfer\" then confirm the balance transfer. You will see a green notification in the top-right corner of the screen when the transfer is included in a block. Written by Zukma Team","title":"From the Accounts Page"},{"location":"home/FAQs/","text":"FREQUENTLY ASKED QUESTIONS General FAQs Attention Disclaimer Zukma is a work in progress. The following FAQs will continue to be updated as the platform evolves. The exact structures and technologies to be included over time and are liable to change with continued research and the possible need for adaptation due to the fast-paced development in the crypto industry What is our mission? We\u2019re on a mission to truly decentralise finance. We revolutionize the future of DeFi by providing the industry-leading ecosystem, blockchain, exchange and end-to-end financial platform within a community-governed ecosystem. Why do we need Zukma to help achieve true Decentralisation? The distribution of funds in the crypto space is still relatively centralised with the majority of funds in the hands of relatively few. Part of this is because the technology is still in its youth and adoption still hasn\u2019t reached the masses, although the path towards real mass adoption is getting clearer by the day. The Problem of centralised funds still persists as a lot of coins and tokens are in the hands of a small number of big players in the industry. In order to further disperse these financial resources and give everyone a fair chance of participating in an independent market, exchanges mark a pivotal point. A widespread allocation is only possible if there are a lot of different - ideally independent and decentralised - exchanges that grant access to assets with each acting as a sort of contingency for another, avoiding risk of corruption. The requirements for those exchanges are steadily rising and rightfully so. Investors want to be able to voice their concerns when putting their hard earned money at risk and the weight of their voice has been rather small in the past. It's clear that it's one of the major challenges for exchanges and DeFi-projects to empower the individual investors and give them the right to vote on important decisions. With growing desire for participation comes the question on how to meet the needs of the growing crypto community. Zukma offers its users participation through an elaborate voting and consensus mechanism that strives to best represent the interest of each and every one of their investors through nominating the most trustworthy validators (nodes that supply the blockchain with the hardware necessary) and voting upon a trusted council to ensure long term stability of the chain and the trading D'Apps deployed on its native Zukma Network. Zukma Launch\u200b The Genesis block of the Zukma network was launched on 00-00-00 00:00:00 UTC, as a nominated Proof of Stake (nPoS) network. Zukma Roadmap\u200b For more information on the Zukma roadmap on its way to decentralise finance, please visit the LINK to New ZEP Homepage Roadmap! How many chains can Zukma connect? There is no specific limit to the number of chains that can be connected to the Zukma network. As long as working bridges exist, there is a way to connect. Does Zukma support smart contracts?\u200b Zukma supports all common smart contract languages and tool-workflows. Deploy your existing project within minutes or start building with familiar tools and languages What keeps Zukma's governance from failing?\u200b Zukma's governance has already been shown to work. Examples can be found in the runtime upgrades that have successfully taken place through on the testnets as well as in a real economic environment on Kusama and Polkadot itself. Blockchains and especially projects that focus on decentralised finance need a method to adapt and evolve while taking the interests of their community into consideration. Therefore, an on-chain governance system is of utmost importance for the long-term success of Zukma. Ultimately, it is the coin holders that are responsible for preventing Zukma's governance from failing by using their economic value and convictions to guide the progression of the protocol and push the project towards true decentralised finance. What prevents Zukma's governance from becoming centralised? A savvy reader might have noticed that the answer to the previous question endowed the coin holders with the ultimate responsibility to ensure that Zukma\u2019s governance does not fail. By following the train of this assertion, one might assume that Zukma's governance is susceptible to becoming ruled by a few large token holders (called whales in trading parlance) and therefore become a mere plutocracy (rule of the rich). There are several other mechanisms that are built-in to the governance system to resist this plutocratic tendency. One of these mechanisms is called conviction voting, and imposes greater voting power to token holders who are willing to lock their tokens on the protocol for longer lengths of time. Longer lock-ups display conviction in a vote. Conviction voting could allow a highly determined minority to overrule the vote of an apathetic majority in certain situations. Another mechanism is known as Adaptive Quorum Biasing. This makes proposals have a varying threshold for approval or rejection based on what part of the governance protocol the proposal originated in. For details on the subtleties of Zukma\u2019s governance system, please check out our Governance documentation . Web3 Foundation What is the Web3 Foundation? Web3 Foundation is a Swiss Stiftung established under Article 80 et seqq. of the Swiss Civil Code. The Web3 Foundation was founded by Dr. Gavin Wood and has as its focus the development, deployment and maintenance of \u201cWeb3\u201d. Web3 Foundation promotes the development of innovative technologies and applications in the field of cryptographically-enabled decentralised software protocols. Web3 Foundation\u2019s purpose is to nurture and steward cutting-edge technologies and applications at all levels of the Web3 technology stack. Web3\u2019s principal focus is research, development, deployment, funding, and maintenance of Web3 technologies, plus advocacy and education, developer-adoption, support of middleware, and base-layer/demonstration applications. The Web3 Foundation Council is Web3\u2019s governing body, responsible for the management of the Web3 Foundation. The current members of the Web3 Foundation Council are Dr. Gavin Wood (President and Founder), Dr. Aeron Buchanan (Vice President) and Reto Trinkler. Swiss foundations are subject to a mandatory supervision by a federal or cantonal authority. The Web3 Foundation\u2019s application for approval by Eidgen\u00f6ssische Stiftungsaufsicht (Federal Foundation Supervisory Authority) was approved July 2018. Risk factors associated with ZEP Nature of the legal relationship between holders of ZEP is uncertain. The legal nature of the relationship (if any) between the holders of ZEP and the liabilities and obligations of holders of ZEP is uncertain. Regulatory treatment of ZEP is uncertain As the sale of tokens is a nascent practice, the treatment of ZEP by regulatory and governmental authorities is uncertain and may vary across jurisdictions. The legal and regulatory treatment of ZEP may be prone to change in the future, which may have a materially adverse impact on the legal status of ZEP, the economic value (if any) of ZEP and the liquidity of ZEP, as well as the development, function or governance of Zukma and / or the Web3 Foundation itself. Technical FAQ How can I add Zukma to MetaMask? RPC URL : https://rpc.zukma.org/ Chain ID : 77 Currency Symbol : ZEP Explorer: https://evm.,zukma.org/ What is the polkadot.js extension? Do I need to get it to interact with the chain? The Polkadot.js is a browser extension that enables you to create and manage a substrate account (the framework that was used to build i.e. Polkadot, Kusama, and the Zukma chain). To interact with the chain and its staking and governance mechanisms, you need to install it. You can find a video guide here . Where do I find further information on how to become a validator? https://docs.zukma.org/validator-guides/validator/ How can I Nominate/Stake? https://docs.zukma.org/what-to-try/nominator/ Okay I'm hooked, where are the Deep Dives? https://docs.zukma.org/deep-dives/evm-pallet/ I am a developer, where do I look? Work in Progress: https://docs.zukma.org/dev-guides/ What is the minimum amount of ZEP I can have in my account?\u200b 0.1 ZEP What is the block time of Zukma?\u200b Zukma is currently operating at a block time of approximately six seconds. This may be changed in the future. It may be lowered to two or three seconds after optimizations, or potentially increase due to unforeseen circumstances. Does Zukma support smart contracts?\u200b Zukma supports all common smart contract languages and tool-workflows. Deploy your existing project within minutes or start building with familiar tools and languages What is the inflation rate of ZEP?\u200b The inflation rate is based on the amount of ZEP tokens locked in staking. Assuming the ideal staking rate of 50% is reached, the inflation is set to approximately 10% per year. A higher percentage staked will result in a sharp drop of the interest as well as the inflation rate to incentivize the unbonding of funds and to avoid running into shortage of liquidity. What are the transfer fees on Zukma? \u200b It is important to note that the cost of transferring ZEP is dynamic. Currently, the minimum cost of transferring ZEP is ~1.5 milli ZEP, although this can be changed via governance. However, actual transaction fees will vary based on a variety of factors. Specifically, fee calculation follows the following formula: base_fee + (tx_length * length_fee) + WeightToFee(weight) For further information please visit the Substrate documentation on fee calculation . Note On the EVM side the fee is set to 50GWEI, which can be either decreased or increased. Where can I find info about upcoming changes and votes concerning the chain? You can check out proposals and referenda via the governance tab on the explorer here . If you want to partake in the discussion about future changes and the planning of proposals, check the forum for details. Upcoming events concerning the chain can be found on the upcoming event calendar as well. Economic and Staking FAQs Where can I buy ZEP? You can buy ZEP at Buy Zukma Where can I find the tokenomics? The tokenomics can be found on our website: https://zukma.org Where do I find further information on how to become a validator? https://docs.zukma.org/validator-guides/validator/ How can I Nominate/Stake? https://docs.zukma.org/what-to-try/nominator/ How do payouts work? You can find further explanation regarding block rewards and payouts here and here Note Every party involved with a validator is able to request a payout for their own rewards and additionally has the option to make use of the \"payout all\" function, initiating the payout for every party that's eligible for rewards for based upon their respective active eras. Meaning you as a Nominator are not dependent on the Validator to pay out your rewards for you but instead can request your (or everyone's payouts) when you need to. Therefore, you are not at risk of the Validator missing its 21-day deadline (84 eras) for payouts and are in full control of your funds. How are the rewards calculated? Inflation and Interest rates for Zukma at the moment Zukma Interest and Inflation curve https://user-images.githubusercontent.com/91843891/148518117-0921ce62-ef49-4966-8468-1b2b38081733.png What is the inflation rate of ZEP?\u200b The inflation rate is based on the amount of ZEP tokens locked in staking. Assuming the ideal staking rate of 50% is reached, the inflation is set to approximately 10% per year. A higher percentage staked will result in a sharp drop of the interest as well as the inflation rate to incentivize the unbonding of funds and to avoid running into shortage of liquidity. Why does Zukma only have 300 validators?\u200b Zukma opted to start with an active set of 300 validators to create a reasonable and solid foundation for the chain. It's important to note that different projects have different definitions of their validators/nodes, whereas for Zukma, every validator is running their own validating node that performs full verification of the Chain, votes on finality and produces blocks in their decided slots. Comparable projects operate on about 150 active validators. Additionally, the validation is not the sole source of staking. Nominators participate in the staking system as well and receive rewards on the funds they are willing to commit/bond. For every validator, there is a maximum of 256 Nominations possible, with a total of 76,800 possible participants in the staking system for now. The amount of active validators can be changed later by decision of the community through fair and decentralised governance decisions. Further Information can be found here: Validation and Nomination What is the minimum bond necessary to create a validator?\u200b The minimum stake that is necessary to initially be able to create a validator is as low as 0.1 ZEP, which can be changed by the chain's governance. Making it to the list of active validators depends on the amount of ZEP that are bonded to the actual active set of validators, the amount of bonded ZEP on validators on the waiting list as well as the maximum number of validators, which can be increased or decreased by our voting mechanism as well. One way to estimate the minimum amount of ZEP your validator needs to make it to the active set is to navigate to the Targets Tab , sort by maximum stake and look for the least amount that is needed to be eligible for the next era.. You\u2019ll need at least this much + 1 to enter the set. How many active Nominators can a Validator have? 256 is the amount of Nominations a Validator can recieve. 257 Nominations would mean the Validator is oversubscribed and only the top 256 Nominators (based upon bonded ZEP) will be eligible for payouts/rewards. What is the maximum number of Validators a Nominator can bond to? 16 is the maximum number of different validators one Nominator can bond funds to. Note Due to security reasons, we recommend using a separate Stash and Controller Account for every Nomination Can I stop/pause my validator without getting punished? Yes, you can set your validator into the \"chill\" status by going to your \" account actions \" page and click on the \"STOP\" button. This will move your validator into a sleeping stance without losing funds. Reasons for pausing might be intended migration to another server or an upcoming extended server maintenance. You might want to inform your Nominators on the Zukma Forum or on Telegram to give them a heads-up about missing payouts. You can find further information in the deep dive . I want to switch my VPS provider/Change my server hardware. What do I need to consider? You can follow our guide to change the VPS provider. I ran out of storage on my Validator. How do I migrate without the risk of getting slashed/losing funds? -> look above I am running a validator, but it says I am on the waiting list. What does that mean? Being on the waiting list means that your validator has successfully connected to the chain and is - from a technical standpoint - working as intended. The most likely reason for being in the waiting list is that the amount of ZEP nominated (staked) is not high enough to be in the top 300. The amount of nominated (staked) ZEP on your validator will determine if you can make it into the top 300. You can go to the targets page of the explorer to check your rank and see how much is needed for you to move into the active set of validators here (sort for total stake and check which has the least amount to be eligible for the next era to determine the threshold) Other reasons may be connectivity issues from you or your providers side. You can check out Telegram or the Forum and seek help there. Networking FAQs What is libp2p?\u200b Libp2p is a modular and extensible networking stack that is used by IPFS, Substrate, and many other projects. It is a collection of peer-to-peer protocols for finding peers and connecting to them. Its modules have logic for content routing, peer routing, peer discovery, different transports, and NAT traversals. It is intended to be used by applications for building large scale peer-to-peer networks by only selecting the parts of the protocol suite that are needed. The Rust implementation of the specification was built and primarily maintained by a team of contributors at Parity Technologies. The Go and JavaScript versions are maintained by Protocol Labs as well as community contributors. A Nim version of the library also exists. Libp2p as a whole is an open source project that is actively developed and expanded on various code repositories hosted on their GitHub . Does Zukma use libp2p?\u200b Yes, since Zukma is built with Substrate. Substrate uses a networking protocol that is based on libp2p (specifically the Rust libp2p library). However, Substrate uses a mix of standard libp2p protocols and protocols that are homegrown and not official libp2p standards. Of the standard protocols, those which are shared with other implementations of libp2p such as IPFS, are connection-checking (ping), asking for information on a peer (identity), and Kademlia random walks (kad). Of the protocols that are custom to Substrate, there are the legacy Substrate stream, a request-response for getting information on blocks (sync), a light client protocol, a notification protocol for transactions, and block announcement. For detailed information on how Substrate uses libp2p and the standard and custom protocols, please see the networking documentation . How does libp2p differ from IPFS?\u200b The Interplanetary File System (IPFS) is a peer-to-peer hypermedia protocol used primarily for storage of files. It allows one to upload a file onto the network and share it with its content addressable URI. IPFS, like Substrate, is an application of libp2p and exists higher on the technology stack. Although both IPFS and Substrate use libp2p, it cannot be said that Substrate \"uses\" IPFS since besides sharing the underlying library for networking there is no native integration between the two applications. Team FAQ Who is behind Zukma? The Zukma team is an international team of crypto experts and enthusiasts with backgrounds in various professions. We are mainly based in South East Africa but also work closely together with members in the USA, Australia and Turkey. I want to inquire more, how can I contact the officials? Send an Email to: support@zukma.org Community FAQ Where does the community action take place? Find us on Discord , Twitter , Telegram on Github and in our Forum You can find further information on News . Where can I learn more about the Validators supporting the chain? You can check out information provided by the Community's Validators in our Forum For Technical Information check out our documentation . Can I help/support Zukma? Yes, you can take part in supporting the project and spread the word. Take a look at the Zukma Community Bounty Program Written by Zukma Team","title":"FAQs"},{"location":"home/FAQs/#frequently-asked-questions","text":"","title":"FREQUENTLY ASKED QUESTIONS"},{"location":"home/FAQs/#general-faqs","text":"Attention Disclaimer Zukma is a work in progress. The following FAQs will continue to be updated as the platform evolves. The exact structures and technologies to be included over time and are liable to change with continued research and the possible need for adaptation due to the fast-paced development in the crypto industry","title":"General FAQs"},{"location":"home/FAQs/#what-is-our-mission","text":"We\u2019re on a mission to truly decentralise finance. We revolutionize the future of DeFi by providing the industry-leading ecosystem, blockchain, exchange and end-to-end financial platform within a community-governed ecosystem. Why do we need Zukma to help achieve true Decentralisation? The distribution of funds in the crypto space is still relatively centralised with the majority of funds in the hands of relatively few. Part of this is because the technology is still in its youth and adoption still hasn\u2019t reached the masses, although the path towards real mass adoption is getting clearer by the day. The Problem of centralised funds still persists as a lot of coins and tokens are in the hands of a small number of big players in the industry. In order to further disperse these financial resources and give everyone a fair chance of participating in an independent market, exchanges mark a pivotal point. A widespread allocation is only possible if there are a lot of different - ideally independent and decentralised - exchanges that grant access to assets with each acting as a sort of contingency for another, avoiding risk of corruption. The requirements for those exchanges are steadily rising and rightfully so. Investors want to be able to voice their concerns when putting their hard earned money at risk and the weight of their voice has been rather small in the past. It's clear that it's one of the major challenges for exchanges and DeFi-projects to empower the individual investors and give them the right to vote on important decisions. With growing desire for participation comes the question on how to meet the needs of the growing crypto community. Zukma offers its users participation through an elaborate voting and consensus mechanism that strives to best represent the interest of each and every one of their investors through nominating the most trustworthy validators (nodes that supply the blockchain with the hardware necessary) and voting upon a trusted council to ensure long term stability of the chain and the trading D'Apps deployed on its native Zukma Network.","title":"What is our mission?"},{"location":"home/FAQs/#zukma-launch","text":"The Genesis block of the Zukma network was launched on 00-00-00 00:00:00 UTC, as a nominated Proof of Stake (nPoS) network.","title":"Zukma Launch\u200b"},{"location":"home/FAQs/#zukma-roadmap","text":"For more information on the Zukma roadmap on its way to decentralise finance, please visit the LINK to New ZEP Homepage Roadmap!","title":"Zukma Roadmap\u200b"},{"location":"home/FAQs/#how-many-chains-can-zukma-connect","text":"There is no specific limit to the number of chains that can be connected to the Zukma network. As long as working bridges exist, there is a way to connect.","title":"How many chains can Zukma connect?"},{"location":"home/FAQs/#does-zukma-support-smart-contracts","text":"Zukma supports all common smart contract languages and tool-workflows. Deploy your existing project within minutes or start building with familiar tools and languages","title":"Does Zukma support smart contracts?\u200b"},{"location":"home/FAQs/#what-keeps-zukmas-governance-from-failing","text":"Zukma's governance has already been shown to work. Examples can be found in the runtime upgrades that have successfully taken place through on the testnets as well as in a real economic environment on Kusama and Polkadot itself. Blockchains and especially projects that focus on decentralised finance need a method to adapt and evolve while taking the interests of their community into consideration. Therefore, an on-chain governance system is of utmost importance for the long-term success of Zukma. Ultimately, it is the coin holders that are responsible for preventing Zukma's governance from failing by using their economic value and convictions to guide the progression of the protocol and push the project towards true decentralised finance.","title":"What keeps Zukma's governance from failing?\u200b"},{"location":"home/FAQs/#what-prevents-zukmas-governance-from-becoming-centralised","text":"A savvy reader might have noticed that the answer to the previous question endowed the coin holders with the ultimate responsibility to ensure that Zukma\u2019s governance does not fail. By following the train of this assertion, one might assume that Zukma's governance is susceptible to becoming ruled by a few large token holders (called whales in trading parlance) and therefore become a mere plutocracy (rule of the rich). There are several other mechanisms that are built-in to the governance system to resist this plutocratic tendency. One of these mechanisms is called conviction voting, and imposes greater voting power to token holders who are willing to lock their tokens on the protocol for longer lengths of time. Longer lock-ups display conviction in a vote. Conviction voting could allow a highly determined minority to overrule the vote of an apathetic majority in certain situations. Another mechanism is known as Adaptive Quorum Biasing. This makes proposals have a varying threshold for approval or rejection based on what part of the governance protocol the proposal originated in. For details on the subtleties of Zukma\u2019s governance system, please check out our Governance documentation .","title":"What prevents Zukma's governance from becoming centralised?"},{"location":"home/FAQs/#web3-foundation","text":"","title":"Web3 Foundation"},{"location":"home/FAQs/#what-is-the-web3-foundation","text":"Web3 Foundation is a Swiss Stiftung established under Article 80 et seqq. of the Swiss Civil Code. The Web3 Foundation was founded by Dr. Gavin Wood and has as its focus the development, deployment and maintenance of \u201cWeb3\u201d. Web3 Foundation promotes the development of innovative technologies and applications in the field of cryptographically-enabled decentralised software protocols. Web3 Foundation\u2019s purpose is to nurture and steward cutting-edge technologies and applications at all levels of the Web3 technology stack. Web3\u2019s principal focus is research, development, deployment, funding, and maintenance of Web3 technologies, plus advocacy and education, developer-adoption, support of middleware, and base-layer/demonstration applications. The Web3 Foundation Council is Web3\u2019s governing body, responsible for the management of the Web3 Foundation. The current members of the Web3 Foundation Council are Dr. Gavin Wood (President and Founder), Dr. Aeron Buchanan (Vice President) and Reto Trinkler. Swiss foundations are subject to a mandatory supervision by a federal or cantonal authority. The Web3 Foundation\u2019s application for approval by Eidgen\u00f6ssische Stiftungsaufsicht (Federal Foundation Supervisory Authority) was approved July 2018.","title":"What is the Web3 Foundation?"},{"location":"home/FAQs/#risk-factors-associated-with-zep","text":"","title":"Risk factors associated with ZEP"},{"location":"home/FAQs/#nature-of-the-legal-relationship-between-holders-of-zep-is-uncertain","text":"The legal nature of the relationship (if any) between the holders of ZEP and the liabilities and obligations of holders of ZEP is uncertain.","title":"Nature of the legal relationship between holders of ZEP is uncertain."},{"location":"home/FAQs/#regulatory-treatment-of-zep-is-uncertain","text":"As the sale of tokens is a nascent practice, the treatment of ZEP by regulatory and governmental authorities is uncertain and may vary across jurisdictions. The legal and regulatory treatment of ZEP may be prone to change in the future, which may have a materially adverse impact on the legal status of ZEP, the economic value (if any) of ZEP and the liquidity of ZEP, as well as the development, function or governance of Zukma and / or the Web3 Foundation itself.","title":"Regulatory treatment of ZEP is uncertain"},{"location":"home/FAQs/#technical-faq","text":"","title":"Technical FAQ"},{"location":"home/FAQs/#how-can-i-add-zukma-to-metamask","text":"RPC URL : https://rpc.zukma.org/ Chain ID : 77 Currency Symbol : ZEP Explorer: https://evm.,zukma.org/","title":"How can I add Zukma to MetaMask?"},{"location":"home/FAQs/#what-is-the-polkadotjs-extension-do-i-need-to-get-it-to-interact-with-the-chain","text":"The Polkadot.js is a browser extension that enables you to create and manage a substrate account (the framework that was used to build i.e. Polkadot, Kusama, and the Zukma chain). To interact with the chain and its staking and governance mechanisms, you need to install it. You can find a video guide here .","title":"What is the polkadot.js extension? Do I need to get it to interact with the chain?"},{"location":"home/FAQs/#where-do-i-find-further-information-on-how-to-become-a-validator","text":"https://docs.zukma.org/validator-guides/validator/","title":"Where do I find further information on how to become a validator?"},{"location":"home/FAQs/#how-can-i-nominatestake","text":"https://docs.zukma.org/what-to-try/nominator/","title":"How can I Nominate/Stake?"},{"location":"home/FAQs/#okay-im-hooked-where-are-the-deep-dives","text":"https://docs.zukma.org/deep-dives/evm-pallet/","title":"Okay I'm hooked, where are the Deep Dives?"},{"location":"home/FAQs/#i-am-a-developer-where-do-i-look","text":"Work in Progress: https://docs.zukma.org/dev-guides/","title":"I am a developer, where do I look?"},{"location":"home/FAQs/#what-is-the-minimum-amount-of-zep-i-can-have-in-my-account","text":"0.1 ZEP","title":"What is the minimum amount of ZEP I can have in my account?\u200b"},{"location":"home/FAQs/#what-is-the-block-time-of-zukma","text":"Zukma is currently operating at a block time of approximately six seconds. This may be changed in the future. It may be lowered to two or three seconds after optimizations, or potentially increase due to unforeseen circumstances.","title":"What is the block time of Zukma?\u200b"},{"location":"home/FAQs/#does-zukma-support-smart-contracts_1","text":"Zukma supports all common smart contract languages and tool-workflows. Deploy your existing project within minutes or start building with familiar tools and languages","title":"Does Zukma support smart contracts?\u200b"},{"location":"home/FAQs/#what-is-the-inflation-rate-of-zep","text":"The inflation rate is based on the amount of ZEP tokens locked in staking. Assuming the ideal staking rate of 50% is reached, the inflation is set to approximately 10% per year. A higher percentage staked will result in a sharp drop of the interest as well as the inflation rate to incentivize the unbonding of funds and to avoid running into shortage of liquidity.","title":"What is the inflation rate of ZEP?\u200b"},{"location":"home/FAQs/#what-are-the-transfer-fees-on-zukma","text":"It is important to note that the cost of transferring ZEP is dynamic. Currently, the minimum cost of transferring ZEP is ~1.5 milli ZEP, although this can be changed via governance. However, actual transaction fees will vary based on a variety of factors. Specifically, fee calculation follows the following formula: base_fee + (tx_length * length_fee) + WeightToFee(weight) For further information please visit the Substrate documentation on fee calculation . Note On the EVM side the fee is set to 50GWEI, which can be either decreased or increased.","title":"What are the transfer fees on Zukma?\u200b"},{"location":"home/FAQs/#where-can-i-find-info-about-upcoming-changes-and-votes-concerning-the-chain","text":"You can check out proposals and referenda via the governance tab on the explorer here . If you want to partake in the discussion about future changes and the planning of proposals, check the forum for details. Upcoming events concerning the chain can be found on the upcoming event calendar as well.","title":"Where can I find info about upcoming changes and votes concerning the chain?"},{"location":"home/FAQs/#economic-and-staking-faqs","text":"","title":"Economic and Staking FAQs"},{"location":"home/FAQs/#where-can-i-buy-zep","text":"You can buy ZEP at Buy Zukma","title":"Where can I buy ZEP?"},{"location":"home/FAQs/#where-can-i-find-the-tokenomics","text":"The tokenomics can be found on our website: https://zukma.org","title":"Where can I find the tokenomics?"},{"location":"home/FAQs/#where-do-i-find-further-information-on-how-to-become-a-validator_1","text":"https://docs.zukma.org/validator-guides/validator/","title":"Where do I find further information on how to become a validator?"},{"location":"home/FAQs/#how-can-i-nominatestake_1","text":"https://docs.zukma.org/what-to-try/nominator/","title":"How can I Nominate/Stake?"},{"location":"home/FAQs/#how-do-payouts-work","text":"You can find further explanation regarding block rewards and payouts here and here Note Every party involved with a validator is able to request a payout for their own rewards and additionally has the option to make use of the \"payout all\" function, initiating the payout for every party that's eligible for rewards for based upon their respective active eras. Meaning you as a Nominator are not dependent on the Validator to pay out your rewards for you but instead can request your (or everyone's payouts) when you need to. Therefore, you are not at risk of the Validator missing its 21-day deadline (84 eras) for payouts and are in full control of your funds.","title":"How do payouts work?"},{"location":"home/FAQs/#how-are-the-rewards-calculated","text":"Inflation and Interest rates for Zukma at the moment Zukma Interest and Inflation curve https://user-images.githubusercontent.com/91843891/148518117-0921ce62-ef49-4966-8468-1b2b38081733.png","title":"How are the rewards calculated?"},{"location":"home/FAQs/#what-is-the-inflation-rate-of-zep_1","text":"The inflation rate is based on the amount of ZEP tokens locked in staking. Assuming the ideal staking rate of 50% is reached, the inflation is set to approximately 10% per year. A higher percentage staked will result in a sharp drop of the interest as well as the inflation rate to incentivize the unbonding of funds and to avoid running into shortage of liquidity.","title":"What is the inflation rate of ZEP?\u200b"},{"location":"home/FAQs/#why-does-zukma-only-have-300-validators","text":"Zukma opted to start with an active set of 300 validators to create a reasonable and solid foundation for the chain. It's important to note that different projects have different definitions of their validators/nodes, whereas for Zukma, every validator is running their own validating node that performs full verification of the Chain, votes on finality and produces blocks in their decided slots. Comparable projects operate on about 150 active validators. Additionally, the validation is not the sole source of staking. Nominators participate in the staking system as well and receive rewards on the funds they are willing to commit/bond. For every validator, there is a maximum of 256 Nominations possible, with a total of 76,800 possible participants in the staking system for now. The amount of active validators can be changed later by decision of the community through fair and decentralised governance decisions. Further Information can be found here: Validation and Nomination","title":"Why does Zukma only have 300 validators?\u200b"},{"location":"home/FAQs/#what-is-the-minimum-bond-necessary-to-create-a-validator","text":"The minimum stake that is necessary to initially be able to create a validator is as low as 0.1 ZEP, which can be changed by the chain's governance. Making it to the list of active validators depends on the amount of ZEP that are bonded to the actual active set of validators, the amount of bonded ZEP on validators on the waiting list as well as the maximum number of validators, which can be increased or decreased by our voting mechanism as well. One way to estimate the minimum amount of ZEP your validator needs to make it to the active set is to navigate to the Targets Tab , sort by maximum stake and look for the least amount that is needed to be eligible for the next era.. You\u2019ll need at least this much + 1 to enter the set.","title":"What is the minimum bond necessary to create a validator?\u200b"},{"location":"home/FAQs/#how-many-active-nominators-can-a-validator-have","text":"256 is the amount of Nominations a Validator can recieve. 257 Nominations would mean the Validator is oversubscribed and only the top 256 Nominators (based upon bonded ZEP) will be eligible for payouts/rewards.","title":"How many active Nominators can a Validator have?"},{"location":"home/FAQs/#what-is-the-maximum-number-of-validators-a-nominator-can-bond-to","text":"16 is the maximum number of different validators one Nominator can bond funds to. Note Due to security reasons, we recommend using a separate Stash and Controller Account for every Nomination","title":"What is the maximum number of Validators a Nominator can bond to?"},{"location":"home/FAQs/#can-i-stoppause-my-validator-without-getting-punished","text":"Yes, you can set your validator into the \"chill\" status by going to your \" account actions \" page and click on the \"STOP\" button. This will move your validator into a sleeping stance without losing funds. Reasons for pausing might be intended migration to another server or an upcoming extended server maintenance. You might want to inform your Nominators on the Zukma Forum or on Telegram to give them a heads-up about missing payouts. You can find further information in the deep dive .","title":"Can I stop/pause my validator without getting punished?"},{"location":"home/FAQs/#i-want-to-switch-my-vps-providerchange-my-server-hardware-what-do-i-need-to-consider","text":"You can follow our guide to change the VPS provider.","title":"I want to switch my VPS provider/Change my server hardware. What do I need to consider?"},{"location":"home/FAQs/#i-ran-out-of-storage-on-my-validator-how-do-i-migrate-without-the-risk-of-getting-slashedlosing-funds","text":"-> look above","title":"I ran out of storage on my Validator. How do I migrate without the risk of getting slashed/losing funds?"},{"location":"home/FAQs/#i-am-running-a-validator-but-it-says-i-am-on-the-waiting-list-what-does-that-mean","text":"Being on the waiting list means that your validator has successfully connected to the chain and is - from a technical standpoint - working as intended. The most likely reason for being in the waiting list is that the amount of ZEP nominated (staked) is not high enough to be in the top 300. The amount of nominated (staked) ZEP on your validator will determine if you can make it into the top 300. You can go to the targets page of the explorer to check your rank and see how much is needed for you to move into the active set of validators here (sort for total stake and check which has the least amount to be eligible for the next era to determine the threshold) Other reasons may be connectivity issues from you or your providers side. You can check out Telegram or the Forum and seek help there.","title":"I am running a validator, but it says I am on the waiting list. What does that mean?"},{"location":"home/FAQs/#networking-faqs","text":"","title":"Networking FAQs"},{"location":"home/FAQs/#what-is-libp2p","text":"Libp2p is a modular and extensible networking stack that is used by IPFS, Substrate, and many other projects. It is a collection of peer-to-peer protocols for finding peers and connecting to them. Its modules have logic for content routing, peer routing, peer discovery, different transports, and NAT traversals. It is intended to be used by applications for building large scale peer-to-peer networks by only selecting the parts of the protocol suite that are needed. The Rust implementation of the specification was built and primarily maintained by a team of contributors at Parity Technologies. The Go and JavaScript versions are maintained by Protocol Labs as well as community contributors. A Nim version of the library also exists. Libp2p as a whole is an open source project that is actively developed and expanded on various code repositories hosted on their GitHub .","title":"What is libp2p?\u200b"},{"location":"home/FAQs/#does-zukma-use-libp2p","text":"Yes, since Zukma is built with Substrate. Substrate uses a networking protocol that is based on libp2p (specifically the Rust libp2p library). However, Substrate uses a mix of standard libp2p protocols and protocols that are homegrown and not official libp2p standards. Of the standard protocols, those which are shared with other implementations of libp2p such as IPFS, are connection-checking (ping), asking for information on a peer (identity), and Kademlia random walks (kad). Of the protocols that are custom to Substrate, there are the legacy Substrate stream, a request-response for getting information on blocks (sync), a light client protocol, a notification protocol for transactions, and block announcement. For detailed information on how Substrate uses libp2p and the standard and custom protocols, please see the networking documentation .","title":"Does Zukma use libp2p?\u200b"},{"location":"home/FAQs/#how-does-libp2p-differ-from-ipfs","text":"The Interplanetary File System (IPFS) is a peer-to-peer hypermedia protocol used primarily for storage of files. It allows one to upload a file onto the network and share it with its content addressable URI. IPFS, like Substrate, is an application of libp2p and exists higher on the technology stack. Although both IPFS and Substrate use libp2p, it cannot be said that Substrate \"uses\" IPFS since besides sharing the underlying library for networking there is no native integration between the two applications.","title":"How does libp2p differ from IPFS?\u200b"},{"location":"home/FAQs/#team-faq","text":"","title":"Team FAQ"},{"location":"home/FAQs/#who-is-behind-zukma","text":"The Zukma team is an international team of crypto experts and enthusiasts with backgrounds in various professions. We are mainly based in South East Africa but also work closely together with members in the USA, Australia and Turkey. I want to inquire more, how can I contact the officials? Send an Email to: support@zukma.org","title":"Who is behind Zukma?"},{"location":"home/FAQs/#community-faq","text":"","title":"Community FAQ"},{"location":"home/FAQs/#where-does-the-community-action-take-place","text":"Find us on Discord , Twitter , Telegram on Github and in our Forum You can find further information on News .","title":"Where does the community action take place?"},{"location":"home/FAQs/#where-can-i-learn-more-about-the-validators-supporting-the-chain","text":"You can check out information provided by the Community's Validators in our Forum For Technical Information check out our documentation .","title":"Where can I learn more about the Validators supporting the chain?"},{"location":"home/FAQs/#can-i-helpsupport-zukma","text":"Yes, you can take part in supporting the project and spread the word. Take a look at the Zukma Community Bounty Program Written by Zukma Team","title":"Can I help/support Zukma?"},{"location":"home/quick-start/","text":"QUICK START Zukma is build using the substrate framework. In addition Zukma utlilizes an Ethereum-Virtual-Machine (EVM) pallet to enable a seamless interface to all EVM-based blockchains. Hence you can connect to Zukma on both sides, the Substrate and EVM side. Here is how: Connect to Zukma Substrate Just follow this link: Zukma Substrate DApp. In case you are new to substrate you can watch his video: ZEP Wallets Hint The Zukma Substrate DApp offers many functionalities like a fully functional block explorer, the ability to stake and validate and to participate in the on-chain governance. Connect to Zukma EVM To connect to Zukma's EVM we recommend to use MetaMask. Go to Settings -> Network -> Add new Network and enter the following network details: Network : Zukma Smart Chain RPC URL : https://rpc.zukma.org/ Chain ID : 77 Currency Symbol : ZEP Block Explorer: https://evm.zukma.org/ Zukma Dashboard Once connected with Zukma's Substrate and EVM side, you are all set to utilize the Zukma Dashboard The Zukma Dashboard is the one-stop-shop to utilize Zukma's unique features. Keep in mind that the dashboard will grow and expand to continue to provide utiliy. Zukma Dashboard Functionalities you can already access are: Claim: To claim your ZEP coins - YouTube Walkthrough Transfer: To bridge your ZEP from the Substrate to the EVM side and vice versa - YouTube Walkthrough Join the Zukma Community Connect with an outstanding and helpful community whenever you feel the need to ask questions, discuss topics or simply hang out with like-minded DeFi enthusiasts. \u2013 LinkedIn \u2013 Telegram \u2013 YouTube \u2013 Twitter \u2013 Github Hint Check out our forum as well: Forum This is especailly useful for on-chain governance and proposals.","title":"Quick Start"},{"location":"home/quick-start/#quick-start","text":"Zukma is build using the substrate framework. In addition Zukma utlilizes an Ethereum-Virtual-Machine (EVM) pallet to enable a seamless interface to all EVM-based blockchains. Hence you can connect to Zukma on both sides, the Substrate and EVM side. Here is how:","title":" QUICK START"},{"location":"home/quick-start/#connect-to-zukma-substrate","text":"Just follow this link: Zukma Substrate DApp. In case you are new to substrate you can watch his video: ZEP Wallets Hint The Zukma Substrate DApp offers many functionalities like a fully functional block explorer, the ability to stake and validate and to participate in the on-chain governance.","title":"Connect to Zukma Substrate"},{"location":"home/quick-start/#connect-to-zukma-evm","text":"To connect to Zukma's EVM we recommend to use MetaMask. Go to Settings -> Network -> Add new Network and enter the following network details: Network : Zukma Smart Chain RPC URL : https://rpc.zukma.org/ Chain ID : 77 Currency Symbol : ZEP Block Explorer: https://evm.zukma.org/","title":"Connect to Zukma EVM"},{"location":"home/quick-start/#zukma-dashboard","text":"Once connected with Zukma's Substrate and EVM side, you are all set to utilize the Zukma Dashboard The Zukma Dashboard is the one-stop-shop to utilize Zukma's unique features. Keep in mind that the dashboard will grow and expand to continue to provide utiliy. Zukma Dashboard Functionalities you can already access are: Claim: To claim your ZEP coins - YouTube Walkthrough Transfer: To bridge your ZEP from the Substrate to the EVM side and vice versa - YouTube Walkthrough","title":"Zukma Dashboard"},{"location":"home/quick-start/#join-the-zukma-community","text":"Connect with an outstanding and helpful community whenever you feel the need to ask questions, discuss topics or simply hang out with like-minded DeFi enthusiasts. \u2013 LinkedIn \u2013 Telegram \u2013 YouTube \u2013 Twitter \u2013 Github Hint Check out our forum as well: Forum This is especailly useful for on-chain governance and proposals.","title":"Join the Zukma Community"},{"location":"troubleshooting/01-substrate-error-codes/","text":"ERRORS AND HOW TO RESOLVE THEM Errors in Substrate-based chains are usually accompanied by descriptive messages. The substrate explorer translates and displays those descriptive messages to help users understand what might have caused the error or inform the user about performed on-chain actions. If this page does not answer your question, try to reach out to the community and us on Discord for more information on troubleshooting your issue. How to get detailed error descriptions Here's how to find out the detailed error description with the help of the substrate explorer. A typical failed transactions looks something like this: The image displays only the error name as defined in the code, not its error message. Despite this error being rather self-explanatory, let's find its details. In the Explorer Tab , find the block in which this failure occurred. Then, expand the system.ExtrinsicFailed frame: Notice how the details field contains a human-readable description of the error. Most errors will have this, if looked up this way. If you cannot look up the error this way, or there is no message in the details field, consult the table below. Common Errors The table below lists the most commonly encountered errors and ways to resolve them. :root { --bg-table-stripe: #f6f6f5; --b-table: #e3e3e2; --caption: #EC4880; } table { background-color: transparent; border-collapse:collapse; font-family: Arial, Helvetica, sans-serif } th { text-align:left } .dcf-txt-center { text-align: center!important } .dcf-txt-left { text-align: left!important } .dcf-txt-right { text-align: right!important } .dcf-table caption { color: var(--caption); font-size: 1.13em; font-weight: 700; padding-bottom: .56rem } .dcf-table thead { font-size: .84em } .dcf-table tbody { border-bottom: 1px solid var(--b-table); border-top: 1px solid var(--b-table); font-size: .84em } .dcf-table tfoot { font-size: .84em } .dcf-table td, .dcf-table th { padding-right: 1.78em } .dcf-table-bordered, .dcf-table-bordered td, .dcf-table-bordered th { border: 1px solid var(--b-table) } .dcf-table-bordered td, .dcf-table-bordered th, .dcf-table-striped td, .dcf-table-striped th { padding-left: 1em; padding-right: 1em } .dcf-table-bordered tr:not(:last-child), .dcf-table-striped tr:not(:last-child) { border-bottom: 1px solid var(--b-table) } .dcf-table-striped tbody tr:nth-of-type(2n) { background-color: var(--bg-table-stripe) } .dcf-table thead td, .dcf-table thead th { padding-bottom: .75em; vertical-align: bottom; background-color: #EC4880 } th[scope=row] { background-color: #D9D8DA; } .dcf-table tbody td, .dcf-table tbody th, .dcf-table tfoot td, .dcf-table tfoot th { padding-top: .75em; vertical-align: top } .dcf-table tbody td, .dcf-table tbody th { padding-bottom: .75em } .dcf-table-bordered thead th { padding-top: 1.33em } .dcf-wrapper-table-scroll { overflow-x: auto; -webkit-overflow-scrolling: touch; left: 50%; margin-left: -50vw; margin-right: -50vw; padding-bottom: 1em; position: relative; right: 50%; width: 100vw } @media only screen and (max-width:42.09em) { .dcf-table-responsive thead { clip: rect(0 0 0 0); -webkit-clip-path: inset(50%); clip-path: inset(50%); height: 1px; overflow: hidden; position: absolute; width: 1px; white-space: nowrap } .dcf-table-responsive tr { display: block } .dcf-table-responsive td { -webkit-column-gap: 3.16vw; -moz-column-gap: 3.16vw; column-gap: 3.16vw; display: grid; grid-template-columns: 1fr 2fr; text-align: left!important } .dcf-table-responsive.dcf-table-bordered, .dcf-table-responsive.dcf-table-bordered thead th { border-width: 0 } .dcf-table-responsive.dcf-table-bordered tbody td { border-top-width: 0 } .dcf-table-responsive:not(.dcf-table-bordered) tbody tr { padding-bottom: .75em } .dcf-table-responsive:not(.dcf-table-bordered) tbody td { padding-bottom: 0 } .dcf-table-responsive:not(.dcf-table-bordered):not(.dcf-table-striped) tbody td { padding-right: 0 } .dcf-table-responsive.dcf-table-bordered tbody tr:last-child td:last-child { border-bottom-width: 0 } .dcf-table-responsive tbody td:before { content: attr(data-label); float: left; font-weight: 700; padding-right: 1.78em } } .dcf-overflow-x-auto { overflow-x: auto!important; -webkit-overflow-scrolling: touch } Error Description Solution BadOrigin You are not allowed to do this operation, e.g. trying to create a council motion with a non-council account. Either switch to an account that has the necessary permissions, or check if the operation you're trying to execute is permitted at all (e.g. calling system.setCode to do a runtime upgrade directly, without voting). BadProof The transaction's signature seems invalid. It's possible that the node you're connected to is following an obsolete fork - trying again after it catches up usually resolves the issue. To check for bigger problems, inspect the last finalized and current best block of the node you're connected to and compare the values to chain stats exposed by other nodes - are they in sync? If not, try connecting to a different node. Future Transaction nonce too high, i.e. it's \"from the future\". Reduce the nonce to +1 of current nonce. Check current nonce by inspecting the address you're using to send the transaction. Stale Transaction nonce too low. Increase the nonce to +1 of current nonce. Check current nonce by inspecting the address you're using to send the transaction. ExhaustsResources There aren't enough resources left in the current block to submit this transaction. Try again in the next block. Payment Unable to pay for TX fee. You might not have enough free balance to cover the fee this transaction would incur. Temporarily banned The transaction is temporarily banned. The tx is already in pool. Either try on a different node, or wait to see if the initial transaction goes through. Error Table The below table is a reference to the errors that exists in Kusari and Zukma. It is generated from the runtime's metadata. :root { --bg-table-stripe: #f6f6f5; --b-table: #e3e3e2; --caption: #EC4880; } table { background-color: transparent; border-collapse:collapse; font-family: Arial, Helvetica, sans-serif } th { text-align:left } .dcf-txt-center { text-align: center!important } .dcf-txt-left { text-align: left!important } .dcf-txt-right { text-align: right!important } .dcf-table caption { color: var(--caption); font-size: 1.13em; font-weight: 700; padding-bottom: .56rem } .dcf-table thead { font-size: .84em; } .dcf-table tbody { border-bottom: 1px solid var(--b-table); border-top: 1px solid var(--b-table); font-size: .84em } .dcf-table tfoot { font-size: .84em } .dcf-table td, .dcf-table th { padding-right: 1.78em } .dcf-table-bordered, .dcf-table-bordered td, .dcf-table-bordered th { border: 1px solid var(--b-table) } .dcf-table-bordered td, .dcf-table-bordered th, .dcf-table-striped td, .dcf-table-striped th { padding-left: 1em; padding-right: 1em } .dcf-table-bordered tr:not(:last-child), .dcf-table-striped tr:not(:last-child) { border-bottom: 1px solid var(--b-table) } .dcf-table-striped tbody tr:nth-of-type(2n) { background-color: var(--bg-table-stripe) } .dcf-table thead td, .dcf-table thead th { padding-bottom: .75em; vertical-align: bottom; background-color: #EC4880 } th[scope=row] { background-color: #D9D8DA; } .dcf-table tbody td, .dcf-table tbody th, .dcf-table tfoot td, .dcf-table tfoot th { padding-top: .75em; vertical-align: top } .dcf-table tbody td, .dcf-table tbody th { padding-bottom: .75em } .dcf-table-bordered thead th { padding-top: 1.33em } .dcf-wrapper-table-scroll { overflow-x: auto; -webkit-overflow-scrolling: touch; left: 50%; margin-left: -50vw; margin-right: -50vw; padding-bottom: 1em; position: relative; right: 50%; width: 100vw } @media only screen and (max-width:42.09em) { .dcf-table-responsive thead { clip: rect(0 0 0 0); -webkit-clip-path: inset(50%); clip-path: inset(50%); height: 1px; overflow: hidden; position: absolute; width: 1px; white-space: nowrap } .dcf-table-responsive tr { display: block } .dcf-table-responsive td { -webkit-column-gap: 3.16vw; -moz-column-gap: 3.16vw; column-gap: 3.16vw; display: grid; grid-template-columns: 1fr 2fr; text-align: left!important } .dcf-table-responsive.dcf-table-bordered, .dcf-table-responsive.dcf-table-bordered thead th { border-width: 0 } .dcf-table-responsive.dcf-table-bordered tbody td { border-top-width: 0 } .dcf-table-responsive:not(.dcf-table-bordered) tbody tr { padding-bottom: .75em } .dcf-table-responsive:not(.dcf-table-bordered) tbody td { padding-bottom: 0 } .dcf-table-responsive:not(.dcf-table-bordered):not(.dcf-table-striped) tbody td { padding-right: 0 } .dcf-table-responsive.dcf-table-bordered tbody tr:last-child td:last-child { border-bottom-width: 0 } .dcf-table-responsive tbody td:before { content: attr(data-label); float: left; font-weight: 700; padding-right: 1.78em } } .dcf-overflow-x-auto { overflow-x: auto!important; -webkit-overflow-scrolling: touch } Pallet Error Documentation System (0) InvalidSpecName (0) The name of specification does not match between the current runtime and the new runtime. SpecVersionNeedsToIncrease (1) The specification version is not allowed to decrease between the current runtime and the new runtime. FailedToExtractRuntimeVersion (2) Failed to extract the runtime version from the new runtime. Either calling Core_version or decoding RuntimeVersion failed. NonDefaultComposite (3) Suicide called when the account has non-default composite data. NonZeroRefCount (4) There is a non-zero reference count preventing the account from being purged. Scheduler (1) FailedToSchedule (0) Failed to schedule a call NotFound (1) Cannot find the scheduled call. TargetBlockNumberInPast (2) Given target block number is in the past. RescheduleNoChange (3) Reschedule failed because it does not change scheduled time. Balances (5) VestingBalance (0) Vesting balance too high to send value LiquidityRestrictions (1) Account liquidity restrictions prevent withdrawal Overflow (2) Got an overflow after adding InsufficientBalance (3) Balance too low to send value ExistentialDeposit (4) Value too low to create account due to existential deposit KeepAlive (5) Transfer/payment would kill account ExistingVestingSchedule (6) A vesting schedule already exists for this account DeadAccount (7) Beneficiary account must pre-exist Authorship (6) InvalidUncleParent (0) The uncle parent not in the chain. UnclesAlreadySet (1) Uncles already set in the block. TooManyUncles (2) Too many uncles. GenesisUncle (3) The uncle is genesis. TooHighUncle (4) The uncle is too high in chain. UncleAlreadyIncluded (5) The uncle is already included. OldUncle (6) The uncle isn't recent enough to be included. Staking (7) NotController (0) Not a controller account. NotStash (1) Not a stash account. AlreadyBonded (2) Stash is already bonded. AlreadyPaired (3) Controller is already paired. EmptyTargets (4) Targets cannot be empty. DuplicateIndex (5) Duplicate index. InvalidSlashIndex (6) Slash record index out of bounds. InsufficientValue (7) Can not bond with value less than minimum balance. NoMoreChunks (8) Can not schedule more unlock chunks. NoUnlockChunk (9) Can not rebond without unlocking chunks. FundedTarget (10) Attempting to target a stash that still has funds. InvalidEraToReward (11) Invalid era to reward. InvalidNumberOfNominations (12) Invalid number of nominations. NotSortedAndUnique (13) Items are not sorted and unique. AlreadyClaimed (14) Rewards for this era have already been claimed for this validator. OffchainElectionEarlySubmission (15) The submitted result is received out of the open window. OffchainElectionWeakSubmission (16) The submitted result is not as good as the one stored on chain. SnapshotUnavailable (17) The snapshot data of the current window is missing. OffchainElectionBogusWinnerCount (18) Incorrect number of winners were presented. OffchainElectionBogusWinner (19) One of the submitted winners is not an active candidate on chain (index is out of range in snapshot). OffchainElectionBogusCompact (20) Error while building the assignment type from the compact. This can happen if an index is invalid, or if the weights overflow. OffchainElectionBogusNominator (21) One of the submitted nominators is not an active nominator on chain. OffchainElectionBogusNomination (22) One of the submitted nominators has an edge to which they have not voted on chain. OffchainElectionSlashedNomination (23) One of the submitted nominators has an edge which is submitted before the last non-zero slash of the target. OffchainElectionBogusSelfVote (24) A self vote must only be originated from a validator to ONLY themselves. OffchainElectionBogusEdge (25) The submitted result has unknown edges that are not among the presented winners. OffchainElectionBogusScore (26) The claimed score does not match with the one computed from the data. OffchainElectionBogusElectionSize (27) The election size is invalid. CallNotAllowed (28) The call is not allowed at the given time due to restrictions of election period. IncorrectHistoryDepth (29) Incorrect previous history depth input provided. IncorrectSlashingSpans (30) Incorrect number of slashing spans provided. Session (9) InvalidProof (0) Invalid ownership proof. NoAssociatedValidatorId (1) No associated validator ID for account. DuplicatedKey (2) Registered duplicate key. NoKeys (3) No keys are associated with this account. Grandpa (11) PauseFailed (0) Attempt to signal GRANDPA pause when the authority set isn't live (either paused or already pending pause). ResumeFailed (1) Attempt to signal GRANDPA resume when the authority set isn't paused (either live or already pending resume). ChangePending (2) Attempt to signal GRANDPA change with one already pending. TooSoon (3) Cannot signal forced change so soon after last. InvalidKeyOwnershipProof (4) A key ownership proof provided as part of an equivocation report is invalid. InvalidEquivocationProof (5) An equivocation proof provided as part of an equivocation report is invalid. DuplicateOffenceReport (6) A given equivocation report is valid but already previously reported. ImOnline (12) InvalidKey (0) Non existent public key. DuplicatedHeartbeat (1) Duplicated heartbeat. Democracy (14) ValueLow (0) Value too low ProposalMissing (1) Proposal does not exist BadIndex (2) Unknown index AlreadyCanceled (3) Cannot cancel the same proposal twice DuplicateProposal (4) Proposal already made ProposalBlacklisted (5) Proposal still blacklisted NotSimpleMajority (6) Next external proposal not simple majority InvalidHash (7) Invalid hash NoProposal (8) No external proposal AlreadyVetoed (9) Identity may not veto a proposal twice NotDelegated (10) Not delegated DuplicatePreimage (11) Preimage already noted NotImminent (12) Not imminent TooEarly (13) Too early Imminent (14) Imminent PreimageMissing (15) Preimage not found ReferendumInvalid (16) Vote given for invalid referendum PreimageInvalid (17) Invalid preimage NoneWaiting (18) No proposals waiting NotLocked (19) The target account does not have a lock. NotExpired (20) The lock on the account to be unlocked has not yet expired. NotVoter (21) The given account did not vote on the referendum. NoPermission (22) The actor has no permission to conduct the action. AlreadyDelegating (23) The account is already delegating. Overflow (24) An unexpected integer overflow occurred. Underflow (25) An unexpected integer underflow occurred. InsufficientFunds (26) Too high a balance was provided that the account cannot afford. NotDelegating (27) The account is not currently delegating. VotesExist (28) The account currently has votes attached to it and the operation cannot succeed until these are removed, either through unvote or reap_vote. InstantNotAllowed (29) The instant referendum origin is currently disallowed. Nonsense (30) Delegation to oneself makes no sense. WrongUpperBound (31) Invalid upper bound. MaxVotesReached (32) Maximum number of votes reached. InvalidWitness (33) The provided witness data is wrong. TooManyProposals (34) Maximum number of proposals reached. Council (15) NotMember (0) Account is not a member DuplicateProposal (1) Duplicate proposals not allowed ProposalMissing (2) Proposal must exist WrongIndex (3) Mismatched index DuplicateVote (4) Duplicate vote ignored AlreadyInitialized (5) Members are already initialized! TooEarly (6) The close call was made too early, before the end of the voting. TooManyProposals (7) There can only be a maximum of MaxProposals active proposals. WrongProposalWeight (8) The given weight bound for the proposal was too low. WrongProposalLength (9) The given length bound for the proposal was too low. TechnicalCommittee (16) NotMember (0) Account is not a member DuplicateProposal (1) Duplicate proposals not allowed ProposalMissing (2) Proposal must exist WrongIndex (3) Mismatched index DuplicateVote (4) Duplicate vote ignored AlreadyInitialized (5) Members are already initialized! TooEarly (6) The close call was made too early, before the end of the voting. TooManyProposals (7) There can only be a maximum of MaxProposals active proposals. WrongProposalWeight (8) The given weight bound for the proposal was too low. WrongProposalLength (9) The given length bound for the proposal was too low. ElectionsPhragmen (17) UnableToVote (0) Cannot vote when no candidates or members exist. NoVotes (1) Must vote for at least one candidate. TooManyVotes (2) Cannot vote more than candidates. MaximumVotesExceeded (3) Cannot vote more than maximum allowed. LowBalance (4) Cannot vote with stake less than minimum balance. UnableToPayBond (5) Voter can not pay voting bond. MustBeVoter (6) Must be a voter. ReportSelf (7) Cannot report self. DuplicatedCandidate (8) Duplicated candidate submission. MemberSubmit (9) Member cannot re-submit candidacy. RunnerSubmit (10) Runner cannot re-submit candidacy. InsufficientCandidateFunds (11) Candidate does not have enough funds. NotMember (12) Not a member. InvalidCandidateCount (13) The provided count of number of candidates is incorrect. InvalidVoteCount (14) The provided count of number of votes is incorrect. InvalidRenouncing (15) The renouncing origin presented a wrong Renouncing parameter. InvalidReplacement (16) Prediction regarding replacement after member removal is wrong. Treasury (19) InsufficientProposersBalance (0) Proposer's balance is too low. InvalidIndex (1) No proposal or bounty at that index. ReasonTooBig (2) The reason given is just too big. AlreadyKnown (3) The tip was already found/started. UnknownTip (4) The tip hash is unknown. NotFinder (5) The account attempting to retract the tip is not the finder of the tip. StillOpen (6) The tip cannot be claimed/closed because there are not enough tippers yet. Premature (7) The tip cannot be claimed/closed because it's still in the countdown period. UnexpectedStatus (8) The bounty status is unexpected. RequireCurator (9) Require bounty curator. InvalidValue (10) Invalid bounty value. InvalidFee (11) Invalid bounty fee. PendingPayout (12) A bounty payout is pending. To cancel the bounty, you must unassign and slash the curator. Claims (24) InvalidEthereumSignature (0) Invalid Ethereum signature. SignerHasNoClaim (1) Ethereum address has no claim. SenderHasNoClaim (2) Account ID sending tx has no claim. PotUnderflow (3) There's not enough in the pot to pay out some unvested amount. Generally implies a logic error. InvalidStatement (4) A needed statement was not included. VestedBalanceExists (5) The account already has a vested balance. Vesting (25) NotVesting (0) The account given is not vesting. ExistingVestingSchedule (1) An existing vesting schedule already exists for this account that cannot be clobbered. AmountLow (2) Amount being transferred is too low to create a vesting schedule. Identity (28) TooManySubAccounts (0) Too many subs-accounts. NotFound (1) Account isn't found. NotNamed (2) Account isn't named. EmptyIndex (3) Empty index. FeeChanged (4) Fee is changed. NoIdentity (5) No identity found. StickyJudgement (6) Sticky judgement. JudgementGiven (7) Judgement given. InvalidJudgement (8) Invalid judgement. InvalidIndex (9) The index is invalid. InvalidTarget (10) The target is invalid. TooManyFields (11) Too many additional fields. TooManyRegistrars (12) Maximum amount of registrars reached. Cannot add any more. AlreadyClaimed (13) Account ID is already named. NotSub (14) Sender is not a sub-account. NotOwned (15) Sub-account isn't owned by sender. Proxy (29) TooMany (0) There are too many proxies registered or too many announcements pending. NotFound (1) Proxy registration not found. NotProxy (2) Sender is not a proxy of the account to be proxied. Unproxyable (3) A call which is incompatible with the proxy type's filter was attempted. Duplicate (4) Account is already a proxy. NoPermission (5) Call may not be made by proxy because it may escalate its privileges. Unannounced (6) Announcement, if made at all, was made too recently. Multisig (30) MinimumThreshold (0) Threshold must be 2 or greater. AlreadyApproved (1) Call is already approved by this signatory. NoApprovalsNeeded (2) Call doesn't need any (more) approvals. TooFewSignatories (3) There are too few signatories in the list. TooManySignatories (4) There are too many signatories in the list. SignatoriesOutOfOrder (5) The signatories were provided out of order; they should be ordered. SenderInSignatories (6) The sender was contained in the other signatories; it shouldn't be. NotFound (7) Multisig operation not found when attempting to cancel. NotOwner (8) Only the account that originally created the multisig is able to cancel it. NoTimepoint (9) No timepoint was given, yet the multisig operation is already underway. WrongTimepoint (10) A different timepoint was given to the multisig operation that is underway. UnexpectedTimepoint (11) A timepoint was given, yet no multisig operation is underway. WeightTooLow (12) The maximum weight information provided was too low. AlreadyStored (13) The data to be stored is already stored. Written by Zukma Team","title":"Resolve Errors"},{"location":"troubleshooting/01-substrate-error-codes/#errors-and-how-to-resolve-them","text":"Errors in Substrate-based chains are usually accompanied by descriptive messages. The substrate explorer translates and displays those descriptive messages to help users understand what might have caused the error or inform the user about performed on-chain actions. If this page does not answer your question, try to reach out to the community and us on Discord for more information on troubleshooting your issue.","title":"ERRORS AND HOW TO RESOLVE THEM"},{"location":"troubleshooting/01-substrate-error-codes/#how-to-get-detailed-error-descriptions","text":"Here's how to find out the detailed error description with the help of the substrate explorer. A typical failed transactions looks something like this: The image displays only the error name as defined in the code, not its error message. Despite this error being rather self-explanatory, let's find its details. In the Explorer Tab , find the block in which this failure occurred. Then, expand the system.ExtrinsicFailed frame: Notice how the details field contains a human-readable description of the error. Most errors will have this, if looked up this way. If you cannot look up the error this way, or there is no message in the details field, consult the table below.","title":"How to get detailed error descriptions"},{"location":"troubleshooting/01-substrate-error-codes/#common-errors","text":"The table below lists the most commonly encountered errors and ways to resolve them. :root { --bg-table-stripe: #f6f6f5; --b-table: #e3e3e2; --caption: #EC4880; } table { background-color: transparent; border-collapse:collapse; font-family: Arial, Helvetica, sans-serif } th { text-align:left } .dcf-txt-center { text-align: center!important } .dcf-txt-left { text-align: left!important } .dcf-txt-right { text-align: right!important } .dcf-table caption { color: var(--caption); font-size: 1.13em; font-weight: 700; padding-bottom: .56rem } .dcf-table thead { font-size: .84em } .dcf-table tbody { border-bottom: 1px solid var(--b-table); border-top: 1px solid var(--b-table); font-size: .84em } .dcf-table tfoot { font-size: .84em } .dcf-table td, .dcf-table th { padding-right: 1.78em } .dcf-table-bordered, .dcf-table-bordered td, .dcf-table-bordered th { border: 1px solid var(--b-table) } .dcf-table-bordered td, .dcf-table-bordered th, .dcf-table-striped td, .dcf-table-striped th { padding-left: 1em; padding-right: 1em } .dcf-table-bordered tr:not(:last-child), .dcf-table-striped tr:not(:last-child) { border-bottom: 1px solid var(--b-table) } .dcf-table-striped tbody tr:nth-of-type(2n) { background-color: var(--bg-table-stripe) } .dcf-table thead td, .dcf-table thead th { padding-bottom: .75em; vertical-align: bottom; background-color: #EC4880 } th[scope=row] { background-color: #D9D8DA; } .dcf-table tbody td, .dcf-table tbody th, .dcf-table tfoot td, .dcf-table tfoot th { padding-top: .75em; vertical-align: top } .dcf-table tbody td, .dcf-table tbody th { padding-bottom: .75em } .dcf-table-bordered thead th { padding-top: 1.33em } .dcf-wrapper-table-scroll { overflow-x: auto; -webkit-overflow-scrolling: touch; left: 50%; margin-left: -50vw; margin-right: -50vw; padding-bottom: 1em; position: relative; right: 50%; width: 100vw } @media only screen and (max-width:42.09em) { .dcf-table-responsive thead { clip: rect(0 0 0 0); -webkit-clip-path: inset(50%); clip-path: inset(50%); height: 1px; overflow: hidden; position: absolute; width: 1px; white-space: nowrap } .dcf-table-responsive tr { display: block } .dcf-table-responsive td { -webkit-column-gap: 3.16vw; -moz-column-gap: 3.16vw; column-gap: 3.16vw; display: grid; grid-template-columns: 1fr 2fr; text-align: left!important } .dcf-table-responsive.dcf-table-bordered, .dcf-table-responsive.dcf-table-bordered thead th { border-width: 0 } .dcf-table-responsive.dcf-table-bordered tbody td { border-top-width: 0 } .dcf-table-responsive:not(.dcf-table-bordered) tbody tr { padding-bottom: .75em } .dcf-table-responsive:not(.dcf-table-bordered) tbody td { padding-bottom: 0 } .dcf-table-responsive:not(.dcf-table-bordered):not(.dcf-table-striped) tbody td { padding-right: 0 } .dcf-table-responsive.dcf-table-bordered tbody tr:last-child td:last-child { border-bottom-width: 0 } .dcf-table-responsive tbody td:before { content: attr(data-label); float: left; font-weight: 700; padding-right: 1.78em } } .dcf-overflow-x-auto { overflow-x: auto!important; -webkit-overflow-scrolling: touch } Error Description Solution BadOrigin You are not allowed to do this operation, e.g. trying to create a council motion with a non-council account. Either switch to an account that has the necessary permissions, or check if the operation you're trying to execute is permitted at all (e.g. calling system.setCode to do a runtime upgrade directly, without voting). BadProof The transaction's signature seems invalid. It's possible that the node you're connected to is following an obsolete fork - trying again after it catches up usually resolves the issue. To check for bigger problems, inspect the last finalized and current best block of the node you're connected to and compare the values to chain stats exposed by other nodes - are they in sync? If not, try connecting to a different node. Future Transaction nonce too high, i.e. it's \"from the future\". Reduce the nonce to +1 of current nonce. Check current nonce by inspecting the address you're using to send the transaction. Stale Transaction nonce too low. Increase the nonce to +1 of current nonce. Check current nonce by inspecting the address you're using to send the transaction. ExhaustsResources There aren't enough resources left in the current block to submit this transaction. Try again in the next block. Payment Unable to pay for TX fee. You might not have enough free balance to cover the fee this transaction would incur. Temporarily banned The transaction is temporarily banned. The tx is already in pool. Either try on a different node, or wait to see if the initial transaction goes through.","title":"Common Errors"},{"location":"troubleshooting/01-substrate-error-codes/#error-table","text":"The below table is a reference to the errors that exists in Kusari and Zukma. It is generated from the runtime's metadata. :root { --bg-table-stripe: #f6f6f5; --b-table: #e3e3e2; --caption: #EC4880; } table { background-color: transparent; border-collapse:collapse; font-family: Arial, Helvetica, sans-serif } th { text-align:left } .dcf-txt-center { text-align: center!important } .dcf-txt-left { text-align: left!important } .dcf-txt-right { text-align: right!important } .dcf-table caption { color: var(--caption); font-size: 1.13em; font-weight: 700; padding-bottom: .56rem } .dcf-table thead { font-size: .84em; } .dcf-table tbody { border-bottom: 1px solid var(--b-table); border-top: 1px solid var(--b-table); font-size: .84em } .dcf-table tfoot { font-size: .84em } .dcf-table td, .dcf-table th { padding-right: 1.78em } .dcf-table-bordered, .dcf-table-bordered td, .dcf-table-bordered th { border: 1px solid var(--b-table) } .dcf-table-bordered td, .dcf-table-bordered th, .dcf-table-striped td, .dcf-table-striped th { padding-left: 1em; padding-right: 1em } .dcf-table-bordered tr:not(:last-child), .dcf-table-striped tr:not(:last-child) { border-bottom: 1px solid var(--b-table) } .dcf-table-striped tbody tr:nth-of-type(2n) { background-color: var(--bg-table-stripe) } .dcf-table thead td, .dcf-table thead th { padding-bottom: .75em; vertical-align: bottom; background-color: #EC4880 } th[scope=row] { background-color: #D9D8DA; } .dcf-table tbody td, .dcf-table tbody th, .dcf-table tfoot td, .dcf-table tfoot th { padding-top: .75em; vertical-align: top } .dcf-table tbody td, .dcf-table tbody th { padding-bottom: .75em } .dcf-table-bordered thead th { padding-top: 1.33em } .dcf-wrapper-table-scroll { overflow-x: auto; -webkit-overflow-scrolling: touch; left: 50%; margin-left: -50vw; margin-right: -50vw; padding-bottom: 1em; position: relative; right: 50%; width: 100vw } @media only screen and (max-width:42.09em) { .dcf-table-responsive thead { clip: rect(0 0 0 0); -webkit-clip-path: inset(50%); clip-path: inset(50%); height: 1px; overflow: hidden; position: absolute; width: 1px; white-space: nowrap } .dcf-table-responsive tr { display: block } .dcf-table-responsive td { -webkit-column-gap: 3.16vw; -moz-column-gap: 3.16vw; column-gap: 3.16vw; display: grid; grid-template-columns: 1fr 2fr; text-align: left!important } .dcf-table-responsive.dcf-table-bordered, .dcf-table-responsive.dcf-table-bordered thead th { border-width: 0 } .dcf-table-responsive.dcf-table-bordered tbody td { border-top-width: 0 } .dcf-table-responsive:not(.dcf-table-bordered) tbody tr { padding-bottom: .75em } .dcf-table-responsive:not(.dcf-table-bordered) tbody td { padding-bottom: 0 } .dcf-table-responsive:not(.dcf-table-bordered):not(.dcf-table-striped) tbody td { padding-right: 0 } .dcf-table-responsive.dcf-table-bordered tbody tr:last-child td:last-child { border-bottom-width: 0 } .dcf-table-responsive tbody td:before { content: attr(data-label); float: left; font-weight: 700; padding-right: 1.78em } } .dcf-overflow-x-auto { overflow-x: auto!important; -webkit-overflow-scrolling: touch } Pallet Error Documentation System (0) InvalidSpecName (0) The name of specification does not match between the current runtime and the new runtime. SpecVersionNeedsToIncrease (1) The specification version is not allowed to decrease between the current runtime and the new runtime. FailedToExtractRuntimeVersion (2) Failed to extract the runtime version from the new runtime. Either calling Core_version or decoding RuntimeVersion failed. NonDefaultComposite (3) Suicide called when the account has non-default composite data. NonZeroRefCount (4) There is a non-zero reference count preventing the account from being purged. Scheduler (1) FailedToSchedule (0) Failed to schedule a call NotFound (1) Cannot find the scheduled call. TargetBlockNumberInPast (2) Given target block number is in the past. RescheduleNoChange (3) Reschedule failed because it does not change scheduled time. Balances (5) VestingBalance (0) Vesting balance too high to send value LiquidityRestrictions (1) Account liquidity restrictions prevent withdrawal Overflow (2) Got an overflow after adding InsufficientBalance (3) Balance too low to send value ExistentialDeposit (4) Value too low to create account due to existential deposit KeepAlive (5) Transfer/payment would kill account ExistingVestingSchedule (6) A vesting schedule already exists for this account DeadAccount (7) Beneficiary account must pre-exist Authorship (6) InvalidUncleParent (0) The uncle parent not in the chain. UnclesAlreadySet (1) Uncles already set in the block. TooManyUncles (2) Too many uncles. GenesisUncle (3) The uncle is genesis. TooHighUncle (4) The uncle is too high in chain. UncleAlreadyIncluded (5) The uncle is already included. OldUncle (6) The uncle isn't recent enough to be included. Staking (7) NotController (0) Not a controller account. NotStash (1) Not a stash account. AlreadyBonded (2) Stash is already bonded. AlreadyPaired (3) Controller is already paired. EmptyTargets (4) Targets cannot be empty. DuplicateIndex (5) Duplicate index. InvalidSlashIndex (6) Slash record index out of bounds. InsufficientValue (7) Can not bond with value less than minimum balance. NoMoreChunks (8) Can not schedule more unlock chunks. NoUnlockChunk (9) Can not rebond without unlocking chunks. FundedTarget (10) Attempting to target a stash that still has funds. InvalidEraToReward (11) Invalid era to reward. InvalidNumberOfNominations (12) Invalid number of nominations. NotSortedAndUnique (13) Items are not sorted and unique. AlreadyClaimed (14) Rewards for this era have already been claimed for this validator. OffchainElectionEarlySubmission (15) The submitted result is received out of the open window. OffchainElectionWeakSubmission (16) The submitted result is not as good as the one stored on chain. SnapshotUnavailable (17) The snapshot data of the current window is missing. OffchainElectionBogusWinnerCount (18) Incorrect number of winners were presented. OffchainElectionBogusWinner (19) One of the submitted winners is not an active candidate on chain (index is out of range in snapshot). OffchainElectionBogusCompact (20) Error while building the assignment type from the compact. This can happen if an index is invalid, or if the weights overflow. OffchainElectionBogusNominator (21) One of the submitted nominators is not an active nominator on chain. OffchainElectionBogusNomination (22) One of the submitted nominators has an edge to which they have not voted on chain. OffchainElectionSlashedNomination (23) One of the submitted nominators has an edge which is submitted before the last non-zero slash of the target. OffchainElectionBogusSelfVote (24) A self vote must only be originated from a validator to ONLY themselves. OffchainElectionBogusEdge (25) The submitted result has unknown edges that are not among the presented winners. OffchainElectionBogusScore (26) The claimed score does not match with the one computed from the data. OffchainElectionBogusElectionSize (27) The election size is invalid. CallNotAllowed (28) The call is not allowed at the given time due to restrictions of election period. IncorrectHistoryDepth (29) Incorrect previous history depth input provided. IncorrectSlashingSpans (30) Incorrect number of slashing spans provided. Session (9) InvalidProof (0) Invalid ownership proof. NoAssociatedValidatorId (1) No associated validator ID for account. DuplicatedKey (2) Registered duplicate key. NoKeys (3) No keys are associated with this account. Grandpa (11) PauseFailed (0) Attempt to signal GRANDPA pause when the authority set isn't live (either paused or already pending pause). ResumeFailed (1) Attempt to signal GRANDPA resume when the authority set isn't paused (either live or already pending resume). ChangePending (2) Attempt to signal GRANDPA change with one already pending. TooSoon (3) Cannot signal forced change so soon after last. InvalidKeyOwnershipProof (4) A key ownership proof provided as part of an equivocation report is invalid. InvalidEquivocationProof (5) An equivocation proof provided as part of an equivocation report is invalid. DuplicateOffenceReport (6) A given equivocation report is valid but already previously reported. ImOnline (12) InvalidKey (0) Non existent public key. DuplicatedHeartbeat (1) Duplicated heartbeat. Democracy (14) ValueLow (0) Value too low ProposalMissing (1) Proposal does not exist BadIndex (2) Unknown index AlreadyCanceled (3) Cannot cancel the same proposal twice DuplicateProposal (4) Proposal already made ProposalBlacklisted (5) Proposal still blacklisted NotSimpleMajority (6) Next external proposal not simple majority InvalidHash (7) Invalid hash NoProposal (8) No external proposal AlreadyVetoed (9) Identity may not veto a proposal twice NotDelegated (10) Not delegated DuplicatePreimage (11) Preimage already noted NotImminent (12) Not imminent TooEarly (13) Too early Imminent (14) Imminent PreimageMissing (15) Preimage not found ReferendumInvalid (16) Vote given for invalid referendum PreimageInvalid (17) Invalid preimage NoneWaiting (18) No proposals waiting NotLocked (19) The target account does not have a lock. NotExpired (20) The lock on the account to be unlocked has not yet expired. NotVoter (21) The given account did not vote on the referendum. NoPermission (22) The actor has no permission to conduct the action. AlreadyDelegating (23) The account is already delegating. Overflow (24) An unexpected integer overflow occurred. Underflow (25) An unexpected integer underflow occurred. InsufficientFunds (26) Too high a balance was provided that the account cannot afford. NotDelegating (27) The account is not currently delegating. VotesExist (28) The account currently has votes attached to it and the operation cannot succeed until these are removed, either through unvote or reap_vote. InstantNotAllowed (29) The instant referendum origin is currently disallowed. Nonsense (30) Delegation to oneself makes no sense. WrongUpperBound (31) Invalid upper bound. MaxVotesReached (32) Maximum number of votes reached. InvalidWitness (33) The provided witness data is wrong. TooManyProposals (34) Maximum number of proposals reached. Council (15) NotMember (0) Account is not a member DuplicateProposal (1) Duplicate proposals not allowed ProposalMissing (2) Proposal must exist WrongIndex (3) Mismatched index DuplicateVote (4) Duplicate vote ignored AlreadyInitialized (5) Members are already initialized! TooEarly (6) The close call was made too early, before the end of the voting. TooManyProposals (7) There can only be a maximum of MaxProposals active proposals. WrongProposalWeight (8) The given weight bound for the proposal was too low. WrongProposalLength (9) The given length bound for the proposal was too low. TechnicalCommittee (16) NotMember (0) Account is not a member DuplicateProposal (1) Duplicate proposals not allowed ProposalMissing (2) Proposal must exist WrongIndex (3) Mismatched index DuplicateVote (4) Duplicate vote ignored AlreadyInitialized (5) Members are already initialized! TooEarly (6) The close call was made too early, before the end of the voting. TooManyProposals (7) There can only be a maximum of MaxProposals active proposals. WrongProposalWeight (8) The given weight bound for the proposal was too low. WrongProposalLength (9) The given length bound for the proposal was too low. ElectionsPhragmen (17) UnableToVote (0) Cannot vote when no candidates or members exist. NoVotes (1) Must vote for at least one candidate. TooManyVotes (2) Cannot vote more than candidates. MaximumVotesExceeded (3) Cannot vote more than maximum allowed. LowBalance (4) Cannot vote with stake less than minimum balance. UnableToPayBond (5) Voter can not pay voting bond. MustBeVoter (6) Must be a voter. ReportSelf (7) Cannot report self. DuplicatedCandidate (8) Duplicated candidate submission. MemberSubmit (9) Member cannot re-submit candidacy. RunnerSubmit (10) Runner cannot re-submit candidacy. InsufficientCandidateFunds (11) Candidate does not have enough funds. NotMember (12) Not a member. InvalidCandidateCount (13) The provided count of number of candidates is incorrect. InvalidVoteCount (14) The provided count of number of votes is incorrect. InvalidRenouncing (15) The renouncing origin presented a wrong Renouncing parameter. InvalidReplacement (16) Prediction regarding replacement after member removal is wrong. Treasury (19) InsufficientProposersBalance (0) Proposer's balance is too low. InvalidIndex (1) No proposal or bounty at that index. ReasonTooBig (2) The reason given is just too big. AlreadyKnown (3) The tip was already found/started. UnknownTip (4) The tip hash is unknown. NotFinder (5) The account attempting to retract the tip is not the finder of the tip. StillOpen (6) The tip cannot be claimed/closed because there are not enough tippers yet. Premature (7) The tip cannot be claimed/closed because it's still in the countdown period. UnexpectedStatus (8) The bounty status is unexpected. RequireCurator (9) Require bounty curator. InvalidValue (10) Invalid bounty value. InvalidFee (11) Invalid bounty fee. PendingPayout (12) A bounty payout is pending. To cancel the bounty, you must unassign and slash the curator. Claims (24) InvalidEthereumSignature (0) Invalid Ethereum signature. SignerHasNoClaim (1) Ethereum address has no claim. SenderHasNoClaim (2) Account ID sending tx has no claim. PotUnderflow (3) There's not enough in the pot to pay out some unvested amount. Generally implies a logic error. InvalidStatement (4) A needed statement was not included. VestedBalanceExists (5) The account already has a vested balance. Vesting (25) NotVesting (0) The account given is not vesting. ExistingVestingSchedule (1) An existing vesting schedule already exists for this account that cannot be clobbered. AmountLow (2) Amount being transferred is too low to create a vesting schedule. Identity (28) TooManySubAccounts (0) Too many subs-accounts. NotFound (1) Account isn't found. NotNamed (2) Account isn't named. EmptyIndex (3) Empty index. FeeChanged (4) Fee is changed. NoIdentity (5) No identity found. StickyJudgement (6) Sticky judgement. JudgementGiven (7) Judgement given. InvalidJudgement (8) Invalid judgement. InvalidIndex (9) The index is invalid. InvalidTarget (10) The target is invalid. TooManyFields (11) Too many additional fields. TooManyRegistrars (12) Maximum amount of registrars reached. Cannot add any more. AlreadyClaimed (13) Account ID is already named. NotSub (14) Sender is not a sub-account. NotOwned (15) Sub-account isn't owned by sender. Proxy (29) TooMany (0) There are too many proxies registered or too many announcements pending. NotFound (1) Proxy registration not found. NotProxy (2) Sender is not a proxy of the account to be proxied. Unproxyable (3) A call which is incompatible with the proxy type's filter was attempted. Duplicate (4) Account is already a proxy. NoPermission (5) Call may not be made by proxy because it may escalate its privileges. Unannounced (6) Announcement, if made at all, was made too recently. Multisig (30) MinimumThreshold (0) Threshold must be 2 or greater. AlreadyApproved (1) Call is already approved by this signatory. NoApprovalsNeeded (2) Call doesn't need any (more) approvals. TooFewSignatories (3) There are too few signatories in the list. TooManySignatories (4) There are too many signatories in the list. SignatoriesOutOfOrder (5) The signatories were provided out of order; they should be ordered. SenderInSignatories (6) The sender was contained in the other signatories; it shouldn't be. NotFound (7) Multisig operation not found when attempting to cancel. NotOwner (8) Only the account that originally created the multisig is able to cancel it. NoTimepoint (9) No timepoint was given, yet the multisig operation is already underway. WrongTimepoint (10) A different timepoint was given to the multisig operation that is underway. UnexpectedTimepoint (11) A timepoint was given, yet no multisig operation is underway. WeightTooLow (12) The maximum weight information provided was too low. AlreadyStored (13) The data to be stored is already stored. Written by Zukma Team","title":"Error Table"},{"location":"troubleshooting/02-Glossary/","text":"Glossary Active Nomination A validator (or validators) that a nominator has selected to nominate and is actively validating this era. The nominator is placing their stake behind this validator for this era and will potentially receive staking rewards in return for doing so. Authority An authority is a generic term for the role in a blockchain that can participate in the consensus mechanisms. In GRANDPA, the authorities vote on chains they consider final. In BABE, the authorities are block producers. Authority sets can be chosen to be mechanisms such as Polkadot's NPoS algorithm. BABE Blind Assignment of Block Extension (BABE) is Zukma Network block production mechanism. Block A collection of data, such as transactions, that together indicate a state transition of the blockchain. Block Explorer An application that allows a user to explore the different blocks on a blockchain. Blocks Nominations This indicates that a validator does not currently allow any more nominations. This is controlled by the validator. Bonding A process by which coins/tokens can be \"frozen\" in exchange for some other benefit. For example, staking is a form of bonding for which you receive rewards in exchange for securing the network. Bounty A mechanism which works in some sense as the reverse of a Treasury Proposal, allowing the Zukma Network/Zukma Council to indicate that there is a need to do some task for the Zukma Network and allowing users to receive ZEP in return for working on that task. Bridge A bridge is a piece of software that aims to increase interoperability between different blockchains. A bridge lets users convert their crypto assets into wrapped tokens of a destination chain. Capacity The maximum number of nominators signalling intent to nominate a validator (and thus could potentially actively nominate that validator in the next session). This maximum number will equal the number of nominators necessary to oversubscribe a validator. Any validator which is \"at capacity\" or higher may potentially be oversubscribed in the next session; a validator that is not at capacity cannot be oversubscribed unless more nominators select it before the next election. Commission Validators and nominators get paid from block production on the network, where validators can set a variable commission rate, which is initially subtracted from the total rewards that validator is entitled to (for that period), where the commission determines the rate of distribution for the remaining rewards set out for the nominators that are backing that validator. Community Queue The queue for proposals originating from individual accounts (i.e. not the Council) which are waiting to become referenda. Compare the External queue. Consensus The process of a group of entities to agree on a particular data value (such as the ordering and makeup of blocks on a blockchain). There are a variety of algorithms used for determining consensus. The consensus algorithm used by Zukma Network is BABE and GRANDPA. Curator A person, group, or other entity charged with judging and verifying the successful completion of a Bounty. Dapps A generic term for a decentralized application, that is, one that runs as part of a distributed network as opposed to being run on a specific system or set of systems. Epoch An epoch is a time duration in the BABE protocol that is broken into smaller time slots. Each slot has at least one slot leader who has the right to propose a block. Era A (whole) number of sessions, which is the period that the validator set (and each validator's active nominator set) is recalculated and where rewards are paid out. Equivocation Providing conflicting information to the network. BABE equivocation entails creating multiple blocks in the same slot. GRANDPA equivocation would consist of signing multiple conflicting chains. External Queue The queue for proposals originating with the Zukma Network/ Council which are waiting to become referenda. Compare the Community queue. Extrinsic State changes that come from the outside world, i.e. they are not part of the system itself. Extrinsics can take two forms, \"inherents\" and \"transactions\". Finality The property of a block that cannot be reverted. Generally, created blocks are not final until some point in the future - perhaps never, in the case of \"probabilistic finality\". The Zukma Network uses a deterministic finality gadget known as GRANDPA. Finality Gadget A mechanism that determines finality. Frame The collection of Substrate-provided pallets (Substrate Runtime Modules). Genesis The origin of a blockchain, also known as block 0. It can also be used to reference the initial state of the blockchain at origination. Governance The process of determining what changes to the network are permissible, such as modifications to code or movement of funds. The governance system in Zukma Network is on-chain and revolves around stakeholder voting. Governance Council An on-chain entity that consists of several on-chain accounts (starting at 6, eventually moving to the final value of 24). The Council can act as a representative for \"passive\" (non-voting) stakeholders. Council members have two main tasks: proposing referenda for the overall stakeholder group to vote on and cancelling malicious referenda. GRANDPA Finality Gadget GHOST-based Recursive ANcestor Deriving Prefix Agreement. It is the finality gadget for Zukma Network, which allows asynchronous, accountable, and safe finality to the blockchain. For an overview of GRANDPA, see this Medium post. Hard Fork A permanent diversion of a blockchain occurs quickly due to a high priority change in a consensus rule. Clients who follow a hard fork always need to upgrade their clients to continue following the upgraded chain. Hard forks are considered permanent divergences of a chain for which non-upgraded clients are following consensus rules incompatible to the ones followed by upgraded clients. Inactive Nomination A validator (or validators) that a nominator has selected to nominate, but is not actively validating this era. This type of nomination may become active in a future era. Inherent Extrinsics that are \"inherently true.\" Inherents are not gossiped on the network and are put into blocks by the block author. They are not provably true the way that the desire to send funds is, therefore they do not carry a signature. A blockchain's runtime must have rules for validating inherents. For example, timestamps are inherents. They are validated by being within some margin that each validator deems reasonable. Injected Account An account that is not directly managed by the Substrate Explorer UI but can be accessed through it, such as accounts controlled by the Polkadot{.js} extension. Interoperability The ability for some sort of system to exchange and make use of information often compared to \"cross-chain\" technologies. Keep-Alive Check The keep-alive check is used to indicate whether or not a transfer can allow the sending account to be reduced to less than the existential deposit, causing it to be reaped. Zukma Network The \"canary network\" for Zukma. It consists of an early-release, unaudited version of the Zukma software. It is not a testnet - after the transition to NPoS, the network is entirely in the hands of the community (i.e., Zukma Network coin holders). LIBP2P An open-source library for encrypted peer-to-peer communications and other networking functions. More information at: https://libp2p.io/ Liveness The property of a distributed system is that it will eventually come to some sort of consensus. A system stuck in an infinite loop would not be considered live, even if computations are taking place; a system that eventually provides a result, even if incorrect or it takes a long time, is considered to have liveness. Mainnet Short for \"main network\": the fully functional and acting chain that runs its own network. Metadata Data that includes information about other data, such as information about a specific transaction. Next Session This indicates that the validator will be a member of the active set in the next session. Node Explorer A tool that gives you information about a node, such as the latest blocks sealed, finalized, and the current chain state as known by that node. Nominated Proof of Stake (NPoS) A Proof-of-Stake system where nominators back validators with their own stake as a show of faith in the good behavior of the validator. Nominated Proof-of-Stake differs from the more generic concept Delegated Proof-of-Stake in that nominators are subject to loss of stake if they nominate a bad validator; delegators are not subject to loss of stake based on the behavior of the validator. Note that some other blockchain technologies may use the term Delegated Proof-of-Stake, even if delegators can be slashed. Zukma Network uses the Phragm\u00e9n method to allocate stake to nominees. Nominator Accounts that select a set of validators to nominate by bonding their coins. Nominators receive some of the validators' rewards, but are also liable for slashing if their nominated validators misbehave. Non-fungible Token (NFT) A non-fungible token is a token that does not hold the property of fungibility, which, in turn, means that it cannot be interchangeable and indistinguishable from other tokens. NFTs allow the tokenization of unique items and provide exclusive ownership for those tokens. On-chain Governance A governance system of a blockchain that is controlled by mechanisms on the blockchain. On-chain governance allows decisions to be made transparently. Note that there are a variety of different algorithms for making these decisions, such as simple majority voting, adaptive quorum biasing, or identity-based quadratic voting. Online Message This is a message that is broadcast by a validator to verify to the network that the validator is online, even if they haven't published a block this epoch. This is sometimes referred to as \"ImOnline\" or \"Heartbeat Signal\". Origin The initiator of an extrinsic. A simple origin would be the account that is sending coins to another account. Substrate also supports more complex origin types, such as the root origin, from which privileged functions can be called. Oversubscribed If more than the maximum number of nominators nominate the same validator, it is \"oversubscribed\", and only the top staked nominators (ranked by the amount of stake, up to the maximum number of nominators) are paid rewards. Other nominators will receive no rewards for that era. The current maximum number of nominators is 256 on Zukma Network, but it can be modified via governance. Pallet A Substrate runtime module. Parity Technologies A company, founded by Dr. Gavin Wood and Dr. Jutta Steiner, that is developing Substrate and Polkadot. It has also released several other projects including Parity Ethereum and Parity Secret Store. Proof of Stake (PoS) A method of selecting participation in a consensus system, in which participants are chosen based on how many coins/tokens they have at stake (at risk of loss due to misbehavior). Normally, Proof-of-Stake systems limit the number of participants. Proof of Work (PoW) A method of selecting participants in a consensus system, typically the longest chain rule, in which participants try to solve a puzzle like finding a partial pre-image of a hash. Normally, a Proof-of-Work system can have any number of participants. Proposal A potential function call to be voted on in a referendum. Proposals modify the behavior of the Zukma Network, from minor parameter tuning up to replacing the runtime code. Protocol A system of rules that allows two or more entities of a communications system to transmit information. The protocol defines the rules, syntax, semantics, and synchronization of communication and possible recovery methods.f Random Seed A random seed is a pseudo-random number available on-chain. It is used in various places of the Zukma Network, most prominently in BABE the block production mechanism. Referendum A vote on whether or not a proposal should be accepted by the network. Referenda may be initiated by the Governance Council, by a member of the public, or as the result of a previous proposal. Stakeholders vote on referenda, weighted by both the size of their stake (i.e. number of ZEP held) and the amount of time they are willing to lock their coins. Re-Genesis Re-Genesis is the process of exporting the current chain state, and creating a new chain that builds on it. Re-Genesis will involve stop-the-world migration, which results in a period of time when no actual blocks are added to the blockchain. In a way, re-genesis can be viewed as a hard fork process. A formal design of Re-Genesis on Substrate is still under development - Re-Genesis Rationale and Design . Runtime The state transition function of a blockchain. It defines a valid algorithm for determining the state of the next block given the previous state. Runtime Module A module that implements specific transition functions and features one might want to have in their runtime. Each module should have domain-specific logic. For example, a Balances module has logic to deal with accounts and balances. In Substrate, modules are called \"pallets\". Safety The property of a distributed system indicating that a particular state transition will not be reverted. GRANDPA provides deterministic safety. That is, for a state changed marked as \"safe\" or \"final\", one would require a hard fork to revert that change. Scalability While an ambiguous concept, [blockchain] scalability can be understood as the ability for the network to scale in capabilities (e.g. processing more transactions) when needed. ZEP The native coin for Zukma. ZEP serves three purposes: network governance (allowing them to vote on-chain upgrades and other exceptional events), general operation (rewarding good actors and punishing bad actors), and bonding. Sealing The process of adding a block to the Chain. Note that finalization is a separate process - blocks are finalized sometime after they are sealed. Session A session is a Substrate implementation term for a period that has a constant set of validators. Validators can only join or exit the validator set at a session change. Session Certificate A message containing a signature on the concatenation of all the Session keys. Signed by the Controller. Session Key Hot keys that are used for performing network operations by validators, for example, signing GRANDPA commit messages. Slashing The removal of a percentage of an account's ZEP as a punishment for a validator acting maliciously or incompetently (e.g., equivocating or remaining offline for an extended period). Soft Fork A backward compatible change to client code causes upgraded clients to start mining a new chain. Requires a \"vote-by-hashrate\" of a majority of miners to enact successfully. Soft forks are considered temporary divergences in a chain since non-upgraded clients do not follow the new consensus rules but upgraded clients are still compatible with old consensus rules. Staking The act of bonding coins (for Zukma Network, ZEP) by putting them up as \"collateral\" for a chance to produce a valid block (and thus obtain a block reward). Validators and nominators stake their ZEP in order to secure the network. State transition function A function that describes how the state of a blockchain can be transformed. For example, it may describe how tokens can be transferred from one account to another. Substrate A modular framework for building blockchains. Zukma Network are built using Substrate. Chains built with Substrate will be easy to connect as parachains. Tabling In Zukma Network governance, bringing a proposal to a vote via referendum. Note that this is the British meaning of \"tabling\", which is different from the US version, which means \"to postpone\" a measure. Teleport Send an asset from an account on one chain to an account on a different chain. This occurs by burning an amount on the sending chain and minting an equivalent amount on the destination chain. Testnet Short for \"test network\": an experimental network where testing and development takes place. Networks are often executed on a testnet before they are deployed to a mainnet Tokenization The process of replacing sensitive data with non-sensitive data. Transfer Send an asset from one account to another. This generally refers to transfers that occur only on the same chain. Transaction An extrinsic that is signed. Transactions are gossiped on the network and incur a transaction fee. Transactions are \"provably true\", unlike inherents. For example, one can prove that Alice wants to send funds to Bob by the fact that she signed a transfer-funds message with her private key. Validator A node that secures the Chain by staking ZEP. Voting The process of stakeholders determining whether or not a referendum should pass. Votes are weighted both by the number of ZEP that the stakeholder account controls and the amount of time they are willing to lock their ZEP. Waiting Nomination The nominator has nominated this validator, but the validator was not elected into the active validator set this era and thus cannot produce blocks for the canonical chain. If the validator does get into the active set in a future era, this may turn into an active or inactive nomination. Wallet A program that allows one to store private keys and sign transactions for Zukma Network or other blockchain networks. Wasm The abbreviation for WebAssembly. Web3 Foundation A Switzerland-based foundation that nurtures and stewards technologies and applications in the fields of decentralized web software protocols, particularly those that utilize modern cryptographic methods to safeguard decentralization, to the benefit and for the stability of the Web3 ecosystem. WebAssembly An instruction format for a virtual, stack-based machine. Polkadot Runtime Modules are compiled to WebAssembly. Also known as Wasm. Written by Zukma Team","title":"Glossary"},{"location":"troubleshooting/02-Glossary/#glossary","text":"","title":"Glossary"},{"location":"troubleshooting/02-Glossary/#active-nomination","text":"A validator (or validators) that a nominator has selected to nominate and is actively validating this era. The nominator is placing their stake behind this validator for this era and will potentially receive staking rewards in return for doing so.","title":"Active Nomination"},{"location":"troubleshooting/02-Glossary/#authority","text":"An authority is a generic term for the role in a blockchain that can participate in the consensus mechanisms. In GRANDPA, the authorities vote on chains they consider final. In BABE, the authorities are block producers. Authority sets can be chosen to be mechanisms such as Polkadot's NPoS algorithm.","title":"Authority"},{"location":"troubleshooting/02-Glossary/#babe","text":"Blind Assignment of Block Extension (BABE) is Zukma Network block production mechanism.","title":"BABE"},{"location":"troubleshooting/02-Glossary/#block","text":"A collection of data, such as transactions, that together indicate a state transition of the blockchain.","title":"Block"},{"location":"troubleshooting/02-Glossary/#block-explorer","text":"An application that allows a user to explore the different blocks on a blockchain.","title":"Block Explorer"},{"location":"troubleshooting/02-Glossary/#blocks-nominations","text":"This indicates that a validator does not currently allow any more nominations. This is controlled by the validator.","title":"Blocks Nominations"},{"location":"troubleshooting/02-Glossary/#bonding","text":"A process by which coins/tokens can be \"frozen\" in exchange for some other benefit. For example, staking is a form of bonding for which you receive rewards in exchange for securing the network.","title":"Bonding"},{"location":"troubleshooting/02-Glossary/#bounty","text":"A mechanism which works in some sense as the reverse of a Treasury Proposal, allowing the Zukma Network/Zukma Council to indicate that there is a need to do some task for the Zukma Network and allowing users to receive ZEP in return for working on that task.","title":"Bounty"},{"location":"troubleshooting/02-Glossary/#bridge","text":"A bridge is a piece of software that aims to increase interoperability between different blockchains. A bridge lets users convert their crypto assets into wrapped tokens of a destination chain.","title":"Bridge"},{"location":"troubleshooting/02-Glossary/#capacity","text":"The maximum number of nominators signalling intent to nominate a validator (and thus could potentially actively nominate that validator in the next session). This maximum number will equal the number of nominators necessary to oversubscribe a validator. Any validator which is \"at capacity\" or higher may potentially be oversubscribed in the next session; a validator that is not at capacity cannot be oversubscribed unless more nominators select it before the next election.","title":"Capacity"},{"location":"troubleshooting/02-Glossary/#commission","text":"Validators and nominators get paid from block production on the network, where validators can set a variable commission rate, which is initially subtracted from the total rewards that validator is entitled to (for that period), where the commission determines the rate of distribution for the remaining rewards set out for the nominators that are backing that validator.","title":"Commission"},{"location":"troubleshooting/02-Glossary/#community-queue","text":"The queue for proposals originating from individual accounts (i.e. not the Council) which are waiting to become referenda. Compare the External queue.","title":"Community Queue"},{"location":"troubleshooting/02-Glossary/#consensus","text":"The process of a group of entities to agree on a particular data value (such as the ordering and makeup of blocks on a blockchain). There are a variety of algorithms used for determining consensus. The consensus algorithm used by Zukma Network is BABE and GRANDPA.","title":"Consensus"},{"location":"troubleshooting/02-Glossary/#curator","text":"A person, group, or other entity charged with judging and verifying the successful completion of a Bounty.","title":"Curator"},{"location":"troubleshooting/02-Glossary/#dapps","text":"A generic term for a decentralized application, that is, one that runs as part of a distributed network as opposed to being run on a specific system or set of systems.","title":"Dapps"},{"location":"troubleshooting/02-Glossary/#epoch","text":"An epoch is a time duration in the BABE protocol that is broken into smaller time slots. Each slot has at least one slot leader who has the right to propose a block.","title":"Epoch"},{"location":"troubleshooting/02-Glossary/#era","text":"A (whole) number of sessions, which is the period that the validator set (and each validator's active nominator set) is recalculated and where rewards are paid out.","title":"Era"},{"location":"troubleshooting/02-Glossary/#equivocation","text":"Providing conflicting information to the network. BABE equivocation entails creating multiple blocks in the same slot. GRANDPA equivocation would consist of signing multiple conflicting chains.","title":"Equivocation"},{"location":"troubleshooting/02-Glossary/#external-queue","text":"The queue for proposals originating with the Zukma Network/ Council which are waiting to become referenda. Compare the Community queue.","title":"External Queue"},{"location":"troubleshooting/02-Glossary/#extrinsic","text":"State changes that come from the outside world, i.e. they are not part of the system itself. Extrinsics can take two forms, \"inherents\" and \"transactions\".","title":"Extrinsic"},{"location":"troubleshooting/02-Glossary/#finality","text":"The property of a block that cannot be reverted. Generally, created blocks are not final until some point in the future - perhaps never, in the case of \"probabilistic finality\". The Zukma Network uses a deterministic finality gadget known as GRANDPA.","title":"Finality"},{"location":"troubleshooting/02-Glossary/#finality-gadget","text":"A mechanism that determines finality.","title":"Finality Gadget"},{"location":"troubleshooting/02-Glossary/#frame","text":"The collection of Substrate-provided pallets (Substrate Runtime Modules).","title":"Frame"},{"location":"troubleshooting/02-Glossary/#genesis","text":"The origin of a blockchain, also known as block 0. It can also be used to reference the initial state of the blockchain at origination.","title":"Genesis"},{"location":"troubleshooting/02-Glossary/#governance","text":"The process of determining what changes to the network are permissible, such as modifications to code or movement of funds. The governance system in Zukma Network is on-chain and revolves around stakeholder voting.","title":"Governance"},{"location":"troubleshooting/02-Glossary/#governance-council","text":"An on-chain entity that consists of several on-chain accounts (starting at 6, eventually moving to the final value of 24). The Council can act as a representative for \"passive\" (non-voting) stakeholders. Council members have two main tasks: proposing referenda for the overall stakeholder group to vote on and cancelling malicious referenda.","title":"Governance Council"},{"location":"troubleshooting/02-Glossary/#grandpa-finality-gadget","text":"GHOST-based Recursive ANcestor Deriving Prefix Agreement. It is the finality gadget for Zukma Network, which allows asynchronous, accountable, and safe finality to the blockchain. For an overview of GRANDPA, see this Medium post.","title":"GRANDPA Finality Gadget"},{"location":"troubleshooting/02-Glossary/#hard-fork","text":"A permanent diversion of a blockchain occurs quickly due to a high priority change in a consensus rule. Clients who follow a hard fork always need to upgrade their clients to continue following the upgraded chain. Hard forks are considered permanent divergences of a chain for which non-upgraded clients are following consensus rules incompatible to the ones followed by upgraded clients.","title":"Hard Fork"},{"location":"troubleshooting/02-Glossary/#inactive-nomination","text":"A validator (or validators) that a nominator has selected to nominate, but is not actively validating this era. This type of nomination may become active in a future era.","title":"Inactive Nomination"},{"location":"troubleshooting/02-Glossary/#inherent","text":"Extrinsics that are \"inherently true.\" Inherents are not gossiped on the network and are put into blocks by the block author. They are not provably true the way that the desire to send funds is, therefore they do not carry a signature. A blockchain's runtime must have rules for validating inherents. For example, timestamps are inherents. They are validated by being within some margin that each validator deems reasonable.","title":"Inherent"},{"location":"troubleshooting/02-Glossary/#injected-account","text":"An account that is not directly managed by the Substrate Explorer UI but can be accessed through it, such as accounts controlled by the Polkadot{.js} extension.","title":"Injected Account"},{"location":"troubleshooting/02-Glossary/#interoperability","text":"The ability for some sort of system to exchange and make use of information often compared to \"cross-chain\" technologies.","title":"Interoperability"},{"location":"troubleshooting/02-Glossary/#keep-alive-check","text":"The keep-alive check is used to indicate whether or not a transfer can allow the sending account to be reduced to less than the existential deposit, causing it to be reaped.","title":"Keep-Alive Check"},{"location":"troubleshooting/02-Glossary/#zukma-network","text":"The \"canary network\" for Zukma. It consists of an early-release, unaudited version of the Zukma software. It is not a testnet - after the transition to NPoS, the network is entirely in the hands of the community (i.e., Zukma Network coin holders).","title":"Zukma Network"},{"location":"troubleshooting/02-Glossary/#libp2p","text":"An open-source library for encrypted peer-to-peer communications and other networking functions. More information at: https://libp2p.io/","title":"LIBP2P"},{"location":"troubleshooting/02-Glossary/#liveness","text":"The property of a distributed system is that it will eventually come to some sort of consensus. A system stuck in an infinite loop would not be considered live, even if computations are taking place; a system that eventually provides a result, even if incorrect or it takes a long time, is considered to have liveness.","title":"Liveness"},{"location":"troubleshooting/02-Glossary/#mainnet","text":"Short for \"main network\": the fully functional and acting chain that runs its own network.","title":"Mainnet"},{"location":"troubleshooting/02-Glossary/#metadata","text":"Data that includes information about other data, such as information about a specific transaction.","title":"Metadata"},{"location":"troubleshooting/02-Glossary/#next-session","text":"This indicates that the validator will be a member of the active set in the next session.","title":"Next Session"},{"location":"troubleshooting/02-Glossary/#node-explorer","text":"A tool that gives you information about a node, such as the latest blocks sealed, finalized, and the current chain state as known by that node.","title":"Node Explorer"},{"location":"troubleshooting/02-Glossary/#nominated-proof-of-stake-npos","text":"A Proof-of-Stake system where nominators back validators with their own stake as a show of faith in the good behavior of the validator. Nominated Proof-of-Stake differs from the more generic concept Delegated Proof-of-Stake in that nominators are subject to loss of stake if they nominate a bad validator; delegators are not subject to loss of stake based on the behavior of the validator. Note that some other blockchain technologies may use the term Delegated Proof-of-Stake, even if delegators can be slashed. Zukma Network uses the Phragm\u00e9n method to allocate stake to nominees.","title":"Nominated Proof of Stake (NPoS)"},{"location":"troubleshooting/02-Glossary/#nominator","text":"Accounts that select a set of validators to nominate by bonding their coins. Nominators receive some of the validators' rewards, but are also liable for slashing if their nominated validators misbehave.","title":"Nominator"},{"location":"troubleshooting/02-Glossary/#non-fungible-token-nft","text":"A non-fungible token is a token that does not hold the property of fungibility, which, in turn, means that it cannot be interchangeable and indistinguishable from other tokens. NFTs allow the tokenization of unique items and provide exclusive ownership for those tokens.","title":"Non-fungible Token (NFT)"},{"location":"troubleshooting/02-Glossary/#on-chain-governance","text":"A governance system of a blockchain that is controlled by mechanisms on the blockchain. On-chain governance allows decisions to be made transparently. Note that there are a variety of different algorithms for making these decisions, such as simple majority voting, adaptive quorum biasing, or identity-based quadratic voting.","title":"On-chain Governance"},{"location":"troubleshooting/02-Glossary/#online-message","text":"This is a message that is broadcast by a validator to verify to the network that the validator is online, even if they haven't published a block this epoch. This is sometimes referred to as \"ImOnline\" or \"Heartbeat Signal\".","title":"Online Message"},{"location":"troubleshooting/02-Glossary/#origin","text":"The initiator of an extrinsic. A simple origin would be the account that is sending coins to another account. Substrate also supports more complex origin types, such as the root origin, from which privileged functions can be called.","title":"Origin"},{"location":"troubleshooting/02-Glossary/#oversubscribed","text":"If more than the maximum number of nominators nominate the same validator, it is \"oversubscribed\", and only the top staked nominators (ranked by the amount of stake, up to the maximum number of nominators) are paid rewards. Other nominators will receive no rewards for that era. The current maximum number of nominators is 256 on Zukma Network, but it can be modified via governance.","title":"Oversubscribed"},{"location":"troubleshooting/02-Glossary/#pallet","text":"A Substrate runtime module.","title":"Pallet"},{"location":"troubleshooting/02-Glossary/#parity-technologies","text":"A company, founded by Dr. Gavin Wood and Dr. Jutta Steiner, that is developing Substrate and Polkadot. It has also released several other projects including Parity Ethereum and Parity Secret Store.","title":"Parity Technologies"},{"location":"troubleshooting/02-Glossary/#proof-of-stake-pos","text":"A method of selecting participation in a consensus system, in which participants are chosen based on how many coins/tokens they have at stake (at risk of loss due to misbehavior). Normally, Proof-of-Stake systems limit the number of participants.","title":"Proof of Stake (PoS)"},{"location":"troubleshooting/02-Glossary/#proof-of-work-pow","text":"A method of selecting participants in a consensus system, typically the longest chain rule, in which participants try to solve a puzzle like finding a partial pre-image of a hash. Normally, a Proof-of-Work system can have any number of participants.","title":"Proof of Work (PoW)"},{"location":"troubleshooting/02-Glossary/#proposal","text":"A potential function call to be voted on in a referendum. Proposals modify the behavior of the Zukma Network, from minor parameter tuning up to replacing the runtime code.","title":"Proposal"},{"location":"troubleshooting/02-Glossary/#protocol","text":"A system of rules that allows two or more entities of a communications system to transmit information. The protocol defines the rules, syntax, semantics, and synchronization of communication and possible recovery methods.f","title":"Protocol"},{"location":"troubleshooting/02-Glossary/#random-seed","text":"A random seed is a pseudo-random number available on-chain. It is used in various places of the Zukma Network, most prominently in BABE the block production mechanism.","title":"Random Seed"},{"location":"troubleshooting/02-Glossary/#referendum","text":"A vote on whether or not a proposal should be accepted by the network. Referenda may be initiated by the Governance Council, by a member of the public, or as the result of a previous proposal. Stakeholders vote on referenda, weighted by both the size of their stake (i.e. number of ZEP held) and the amount of time they are willing to lock their coins.","title":"Referendum"},{"location":"troubleshooting/02-Glossary/#re-genesis","text":"Re-Genesis is the process of exporting the current chain state, and creating a new chain that builds on it. Re-Genesis will involve stop-the-world migration, which results in a period of time when no actual blocks are added to the blockchain. In a way, re-genesis can be viewed as a hard fork process. A formal design of Re-Genesis on Substrate is still under development - Re-Genesis Rationale and Design .","title":"Re-Genesis"},{"location":"troubleshooting/02-Glossary/#runtime","text":"The state transition function of a blockchain. It defines a valid algorithm for determining the state of the next block given the previous state.","title":"Runtime"},{"location":"troubleshooting/02-Glossary/#runtime-module","text":"A module that implements specific transition functions and features one might want to have in their runtime. Each module should have domain-specific logic. For example, a Balances module has logic to deal with accounts and balances. In Substrate, modules are called \"pallets\".","title":"Runtime Module"},{"location":"troubleshooting/02-Glossary/#safety","text":"The property of a distributed system indicating that a particular state transition will not be reverted. GRANDPA provides deterministic safety. That is, for a state changed marked as \"safe\" or \"final\", one would require a hard fork to revert that change.","title":"Safety"},{"location":"troubleshooting/02-Glossary/#scalability","text":"While an ambiguous concept, [blockchain] scalability can be understood as the ability for the network to scale in capabilities (e.g. processing more transactions) when needed.","title":"Scalability"},{"location":"troubleshooting/02-Glossary/#zep","text":"The native coin for Zukma. ZEP serves three purposes: network governance (allowing them to vote on-chain upgrades and other exceptional events), general operation (rewarding good actors and punishing bad actors), and bonding.","title":"ZEP"},{"location":"troubleshooting/02-Glossary/#sealing","text":"The process of adding a block to the Chain. Note that finalization is a separate process - blocks are finalized sometime after they are sealed.","title":"Sealing"},{"location":"troubleshooting/02-Glossary/#session","text":"A session is a Substrate implementation term for a period that has a constant set of validators. Validators can only join or exit the validator set at a session change.","title":"Session"},{"location":"troubleshooting/02-Glossary/#session-certificate","text":"A message containing a signature on the concatenation of all the Session keys. Signed by the Controller.","title":"Session Certificate"},{"location":"troubleshooting/02-Glossary/#session-key","text":"Hot keys that are used for performing network operations by validators, for example, signing GRANDPA commit messages.","title":"Session Key"},{"location":"troubleshooting/02-Glossary/#slashing","text":"The removal of a percentage of an account's ZEP as a punishment for a validator acting maliciously or incompetently (e.g., equivocating or remaining offline for an extended period).","title":"Slashing"},{"location":"troubleshooting/02-Glossary/#soft-fork","text":"A backward compatible change to client code causes upgraded clients to start mining a new chain. Requires a \"vote-by-hashrate\" of a majority of miners to enact successfully. Soft forks are considered temporary divergences in a chain since non-upgraded clients do not follow the new consensus rules but upgraded clients are still compatible with old consensus rules.","title":"Soft Fork"},{"location":"troubleshooting/02-Glossary/#staking","text":"The act of bonding coins (for Zukma Network, ZEP) by putting them up as \"collateral\" for a chance to produce a valid block (and thus obtain a block reward). Validators and nominators stake their ZEP in order to secure the network.","title":"Staking"},{"location":"troubleshooting/02-Glossary/#state-transition-function","text":"A function that describes how the state of a blockchain can be transformed. For example, it may describe how tokens can be transferred from one account to another.","title":"State transition function"},{"location":"troubleshooting/02-Glossary/#substrate","text":"A modular framework for building blockchains. Zukma Network are built using Substrate. Chains built with Substrate will be easy to connect as parachains.","title":"Substrate"},{"location":"troubleshooting/02-Glossary/#tabling","text":"In Zukma Network governance, bringing a proposal to a vote via referendum. Note that this is the British meaning of \"tabling\", which is different from the US version, which means \"to postpone\" a measure.","title":"Tabling"},{"location":"troubleshooting/02-Glossary/#teleport","text":"Send an asset from an account on one chain to an account on a different chain. This occurs by burning an amount on the sending chain and minting an equivalent amount on the destination chain.","title":"Teleport"},{"location":"troubleshooting/02-Glossary/#testnet","text":"Short for \"test network\": an experimental network where testing and development takes place. Networks are often executed on a testnet before they are deployed to a mainnet","title":"Testnet"},{"location":"troubleshooting/02-Glossary/#tokenization","text":"The process of replacing sensitive data with non-sensitive data.","title":"Tokenization"},{"location":"troubleshooting/02-Glossary/#transfer","text":"Send an asset from one account to another. This generally refers to transfers that occur only on the same chain.","title":"Transfer"},{"location":"troubleshooting/02-Glossary/#transaction","text":"An extrinsic that is signed. Transactions are gossiped on the network and incur a transaction fee. Transactions are \"provably true\", unlike inherents. For example, one can prove that Alice wants to send funds to Bob by the fact that she signed a transfer-funds message with her private key.","title":"Transaction"},{"location":"troubleshooting/02-Glossary/#validator","text":"A node that secures the Chain by staking ZEP.","title":"Validator"},{"location":"troubleshooting/02-Glossary/#voting","text":"The process of stakeholders determining whether or not a referendum should pass. Votes are weighted both by the number of ZEP that the stakeholder account controls and the amount of time they are willing to lock their ZEP.","title":"Voting"},{"location":"troubleshooting/02-Glossary/#waiting-nomination","text":"The nominator has nominated this validator, but the validator was not elected into the active validator set this era and thus cannot produce blocks for the canonical chain. If the validator does get into the active set in a future era, this may turn into an active or inactive nomination.","title":"Waiting Nomination"},{"location":"troubleshooting/02-Glossary/#wallet","text":"A program that allows one to store private keys and sign transactions for Zukma Network or other blockchain networks.","title":"Wallet"},{"location":"troubleshooting/02-Glossary/#wasm","text":"The abbreviation for WebAssembly.","title":"Wasm"},{"location":"troubleshooting/02-Glossary/#web3-foundation","text":"A Switzerland-based foundation that nurtures and stewards technologies and applications in the fields of decentralized web software protocols, particularly those that utilize modern cryptographic methods to safeguard decentralization, to the benefit and for the stability of the Web3 ecosystem.","title":"Web3 Foundation"},{"location":"troubleshooting/02-Glossary/#webassembly","text":"An instruction format for a virtual, stack-based machine. Polkadot Runtime Modules are compiled to WebAssembly. Also known as Wasm. Written by Zukma Team","title":"WebAssembly"},{"location":"validator-guides/account-generation/","text":"ACCOUNT GENERATION To start interacting with Zukma, you need a wallet or account that enables you to send transactions, participate in the chain governance, run a validator or nominate to earn interest. The following guide will show you how easy setting up a Zukma account is and what exact steps you need to take. If you encounter any issues or problems, please feel free to reach out to us on Telegram . Before we start, let's get some terms right, and let's spend a couple of seconds talking about the concept of keys. A standard wallet or account is composed out of two keys: The PUBLIC KEY (Wallet address) The PRIVATE KEY (The key that allows you to access and manage your funds) Your Zukma account follows the same rules. Therefore, we will continue with a section on key security to make you aware that You must keep your PRIVATE KEY, SEED PHRASE, or JSON KEYSTORE file secret at all times. Storing your key safely The only ways to access your account are via your secret seed or your account's JSON file in combination with a password. It would be best if you kept them both secure and private. If you share them with anyone, they will have full access to your account, including all of your funds. This information is a target for hackers and others with bad intentions. In this guide, we recommend the Polkadot{.js} browser plug-in as the best method to create your Zukma account. Tip Polkadot{.js} Browser Extension RECOMMENDED FOR MOST USERS The seed is your key to the account. Knowing the seed allows you to re-generate and control your account or anyone else who knows the seed. It is imperative to store the seed somewhere safe, secret, and secure. If you lose access to your account (i.e., forget the password for your account's JSON file), you can re-create it by entering the seed. This also means that somebody else can control your account if they have access to your seed. For maximum security, the seed should be written down on paper or another non-digital device and stored in a safe place. You may also want to protect your seed from physical damage (e.g., keeping it in a sealed plastic bag to prevent water damage, storing it in a fireproof safe, etching it in metal, etc.) We recommend that you keep multiple copies of the seed in geographically separate locations (e.g., one in your home safe and one in a safety deposit box at your bank). You should not store your seed on any kind of computer that has or may have access to the internet in the future. Storing your account's JSON file The JSON file is encrypted with a password, which means you can import it into any wallet which supports JSON imports, but to then use it, you need the password. You don't have to be as careful with your JSON file's storage as you would with your seed (i.e. it can be on a USB drive near you), but remember that in this case, your account is only as secure as the password you used to encrypt it. Do not use easy to guess or hard to remember passwords. It is good practice to use a mnemonic password of four to five words. These are nearly impossible for computers to guess due to the number of combinations possible but much more manageable for humans to remember. Polkadot{.js} Browser Extension Since Polkadot and Zukma share the same foundation, namely Substrate, the Polkadot{.js} browser extension is the recommended way to create your Zukma account. Polkadot{.js} Browser Extension for Chrome & Brave Polkadot{.js} Browser Extension for Firefox The Polkadot{.js} browser extension provides a reasonable balance of security and usability. It's comparable to MetaMask for Ethereum. It provides a separate local mechanism to generate your address and interact with Zukma. So let's start installing the Polkadot{.js} plugin to enable you to interact with Zukma. Create an Account Open the Polkadot{.js} browser extension by clicking the logo on the top bar of your browser. You will see a browser popup, not unlike the one below. Click the big plus button or select \"Create new account\" from the small plus icon in the top right. The Polkadot{.js} plugin will then use system randomness to make a new seed for you and display it to you in the form of twelve words. You should back up these words as explained above. It is imperative to store the seed somewhere safe, secret, and secure. If you cannot access your account via Polkadot{.js} for some reason, you can re-enter your seed through the \"Add account menu\" by selecting \"Import account from pre-existing seed\". Name your Account The account name is arbitrary and for your use only. It is not stored on the blockchain and will not be visible to other users who look at your address via a block explorer. If you're juggling multiple accounts, it helps to make this as descriptive and detailed as needed. Enter Password You will use the password to encrypt this account's information. You will need to re-enter it when using the account for all outgoing transactions or sign a cryptographic message. Warning Note that this password does NOT protect your seed phrase. If someone knows the twelve words in your mnemonic seed, they still control your account even if they do not know the password. Success Congrats! You managed to create a Zukma-Substrate Account with the Polkadot{.js} browser extention. Written by Zukma Team","title":"Create an Account"},{"location":"validator-guides/account-generation/#account-generation","text":"To start interacting with Zukma, you need a wallet or account that enables you to send transactions, participate in the chain governance, run a validator or nominate to earn interest. The following guide will show you how easy setting up a Zukma account is and what exact steps you need to take. If you encounter any issues or problems, please feel free to reach out to us on Telegram . Before we start, let's get some terms right, and let's spend a couple of seconds talking about the concept of keys. A standard wallet or account is composed out of two keys: The PUBLIC KEY (Wallet address) The PRIVATE KEY (The key that allows you to access and manage your funds) Your Zukma account follows the same rules. Therefore, we will continue with a section on key security to make you aware that You must keep your PRIVATE KEY, SEED PHRASE, or JSON KEYSTORE file secret at all times.","title":"ACCOUNT GENERATION"},{"location":"validator-guides/account-generation/#storing-your-key-safely","text":"The only ways to access your account are via your secret seed or your account's JSON file in combination with a password. It would be best if you kept them both secure and private. If you share them with anyone, they will have full access to your account, including all of your funds. This information is a target for hackers and others with bad intentions. In this guide, we recommend the Polkadot{.js} browser plug-in as the best method to create your Zukma account. Tip Polkadot{.js} Browser Extension RECOMMENDED FOR MOST USERS The seed is your key to the account. Knowing the seed allows you to re-generate and control your account or anyone else who knows the seed. It is imperative to store the seed somewhere safe, secret, and secure. If you lose access to your account (i.e., forget the password for your account's JSON file), you can re-create it by entering the seed. This also means that somebody else can control your account if they have access to your seed. For maximum security, the seed should be written down on paper or another non-digital device and stored in a safe place. You may also want to protect your seed from physical damage (e.g., keeping it in a sealed plastic bag to prevent water damage, storing it in a fireproof safe, etching it in metal, etc.) We recommend that you keep multiple copies of the seed in geographically separate locations (e.g., one in your home safe and one in a safety deposit box at your bank). You should not store your seed on any kind of computer that has or may have access to the internet in the future.","title":"Storing your key safely"},{"location":"validator-guides/account-generation/#storing-your-accounts-json-file","text":"The JSON file is encrypted with a password, which means you can import it into any wallet which supports JSON imports, but to then use it, you need the password. You don't have to be as careful with your JSON file's storage as you would with your seed (i.e. it can be on a USB drive near you), but remember that in this case, your account is only as secure as the password you used to encrypt it. Do not use easy to guess or hard to remember passwords. It is good practice to use a mnemonic password of four to five words. These are nearly impossible for computers to guess due to the number of combinations possible but much more manageable for humans to remember.","title":"Storing your account's JSON file"},{"location":"validator-guides/account-generation/#polkadotjs-browser-extension","text":"Since Polkadot and Zukma share the same foundation, namely Substrate, the Polkadot{.js} browser extension is the recommended way to create your Zukma account. Polkadot{.js} Browser Extension for Chrome & Brave Polkadot{.js} Browser Extension for Firefox The Polkadot{.js} browser extension provides a reasonable balance of security and usability. It's comparable to MetaMask for Ethereum. It provides a separate local mechanism to generate your address and interact with Zukma. So let's start installing the Polkadot{.js} plugin to enable you to interact with Zukma.","title":"Polkadot{.js} Browser Extension"},{"location":"validator-guides/account-generation/#create-an-account","text":"Open the Polkadot{.js} browser extension by clicking the logo on the top bar of your browser. You will see a browser popup, not unlike the one below. Click the big plus button or select \"Create new account\" from the small plus icon in the top right. The Polkadot{.js} plugin will then use system randomness to make a new seed for you and display it to you in the form of twelve words. You should back up these words as explained above. It is imperative to store the seed somewhere safe, secret, and secure. If you cannot access your account via Polkadot{.js} for some reason, you can re-enter your seed through the \"Add account menu\" by selecting \"Import account from pre-existing seed\".","title":"Create an Account"},{"location":"validator-guides/account-generation/#name-your-account","text":"The account name is arbitrary and for your use only. It is not stored on the blockchain and will not be visible to other users who look at your address via a block explorer. If you're juggling multiple accounts, it helps to make this as descriptive and detailed as needed.","title":"Name your Account"},{"location":"validator-guides/account-generation/#enter-password","text":"You will use the password to encrypt this account's information. You will need to re-enter it when using the account for all outgoing transactions or sign a cryptographic message. Warning Note that this password does NOT protect your seed phrase. If someone knows the twelve words in your mnemonic seed, they still control your account even if they do not know the password. Success Congrats! You managed to create a Zukma-Substrate Account with the Polkadot{.js} browser extention. Written by Zukma Team","title":"Enter Password"},{"location":"validator-guides/change-vps-provider/","text":"HOW TO CHANGE YOUR VPS PROVIDER The need to change a VPS provider can occur out of many reasons. Regardless why you decided to change your provider, this guide will show you how to perform all necessary steps in the correct order to not risk the staked ZEP. We will perform the transition in 6 steps: Prepare the new VPS Generate new Session Keys on the new VPS Pair Validator Stash with new the VPS Waiting Period Shut down old VPS Warning Do not copy the Keystore folder of the old VPS to the new VPS! Do not use the same session key! Do not wipe your current VPS before you completed all steps in this guide. Step 1 - Prepare new VPS To enable a smooth transition bring your new VPS server to a fully synced state. You can follow the Become a Validator guide to prepare your new VPS. Once your new VPS is fully synced you can continue with the next steps. You can check the snyc status on the Telemetry UI . Step 2 - Generate New Session Keys Login to your new and fully synced VPS. Execute the following command to fetch a new session key: curl -H \"Content-Type: application/json\" -d '{\"id\":1, \"jsonrpc\":\"2.0\", \"method\": \"author_rotateKeys\", \"params\":[]}' http://localhost:9933 Copy the session key. It will look like this: 0x13660593581b2e728ee32122636f8996c6fd9c22f33beaa05e2797899c5458b0c888149bf3c0b5ca7fb7296e69fefd85e4e3d5b76848db890207575e49031f37d846e78babf8051c123b498ffe6f12e712f97f6b2f3b54345ffe51145a16bb22187d415c2101b9883668ce93c46f7ba556b394c59781854737b6c941747c0964 Step 3 - Pairing (Set Keys) Head to the Substrate Portal (Chain UI) account actions tab Network -> Staking -> Account Actions or simply follow the aforementioned link. Here we want to pair our new VPS with the current validator stash. The session key from step two will become the link between our validator stash and our new VPS. Therefore, we must change the session keys for our validator stash. We do this by clicking on the menu (three dots) button displayed on the right end of our stash and then clicking the change session keys item. Paste the session key generated in Step 2 into the respective field of the pop-up menu and click the Set Session Key button. Hint Take a note of the era you are currently in Step 4 - Waiting Period The set_key command does not have an immediate effect and requires two full eras to elapse before it does. If you do switch off your old VPS too early you may risk being chilled for the upcoming era. Example: If we clicked on the Set Session Key button halfway through era number 10 we must wait until era 10 elapses and two more eras passed by. Which means, we would be good to go in era 13. Read about the consequences of getting chilled here . Usually being chilled means your validator will be inactive and won't perform any payable actions during the upcoming era. But in case more than 10% of the network is getting chilled at the same time you might face penalties. Step 5 - Shutting down your old VPS When two full eras passed we can be sure that our new VPS has taken over, and we can safely shut down our old VPS. Success Alright mate! You are all set :D Written by Zukma Team","title":"Change VPS Provider"},{"location":"validator-guides/change-vps-provider/#how-to-change-your-vps-provider","text":"The need to change a VPS provider can occur out of many reasons. Regardless why you decided to change your provider, this guide will show you how to perform all necessary steps in the correct order to not risk the staked ZEP. We will perform the transition in 6 steps: Prepare the new VPS Generate new Session Keys on the new VPS Pair Validator Stash with new the VPS Waiting Period Shut down old VPS Warning Do not copy the Keystore folder of the old VPS to the new VPS! Do not use the same session key! Do not wipe your current VPS before you completed all steps in this guide.","title":"HOW TO CHANGE YOUR VPS PROVIDER"},{"location":"validator-guides/change-vps-provider/#step-1-prepare-new-vps","text":"To enable a smooth transition bring your new VPS server to a fully synced state. You can follow the Become a Validator guide to prepare your new VPS. Once your new VPS is fully synced you can continue with the next steps. You can check the snyc status on the Telemetry UI .","title":"Step 1 - Prepare new VPS"},{"location":"validator-guides/change-vps-provider/#step-2-generate-new-session-keys","text":"Login to your new and fully synced VPS. Execute the following command to fetch a new session key: curl -H \"Content-Type: application/json\" -d '{\"id\":1, \"jsonrpc\":\"2.0\", \"method\": \"author_rotateKeys\", \"params\":[]}' http://localhost:9933 Copy the session key. It will look like this: 0x13660593581b2e728ee32122636f8996c6fd9c22f33beaa05e2797899c5458b0c888149bf3c0b5ca7fb7296e69fefd85e4e3d5b76848db890207575e49031f37d846e78babf8051c123b498ffe6f12e712f97f6b2f3b54345ffe51145a16bb22187d415c2101b9883668ce93c46f7ba556b394c59781854737b6c941747c0964","title":"Step 2 - Generate New Session Keys"},{"location":"validator-guides/change-vps-provider/#step-3-pairing-set-keys","text":"Head to the Substrate Portal (Chain UI) account actions tab Network -> Staking -> Account Actions or simply follow the aforementioned link. Here we want to pair our new VPS with the current validator stash. The session key from step two will become the link between our validator stash and our new VPS. Therefore, we must change the session keys for our validator stash. We do this by clicking on the menu (three dots) button displayed on the right end of our stash and then clicking the change session keys item. Paste the session key generated in Step 2 into the respective field of the pop-up menu and click the Set Session Key button. Hint Take a note of the era you are currently in","title":"Step 3 - Pairing (Set Keys)"},{"location":"validator-guides/change-vps-provider/#step-4-waiting-period","text":"The set_key command does not have an immediate effect and requires two full eras to elapse before it does. If you do switch off your old VPS too early you may risk being chilled for the upcoming era. Example: If we clicked on the Set Session Key button halfway through era number 10 we must wait until era 10 elapses and two more eras passed by. Which means, we would be good to go in era 13. Read about the consequences of getting chilled here . Usually being chilled means your validator will be inactive and won't perform any payable actions during the upcoming era. But in case more than 10% of the network is getting chilled at the same time you might face penalties.","title":"Step 4 - Waiting Period"},{"location":"validator-guides/change-vps-provider/#step-5-shutting-down-your-old-vps","text":"When two full eras passed we can be sure that our new VPS has taken over, and we can safely shut down our old VPS. Success Alright mate! You are all set :D Written by Zukma Team","title":"Step 5 - Shutting down your old VPS"},{"location":"validator-guides/node-monitoring/","text":"HOW TO VISUALIZE NODE METRICS This guide will teach you how to use Prometheus and Grafana to implement a basic validator monitoring. We can do this because every Zukma node exposes metrics such as the chain height, number of connected peers or the amount of memory used on a Prometheus metric endpoint. We will use Prometheus to collect the data and Grafana to visualize them on a nice looking dashboard. Example Monitoring Architecture +--------------+ +-------------+ +---------+ | Zukma Node | | Prometheus | | Grafana | +--------------+ +-------------+ +---------+ | -----------------\\ | | | | Every 1 minute |-| | | |----------------| | | | | | | GET current metric values | | |<---------------------------------| | | | | | `substrate_peers_count 5` | | |--------------------------------->| | | | --------------------------------------------------------------------\\ | | |-| Save metric value with corresponding time stamp in local database | | | | |-------------------------------------------------------------------| | | | -------------------------------\\ | | | | Every time user opens graphs |-| | | |------------------------------| | | | | | | GET values of metric `substrate_peers_count` from time-X to time-Y | | |<-------------------------------------------------------------------------| | | | | | `substrate_peers_count (1582023828, 5), (1582023847, 4) [...]` | | |------------------------------------------------------------------------->| | | | Step 1 - Install Prometheus and Grafana To protect our node we will create a user for Prometheus but not allow Prometheus to log-in itself. We will then create the directories required to store the Prometheus config and executable file and then change the ownership of these directories to the Prometheus user so that only Prometheus can access them. Create Prometheus User: sudo useradd --no-create-home --shell /usr/sbin/nologin prometheus Create the directories required to store the configuration and executable files: sudo mkdir /etc/prometheus sudo mkdir /var/lib/prometheus Change the ownership of these directories to prometheus : sudo chown -R prometheus:prometheus /etc/prometheus sudo chown -R prometheus:prometheus /var/lib/prometheus Install and Configure Prometheus After setting up the environment, update your OS, and install the latest Prometheus. You can check the latest release by visiting their downloads page. sudo apt-get update && apt-get upgrade wget https://github.com/prometheus/prometheus/releases/download/v2.33.5/prometheus-2.33.5.linux-amd64.tar.gz tar xfz prometheus-*.tar.gz Let's inspect the unzipped file we downloaded by changing directories: cd prometheus-2.33.5.linux-amd64 The following two binaries are in the directory: prometheus -> Prometheus main binary file promtool The following two directories (which contain the web interface, configuration files examples and the license) are in the directory: console console_libraries We want to copy the downloaded bin files and move it to our local folder for bin files /usr/local/bin/ sudo cp ./prometheus /usr/local/bin/ sudo cp ./promtool /usr/local/bin/ We also want to change the ownership of those file to our Prometheus user: sudo chown prometheus:prometheus /usr/local/bin/prometheus sudo chown prometheus:prometheus /usr/local/bin/promtool We also want to copy and move the consoles and console_libraries folders into our local folder /etc/prometheus sudo cp -r ./consoles /etc/prometheus sudo cp -r ./console_libraries /etc/prometheus We again want to change the ownership to our Prometheus user: sudo chown -R prometheus:prometheus /etc/prometheus/consoles sudo chown -R prometheus:prometheus /etc/prometheus/console_libraries Success Now we successfully moved all folders and binaries of the downloaded folder into the correct local folders and changed their ownership to our Prometheus user. Now we can safely delete the downloaded folder: cd .. && rm -rf prometheus* Configure Prometheus Before Prometheus can be started, it needs some configuration. We will manage the configuration in a .yml file which we will create now: sudo nano /etc/prometheus/prometheus.yml The config file is divided into three parts: global rule_files scrape_configs scrape_interval defines how often Prometheus scrapes targets, while evaluation_interval controls how often the software will evaluate rules. rule files block contains information of the location of any rules we want the Prometheus server to load. scrape_configs contains the information which resources Prometheus monitors. Configure the file as following: global: scrape_interval: 15s evaluation_interval: 15s rule_files: # - \"first.rules\" # - \"second.rules\" scrape_configs: - job_name: \"prometheus\" scrape_interval: 5s static_configs: - targets: [\"localhost:9090\"] - job_name: \"Zukma_Node\" scrape_interval: 5s static_configs: - targets: [\"localhost:9615\"] Note Prometheus can manage multiple jobs. We currently have two jobs (Prometheus and Zukma_Node) and both are listening on localhost ports. You can also change the target address to an IP address of another node if you want to centralize all the data. With the above configuration file, the first exporter is the one that Prometheus exports to monitor itself. As we want to have more precise information about the state of the Prometheus server we reduced the scrape_interval to 5 seconds for this job. The parameters static_configs and targets determine where the exporters are running. The second exporter is capturing the data from our node, and the port by default is 9615. Let' check the validity of the configuration file by running sudo chown prometheus:prometheus /etc/prometheus/prometheus.yml And let's change the ownership of the config file to our Prometheus user: sudo chown prometheus:prometheus /etc/prometheus/prometheus.yml Start Prometheus Before we start Prometheus let's make sure that our firewall isn't blocking port 9090 ufw allow 9090 To test that Prometheus is set up properly we will execute a command to inspect the logs: Remember, we need to run this command as the Prometheus user due to the ownership of the files: sudo -u prometheus /usr/local/bin/prometheus --config.file /etc/prometheus/prometheus.yml --storage.tsdb.path /var/lib/prometheus/ --web.console.templates=/etc/prometheus/consoles --web.console.libraries=/etc/prometheus/console_libraries We should see a message like this: level=info ts=2021-04-16T19:02:20.167Z caller=main.go:380 msg=\"No time or size retention was set so using the default time retention\" duration=15d level=info ts=2021-04-16T19:02:20.167Z caller=main.go:418 msg=\"Starting Prometheus\" version=\"(version=2.26.0, branch=HEAD, revision=3cafc58827d1ebd1a67749f88be4218f0bab3d8d)\" level=info ts=2021-04-16T19:02:20.167Z caller=main.go:423 build_context=\"(go=go1.16.2, user=root@a67cafebe6d0, date=20210331-11:56:23)\" level=info ts=2021-04-16T19:02:20.167Z caller=main.go:424 host_details=\"(Linux 5.4.0-42-generic #46-Ubuntu SMP Fri Jul 10 00:24:02 UTC 2020 x86_64 ubuntu2004 (none))\" level=info ts=2021-04-16T19:02:20.167Z caller=main.go:425 fd_limits=\"(soft=1024, hard=1048576)\" level=info ts=2021-04-16T19:02:20.167Z caller=main.go:426 vm_limits=\"(soft=unlimited, hard=unlimited)\" level=info ts=2021-04-16T19:02:20.169Z caller=web.go:540 component=web msg=\"Start listening for connections\" address=0.0.0.0:9090 level=info ts=2021-04-16T19:02:20.170Z caller=main.go:795 msg=\"Starting TSDB ...\" level=info ts=2021-04-16T19:02:20.171Z caller=tls_config.go:191 component=web msg=\"TLS is disabled.\" http2=false level=info ts=2021-04-16T19:02:20.174Z caller=head.go:696 component=tsdb msg=\"Replaying on-disk memory mappable chunks if any\" level=info ts=2021-04-16T19:02:20.175Z caller=head.go:710 component=tsdb msg=\"On-disk memory mappable chunks replay completed\" duration=1.391446ms level=info ts=2021-04-16T19:02:20.175Z caller=head.go:716 component=tsdb msg=\"Replaying WAL, this may take a while\" level=info ts=2021-04-16T19:02:20.178Z caller=head.go:768 component=tsdb msg=\"WAL segment loaded\" segment=0 maxSegment=4 level=info ts=2021-04-16T19:02:20.193Z caller=head.go:768 component=tsdb msg=\"WAL segment loaded\" segment=1 maxSegment=4 level=info ts=2021-04-16T19:02:20.221Z caller=head.go:768 component=tsdb msg=\"WAL segment loaded\" segment=2 maxSegment=4 level=info ts=2021-04-16T19:02:20.224Z caller=head.go:768 component=tsdb msg=\"WAL segment loaded\" segment=3 maxSegment=4 level=info ts=2021-04-16T19:02:20.229Z caller=head.go:768 component=tsdb msg=\"WAL segment loaded\" segment=4 maxSegment=4 level=info ts=2021-04-16T19:02:20.229Z caller=head.go:773 component=tsdb msg=\"WAL replay completed\" checkpoint_replay_duration=43.716\u00b5s wal_replay_duration=53.973285ms total_replay_duration=55.445308ms level=info ts=2021-04-16T19:02:20.233Z caller=main.go:815 fs_type=EXT4_SUPER_MAGIC level=info ts=2021-04-16T19:02:20.233Z caller=main.go:818 msg=\"TSDB started\" level=info ts=2021-04-16T19:02:20.233Z caller=main.go:944 msg=\"Loading configuration file\" filename=/etc/prometheus/prometheus.yml level=info ts=2021-04-16T19:02:20.234Z caller=main.go:975 msg=\"Completed loading of configuration file\" filename=/etc/prometheus/prometheus.yml totalDuration=824.115\u00b5s remote_storage=3.131\u00b5s web_handler=401ns query_engine=1.056\u00b5s scrape=236.454\u00b5s scrape_sd=45.432\u00b5s notify=723ns notify_sd=2.61\u00b5s rules=956ns level=info ts=2021-04-16T19:02:20.234Z caller=main.go:767 msg=\"Server is ready to receive web requests.\" Now let's try to reach the graphical UI of our Prometheus server by opening the browser and opening the following URL: http:// SERVER_IP_ADDRESS :9090/graph We can also quickly verify if our Zukma node gets scraped by visiting the Status-> Targets page. If you can see it you can close the process on your VPS by hitting Ctrl + C Now that everything is running we want to automatically start the server during the boot process, so we have to create a new systemd configuration file with the following config: sudo nano /etc/systemd/system/prometheus.service [Unit] Description=Prometheus Monitoring Wants=network-online.target After=network-online.target [Service] User=prometheus Group=prometheus Type=simple ExecStart=/usr/local/bin/prometheus \\ --config.file /etc/prometheus/prometheus.yml \\ --storage.tsdb.path /var/lib/prometheus/ \\ --web.console.templates=/etc/prometheus/consoles \\ --web.console.libraries=/etc/prometheus/console_libraries ExecReload=/bin/kill -HUP $MAINPID [Install] WantedBy=multi-user.target After we saved the file, we want to reload systemd and enable the service so that it will be loaded automatically during the operating system's startup. sudo systemctl daemon-reload && systemctl enable prometheus && systemctl start prometheus Success Prometheus should be running now, and we should be able to access its front-end again by re-visiting IP_ADDRESS :9090/ . Step 2 - Install Node Exporter Now we will install Prometheus's Node Exporter module which exposes hardware metrics like CPU load, RAM and storage usage. Create Node Exporter User sudo useradd --no-create-home --shell /usr/sbin/nologin node_exporter Create the directories required to store the configuration and executable files: sudo mkdir /etc/node_exporter sudo mkdir /var/lib/node_exporter Change the ownership of those files to our Node_Exporter user sudo chown -R node_exporter:node_exporter /etc/node_exporter sudo chown -R prometheus:node_exporter /var/lib/node_exporter Install the latest version of Node Exporter from downloads page: wget https://github.com/prometheus/node_exporter/releases/download/v1.3.1/node_exporter-1.3.1.linux-amd64.tar.gz tar xvfz node_exporter-*.*-amd64.tar.gz Change directory into the downloaded file: cd node_exporter-*.*-amd64 Let's copy the binary node_exporter to our local binary folder /usr/local/bin/ sudo cp ./node_exporter /usr/local/bin/ Let's also change the ownership of the binary file: sudo chown node_exporter:node_exporter /usr/local/bin/node_exporter Now we can delete the downloaded node_exporter folder: cd .. && rm -rf node_exporter* Since the Node Exporter will run on port 9100 we need to allow that port on our firewall ufw allow 9100 Let's test-run the node_exporter: cd /usr/local/bin ./node_exporter We can now observe the exposed metrics in our browser at: http:// SERVER_IP_ADDRESS :9100/metrics After we confirmed that the node_exporter is running we can exit the process on our VPS by hitting Ctrl + C Now that everything is running we want to automatically start the node_exporter during the boot process, so we have to create a new systemd configuration file with the following config: sudo nano /etc/systemd/system/node_exporter.service [Unit] Description=Node Exporter Monitoring Wants=network-online.target After=network-online.target [Service] User=node_exporter Group=node_exporter Type=simple ExecStart=/usr/local/bin/node_exporter ExecReload=/bin/kill -HUP $MAINPID [Install] WantedBy=multi-user.target After we saved the file, we want to reload systemd and enable the service so that it will be loaded automatically during the operating system's startup. sudo systemctl daemon-reload && systemctl enable node_exporter && systemctl start node_exporter Finally, we must tell our Prometheus server to scrape the metrics exposed by the node_exporter . We do this by configuring the prometheus.yml file we created earlier. sudo nano /etc/prometheus/prometheus.yml global: scrape_interval: 15s evaluation_interval: 15s rule_files: # - \"first.rules\" # - \"second.rules\" scrape_configs: - job_name: \"prometheus\" scrape_interval: 5s static_configs: - targets: [\"localhost:9090\"] - job_name: \"Zukma_Node\" scrape_interval: 5s static_configs: - targets: [\"localhost:9615\"] - job_name: \"Node_Exporter\" scrape_interval: 5s static_configs: - targets: [\"localhost:9100\"] Now we need to reboot the VPS: reboot After the reboot we can revisit our Prometheus server at: http:// SERVER_IP_ADDRESS /targets You should see the following in your browser: Step 3 - Install Alert Manager In this section, let's configure the Alert Manager that notifies you if problems occour on your server. Alerts can be sent in Slack, Email, Matrix, or others. In this guide, we will configure an outage email alerting using Gmail. First, download the latest binary of Alert Manager and unzip it by running the command below: wget https://github.com/prometheus/alertmanager/releases/download/v0.23.0/alertmanager-0.23.0.linux-amd64.tar.gz tar xvfz alertmanager-*.*-amd64.tar.gz mv alertmanager-*.*-amd64/alertmanager /usr/local/bin/ Gmail Setup To allow Alert Manager to email you, you will need to generate something called an app password in your Gmail account. For details, click here to follow the whole setup. Hint Copy or save your app password! We need it soon. Alert Manager Configuration We will now create a new folder for the Alert Manager's config file: mkdir /etc/alertmanager Now need to create a new configuration file called alertmanager.yml under /etc/alertmanager sudo nano /etc/alertmanager/alertmanager.yml and specify the file as follows: global: resolve_timeout: 1m route: receiver: 'gmail-notifications' receivers: - name: 'gmail-notifications' email_configs: - to: YOUR_EMAIL from: YOUR_EMAIL smarthost: smtp.gmail.com:587 auth_username: YOUR_EMAIL auth_identity: YOUR_EMAIL auth_password: YOUR_APP_PASSWORD send_resolved: true Note With the above configuration, alerts will be sent using the email you set above. Remember to change YOUR_EMAIL to your email and paste the app password you just saved earlier to the YOUR_APP_PASSWORD . Now we change the ownership to our Prometheus user: sudo chown -R prometheus:prometheus /etc/alertmanager Now let's open another port on our firewall for the Alert Manager: ufw allow 9093 Next, we will create another systemd file to make sure that the alert manager will start every time the server reboots: sudo nano /etc/systemd/system/alertmanager.service [Unit] Description=AlertManager Server Service Wants=network-online.target After=network-online.target [Service] User=root Group=root Type=simple ExecStart=/usr/local/bin/alertmanager --config.file /etc/alertmanager/alertmanager.yml --web.external-url=http:// SERVER_IP :9093 --cluster.advertise-address='0.0.0.0:9093' [Install] WantedBy=multi-user.target Note SERVER_IP - Change it to your host IP address. Finally, we can start the Alert Manager with the following command: sudo systemctl daemon-reload && sudo systemctl enable alertmanager && sudo systemctl start alertmanager && sudo systemctl status alertmanager Note You should see: Active: active (running) Created symlink /etc/systemd/system/multi-user.target.wants/alertmanager.service \u2192 /etc/systemd/system/alertmanager.service. \u25cf alertmanager.service - AlertManager Server Service Loaded: loaded (/etc/systemd/system/alertmanager.service; enabled; vendor preset: enabled) Active: active (running) since Sun 2022-03-13 22:17:12 UTC; 12ms ago Main PID: 2484 (alertmanager) Tasks: 4 (limit: 9457) Memory: 948.0K CPU: 10ms Tip For now that's it, but we will need to install a Grafana Plug-In later in this process but let's first install Grafana. Hang on buddy we are done soon Step 4 - Install Grafana To visualize those metrics we will use Grafana. We run the following commands to install it: sudo apt-get install -y adduser libfontconfig1 wget https://dl.grafana.com/oss/release/grafana_8.4.3_amd64.deb sudo dpkg -i grafana_8.4.3_amd64.deb Now we will configure Grafana to autostart as well sudo systemctl daemon-reload sudo systemctl enable grafana-server sudo systemctl start grafana-server ufw allow 3000 Before we start to wire everything together, let's take care of the aforementioned alert manager plugin. It will help you to monitor the alert information. To install it, execute the command below: sudo grafana-cli plugins install camptocamp-prometheus-alertmanager-datasource and restart Grafana: sudo systemctl restart grafana-server Now we can access Grafana by going to http:// SERVER_IP_ADDRESS :3000/login`. The default user and password is admin/admin. Note If you want to change the port on which Grafana runs (3000 is a popular port), edit the file /usr/share/grafana/conf/defaults.ini with a command like sudo vim /usr/share/grafana/conf/defaults.ini and change the http_port value to something else. Then restart grafana with sudo systemctl restart grafana-server . Success We successfully installed and configured Prometheus, Node Exporter, Alert Manager and Grafana at this point Let's us wire it all together Now that everything is running we need to connect our Prometheus and alert manager data source to our Grafana server. We do this in the UI of Grafana by going to Data Sources The only thing we need to input is the URL that is https://localhost:9090 and then click Save & Test. If you see Data source is working, your connection is configured correctly. Success We connected our Prometheus database with Grafana! Now let's wire the Alert Manager similarly: Let's use our Zukma Template Dashboard For this guide we will use a customized Zukma Dashboard to monitor our node, but you can always start to customize or create your own Dashboards. Tip You can get the import code here: Grafana Labs . May also consider to give it a review Success There you go mate Written by Zukma Team","title":"Validator Monitoring"},{"location":"validator-guides/node-monitoring/#how-to-visualize-node-metrics","text":"This guide will teach you how to use Prometheus and Grafana to implement a basic validator monitoring. We can do this because every Zukma node exposes metrics such as the chain height, number of connected peers or the amount of memory used on a Prometheus metric endpoint. We will use Prometheus to collect the data and Grafana to visualize them on a nice looking dashboard.","title":"HOW TO VISUALIZE NODE METRICS"},{"location":"validator-guides/node-monitoring/#example-monitoring-architecture","text":"+--------------+ +-------------+ +---------+ | Zukma Node | | Prometheus | | Grafana | +--------------+ +-------------+ +---------+ | -----------------\\ | | | | Every 1 minute |-| | | |----------------| | | | | | | GET current metric values | | |<---------------------------------| | | | | | `substrate_peers_count 5` | | |--------------------------------->| | | | --------------------------------------------------------------------\\ | | |-| Save metric value with corresponding time stamp in local database | | | | |-------------------------------------------------------------------| | | | -------------------------------\\ | | | | Every time user opens graphs |-| | | |------------------------------| | | | | | | GET values of metric `substrate_peers_count` from time-X to time-Y | | |<-------------------------------------------------------------------------| | | | | | `substrate_peers_count (1582023828, 5), (1582023847, 4) [...]` | | |------------------------------------------------------------------------->| | | |","title":"Example Monitoring Architecture"},{"location":"validator-guides/node-monitoring/#step-1-install-prometheus-and-grafana","text":"To protect our node we will create a user for Prometheus but not allow Prometheus to log-in itself. We will then create the directories required to store the Prometheus config and executable file and then change the ownership of these directories to the Prometheus user so that only Prometheus can access them. Create Prometheus User: sudo useradd --no-create-home --shell /usr/sbin/nologin prometheus Create the directories required to store the configuration and executable files: sudo mkdir /etc/prometheus sudo mkdir /var/lib/prometheus Change the ownership of these directories to prometheus : sudo chown -R prometheus:prometheus /etc/prometheus sudo chown -R prometheus:prometheus /var/lib/prometheus","title":"Step 1 - Install Prometheus and Grafana"},{"location":"validator-guides/node-monitoring/#install-and-configure-prometheus","text":"After setting up the environment, update your OS, and install the latest Prometheus. You can check the latest release by visiting their downloads page. sudo apt-get update && apt-get upgrade wget https://github.com/prometheus/prometheus/releases/download/v2.33.5/prometheus-2.33.5.linux-amd64.tar.gz tar xfz prometheus-*.tar.gz Let's inspect the unzipped file we downloaded by changing directories: cd prometheus-2.33.5.linux-amd64 The following two binaries are in the directory: prometheus -> Prometheus main binary file promtool The following two directories (which contain the web interface, configuration files examples and the license) are in the directory: console console_libraries We want to copy the downloaded bin files and move it to our local folder for bin files /usr/local/bin/ sudo cp ./prometheus /usr/local/bin/ sudo cp ./promtool /usr/local/bin/ We also want to change the ownership of those file to our Prometheus user: sudo chown prometheus:prometheus /usr/local/bin/prometheus sudo chown prometheus:prometheus /usr/local/bin/promtool We also want to copy and move the consoles and console_libraries folders into our local folder /etc/prometheus sudo cp -r ./consoles /etc/prometheus sudo cp -r ./console_libraries /etc/prometheus We again want to change the ownership to our Prometheus user: sudo chown -R prometheus:prometheus /etc/prometheus/consoles sudo chown -R prometheus:prometheus /etc/prometheus/console_libraries Success Now we successfully moved all folders and binaries of the downloaded folder into the correct local folders and changed their ownership to our Prometheus user. Now we can safely delete the downloaded folder: cd .. && rm -rf prometheus*","title":"Install and Configure Prometheus"},{"location":"validator-guides/node-monitoring/#configure-prometheus","text":"Before Prometheus can be started, it needs some configuration. We will manage the configuration in a .yml file which we will create now: sudo nano /etc/prometheus/prometheus.yml The config file is divided into three parts: global rule_files scrape_configs scrape_interval defines how often Prometheus scrapes targets, while evaluation_interval controls how often the software will evaluate rules. rule files block contains information of the location of any rules we want the Prometheus server to load. scrape_configs contains the information which resources Prometheus monitors. Configure the file as following: global: scrape_interval: 15s evaluation_interval: 15s rule_files: # - \"first.rules\" # - \"second.rules\" scrape_configs: - job_name: \"prometheus\" scrape_interval: 5s static_configs: - targets: [\"localhost:9090\"] - job_name: \"Zukma_Node\" scrape_interval: 5s static_configs: - targets: [\"localhost:9615\"] Note Prometheus can manage multiple jobs. We currently have two jobs (Prometheus and Zukma_Node) and both are listening on localhost ports. You can also change the target address to an IP address of another node if you want to centralize all the data. With the above configuration file, the first exporter is the one that Prometheus exports to monitor itself. As we want to have more precise information about the state of the Prometheus server we reduced the scrape_interval to 5 seconds for this job. The parameters static_configs and targets determine where the exporters are running. The second exporter is capturing the data from our node, and the port by default is 9615. Let' check the validity of the configuration file by running sudo chown prometheus:prometheus /etc/prometheus/prometheus.yml And let's change the ownership of the config file to our Prometheus user: sudo chown prometheus:prometheus /etc/prometheus/prometheus.yml","title":"Configure Prometheus"},{"location":"validator-guides/node-monitoring/#start-prometheus","text":"Before we start Prometheus let's make sure that our firewall isn't blocking port 9090 ufw allow 9090 To test that Prometheus is set up properly we will execute a command to inspect the logs: Remember, we need to run this command as the Prometheus user due to the ownership of the files: sudo -u prometheus /usr/local/bin/prometheus --config.file /etc/prometheus/prometheus.yml --storage.tsdb.path /var/lib/prometheus/ --web.console.templates=/etc/prometheus/consoles --web.console.libraries=/etc/prometheus/console_libraries We should see a message like this: level=info ts=2021-04-16T19:02:20.167Z caller=main.go:380 msg=\"No time or size retention was set so using the default time retention\" duration=15d level=info ts=2021-04-16T19:02:20.167Z caller=main.go:418 msg=\"Starting Prometheus\" version=\"(version=2.26.0, branch=HEAD, revision=3cafc58827d1ebd1a67749f88be4218f0bab3d8d)\" level=info ts=2021-04-16T19:02:20.167Z caller=main.go:423 build_context=\"(go=go1.16.2, user=root@a67cafebe6d0, date=20210331-11:56:23)\" level=info ts=2021-04-16T19:02:20.167Z caller=main.go:424 host_details=\"(Linux 5.4.0-42-generic #46-Ubuntu SMP Fri Jul 10 00:24:02 UTC 2020 x86_64 ubuntu2004 (none))\" level=info ts=2021-04-16T19:02:20.167Z caller=main.go:425 fd_limits=\"(soft=1024, hard=1048576)\" level=info ts=2021-04-16T19:02:20.167Z caller=main.go:426 vm_limits=\"(soft=unlimited, hard=unlimited)\" level=info ts=2021-04-16T19:02:20.169Z caller=web.go:540 component=web msg=\"Start listening for connections\" address=0.0.0.0:9090 level=info ts=2021-04-16T19:02:20.170Z caller=main.go:795 msg=\"Starting TSDB ...\" level=info ts=2021-04-16T19:02:20.171Z caller=tls_config.go:191 component=web msg=\"TLS is disabled.\" http2=false level=info ts=2021-04-16T19:02:20.174Z caller=head.go:696 component=tsdb msg=\"Replaying on-disk memory mappable chunks if any\" level=info ts=2021-04-16T19:02:20.175Z caller=head.go:710 component=tsdb msg=\"On-disk memory mappable chunks replay completed\" duration=1.391446ms level=info ts=2021-04-16T19:02:20.175Z caller=head.go:716 component=tsdb msg=\"Replaying WAL, this may take a while\" level=info ts=2021-04-16T19:02:20.178Z caller=head.go:768 component=tsdb msg=\"WAL segment loaded\" segment=0 maxSegment=4 level=info ts=2021-04-16T19:02:20.193Z caller=head.go:768 component=tsdb msg=\"WAL segment loaded\" segment=1 maxSegment=4 level=info ts=2021-04-16T19:02:20.221Z caller=head.go:768 component=tsdb msg=\"WAL segment loaded\" segment=2 maxSegment=4 level=info ts=2021-04-16T19:02:20.224Z caller=head.go:768 component=tsdb msg=\"WAL segment loaded\" segment=3 maxSegment=4 level=info ts=2021-04-16T19:02:20.229Z caller=head.go:768 component=tsdb msg=\"WAL segment loaded\" segment=4 maxSegment=4 level=info ts=2021-04-16T19:02:20.229Z caller=head.go:773 component=tsdb msg=\"WAL replay completed\" checkpoint_replay_duration=43.716\u00b5s wal_replay_duration=53.973285ms total_replay_duration=55.445308ms level=info ts=2021-04-16T19:02:20.233Z caller=main.go:815 fs_type=EXT4_SUPER_MAGIC level=info ts=2021-04-16T19:02:20.233Z caller=main.go:818 msg=\"TSDB started\" level=info ts=2021-04-16T19:02:20.233Z caller=main.go:944 msg=\"Loading configuration file\" filename=/etc/prometheus/prometheus.yml level=info ts=2021-04-16T19:02:20.234Z caller=main.go:975 msg=\"Completed loading of configuration file\" filename=/etc/prometheus/prometheus.yml totalDuration=824.115\u00b5s remote_storage=3.131\u00b5s web_handler=401ns query_engine=1.056\u00b5s scrape=236.454\u00b5s scrape_sd=45.432\u00b5s notify=723ns notify_sd=2.61\u00b5s rules=956ns level=info ts=2021-04-16T19:02:20.234Z caller=main.go:767 msg=\"Server is ready to receive web requests.\" Now let's try to reach the graphical UI of our Prometheus server by opening the browser and opening the following URL: http:// SERVER_IP_ADDRESS :9090/graph We can also quickly verify if our Zukma node gets scraped by visiting the Status-> Targets page. If you can see it you can close the process on your VPS by hitting Ctrl + C Now that everything is running we want to automatically start the server during the boot process, so we have to create a new systemd configuration file with the following config: sudo nano /etc/systemd/system/prometheus.service [Unit] Description=Prometheus Monitoring Wants=network-online.target After=network-online.target [Service] User=prometheus Group=prometheus Type=simple ExecStart=/usr/local/bin/prometheus \\ --config.file /etc/prometheus/prometheus.yml \\ --storage.tsdb.path /var/lib/prometheus/ \\ --web.console.templates=/etc/prometheus/consoles \\ --web.console.libraries=/etc/prometheus/console_libraries ExecReload=/bin/kill -HUP $MAINPID [Install] WantedBy=multi-user.target After we saved the file, we want to reload systemd and enable the service so that it will be loaded automatically during the operating system's startup. sudo systemctl daemon-reload && systemctl enable prometheus && systemctl start prometheus Success Prometheus should be running now, and we should be able to access its front-end again by re-visiting IP_ADDRESS :9090/ .","title":"Start Prometheus"},{"location":"validator-guides/node-monitoring/#step-2-install-node-exporter","text":"Now we will install Prometheus's Node Exporter module which exposes hardware metrics like CPU load, RAM and storage usage. Create Node Exporter User sudo useradd --no-create-home --shell /usr/sbin/nologin node_exporter Create the directories required to store the configuration and executable files: sudo mkdir /etc/node_exporter sudo mkdir /var/lib/node_exporter Change the ownership of those files to our Node_Exporter user sudo chown -R node_exporter:node_exporter /etc/node_exporter sudo chown -R prometheus:node_exporter /var/lib/node_exporter Install the latest version of Node Exporter from downloads page: wget https://github.com/prometheus/node_exporter/releases/download/v1.3.1/node_exporter-1.3.1.linux-amd64.tar.gz tar xvfz node_exporter-*.*-amd64.tar.gz Change directory into the downloaded file: cd node_exporter-*.*-amd64 Let's copy the binary node_exporter to our local binary folder /usr/local/bin/ sudo cp ./node_exporter /usr/local/bin/ Let's also change the ownership of the binary file: sudo chown node_exporter:node_exporter /usr/local/bin/node_exporter Now we can delete the downloaded node_exporter folder: cd .. && rm -rf node_exporter* Since the Node Exporter will run on port 9100 we need to allow that port on our firewall ufw allow 9100 Let's test-run the node_exporter: cd /usr/local/bin ./node_exporter We can now observe the exposed metrics in our browser at: http:// SERVER_IP_ADDRESS :9100/metrics After we confirmed that the node_exporter is running we can exit the process on our VPS by hitting Ctrl + C Now that everything is running we want to automatically start the node_exporter during the boot process, so we have to create a new systemd configuration file with the following config: sudo nano /etc/systemd/system/node_exporter.service [Unit] Description=Node Exporter Monitoring Wants=network-online.target After=network-online.target [Service] User=node_exporter Group=node_exporter Type=simple ExecStart=/usr/local/bin/node_exporter ExecReload=/bin/kill -HUP $MAINPID [Install] WantedBy=multi-user.target After we saved the file, we want to reload systemd and enable the service so that it will be loaded automatically during the operating system's startup. sudo systemctl daemon-reload && systemctl enable node_exporter && systemctl start node_exporter Finally, we must tell our Prometheus server to scrape the metrics exposed by the node_exporter . We do this by configuring the prometheus.yml file we created earlier. sudo nano /etc/prometheus/prometheus.yml global: scrape_interval: 15s evaluation_interval: 15s rule_files: # - \"first.rules\" # - \"second.rules\" scrape_configs: - job_name: \"prometheus\" scrape_interval: 5s static_configs: - targets: [\"localhost:9090\"] - job_name: \"Zukma_Node\" scrape_interval: 5s static_configs: - targets: [\"localhost:9615\"] - job_name: \"Node_Exporter\" scrape_interval: 5s static_configs: - targets: [\"localhost:9100\"] Now we need to reboot the VPS: reboot After the reboot we can revisit our Prometheus server at: http:// SERVER_IP_ADDRESS /targets You should see the following in your browser:","title":"Step 2 - Install Node Exporter"},{"location":"validator-guides/node-monitoring/#step-3-install-alert-manager","text":"In this section, let's configure the Alert Manager that notifies you if problems occour on your server. Alerts can be sent in Slack, Email, Matrix, or others. In this guide, we will configure an outage email alerting using Gmail. First, download the latest binary of Alert Manager and unzip it by running the command below: wget https://github.com/prometheus/alertmanager/releases/download/v0.23.0/alertmanager-0.23.0.linux-amd64.tar.gz tar xvfz alertmanager-*.*-amd64.tar.gz mv alertmanager-*.*-amd64/alertmanager /usr/local/bin/","title":"Step 3 - Install Alert Manager"},{"location":"validator-guides/node-monitoring/#gmail-setup","text":"To allow Alert Manager to email you, you will need to generate something called an app password in your Gmail account. For details, click here to follow the whole setup. Hint Copy or save your app password! We need it soon.","title":"Gmail Setup"},{"location":"validator-guides/node-monitoring/#alert-manager-configuration","text":"We will now create a new folder for the Alert Manager's config file: mkdir /etc/alertmanager Now need to create a new configuration file called alertmanager.yml under /etc/alertmanager sudo nano /etc/alertmanager/alertmanager.yml and specify the file as follows: global: resolve_timeout: 1m route: receiver: 'gmail-notifications' receivers: - name: 'gmail-notifications' email_configs: - to: YOUR_EMAIL from: YOUR_EMAIL smarthost: smtp.gmail.com:587 auth_username: YOUR_EMAIL auth_identity: YOUR_EMAIL auth_password: YOUR_APP_PASSWORD send_resolved: true Note With the above configuration, alerts will be sent using the email you set above. Remember to change YOUR_EMAIL to your email and paste the app password you just saved earlier to the YOUR_APP_PASSWORD . Now we change the ownership to our Prometheus user: sudo chown -R prometheus:prometheus /etc/alertmanager Now let's open another port on our firewall for the Alert Manager: ufw allow 9093 Next, we will create another systemd file to make sure that the alert manager will start every time the server reboots: sudo nano /etc/systemd/system/alertmanager.service [Unit] Description=AlertManager Server Service Wants=network-online.target After=network-online.target [Service] User=root Group=root Type=simple ExecStart=/usr/local/bin/alertmanager --config.file /etc/alertmanager/alertmanager.yml --web.external-url=http:// SERVER_IP :9093 --cluster.advertise-address='0.0.0.0:9093' [Install] WantedBy=multi-user.target Note SERVER_IP - Change it to your host IP address. Finally, we can start the Alert Manager with the following command: sudo systemctl daemon-reload && sudo systemctl enable alertmanager && sudo systemctl start alertmanager && sudo systemctl status alertmanager Note You should see: Active: active (running) Created symlink /etc/systemd/system/multi-user.target.wants/alertmanager.service \u2192 /etc/systemd/system/alertmanager.service. \u25cf alertmanager.service - AlertManager Server Service Loaded: loaded (/etc/systemd/system/alertmanager.service; enabled; vendor preset: enabled) Active: active (running) since Sun 2022-03-13 22:17:12 UTC; 12ms ago Main PID: 2484 (alertmanager) Tasks: 4 (limit: 9457) Memory: 948.0K CPU: 10ms Tip For now that's it, but we will need to install a Grafana Plug-In later in this process but let's first install Grafana. Hang on buddy we are done soon","title":"Alert Manager Configuration"},{"location":"validator-guides/node-monitoring/#step-4-install-grafana","text":"To visualize those metrics we will use Grafana. We run the following commands to install it: sudo apt-get install -y adduser libfontconfig1 wget https://dl.grafana.com/oss/release/grafana_8.4.3_amd64.deb sudo dpkg -i grafana_8.4.3_amd64.deb Now we will configure Grafana to autostart as well sudo systemctl daemon-reload sudo systemctl enable grafana-server sudo systemctl start grafana-server ufw allow 3000 Before we start to wire everything together, let's take care of the aforementioned alert manager plugin. It will help you to monitor the alert information. To install it, execute the command below: sudo grafana-cli plugins install camptocamp-prometheus-alertmanager-datasource and restart Grafana: sudo systemctl restart grafana-server Now we can access Grafana by going to http:// SERVER_IP_ADDRESS :3000/login`. The default user and password is admin/admin. Note If you want to change the port on which Grafana runs (3000 is a popular port), edit the file /usr/share/grafana/conf/defaults.ini with a command like sudo vim /usr/share/grafana/conf/defaults.ini and change the http_port value to something else. Then restart grafana with sudo systemctl restart grafana-server . Success We successfully installed and configured Prometheus, Node Exporter, Alert Manager and Grafana at this point","title":"Step 4 - Install Grafana"},{"location":"validator-guides/node-monitoring/#lets-us-wire-it-all-together","text":"Now that everything is running we need to connect our Prometheus and alert manager data source to our Grafana server. We do this in the UI of Grafana by going to Data Sources The only thing we need to input is the URL that is https://localhost:9090 and then click Save & Test. If you see Data source is working, your connection is configured correctly. Success We connected our Prometheus database with Grafana! Now let's wire the Alert Manager similarly:","title":"Let's us wire it all together"},{"location":"validator-guides/node-monitoring/#lets-use-our-zukma-template-dashboard","text":"For this guide we will use a customized Zukma Dashboard to monitor our node, but you can always start to customize or create your own Dashboards. Tip You can get the import code here: Grafana Labs . May also consider to give it a review Success There you go mate Written by Zukma Team","title":"Let's use our Zukma Template Dashboard"},{"location":"validator-guides/secure-validator/","text":"SECURE YOUR VALIDATOR Validators in a Proof of Stake network are responsible for keeping the network in consensus and verifying state transitions. As the number of validators is limited, validators in the set are responsible for being online and faithfully executing their tasks. This primarily means that validators: - Must be highly available. - Must stay honest - Must have infrastructure that protects the validator's signing keys so that an attacker cannot take control and commit slashable behavior. High Availability A typical technique that promises high availability is to the setup multiple replicas of a node on different servers. The idea is if the active validator's server goes down, many exact copies are ready and can pick up the work with zero downtime. Although such a setup may seem attractive at first glance, they are dangerous if not set up perfectly. This is because all inactive nodes, waiting on the sideline, must potentially use the exact same session key to continue the exact same work of the failed active validator. However, you should always isolate the session keys used by you to just a single node. Replicating session keys across multiple nodes could lead to equivocation slashes. Those slashes can make you lose significant amounts of your staked funds. The good news is that 100% uptime of your validator is not needed, as it has some buffer within eras to go offline for a bit of while and upgrade. For this reason, we advise that you only attempt a high availability setup if you're confident you know exactly what you're doing. Many expert validators on other substrate based networks have made mistakes in the past due to bad handling of their session keys. Remember, even if your validator goes offline for some time, the offline slash is much more forgiving than the equivocation slash. Read more on slashes in the staking deep-dive. Key Management The keys that are of primary concern for validator infrastructure are the Session keys. These keys sign messages related to consensus. Although Session keys are not account keys and therefore cannot transfer funds, an attacker could use them to commit slashable behavior. Session keys are generated inside the node via RPC call. Session keys should be generated and kept within your client. When you generate new Session keys, you must submit an extrinsic (a Session certificate) from your Controller key telling the chain your new Session keys. Note Session keys can also be generated outside the client and inserted into the client's keystore via RPC. For most users, we recommend using the key generation functionality within the client. Monitoring Tools Telemetry UI This tracks your node details including the version you are running, block height, CPU & memory usage, block propagation time, etc. Prometheus-based monitoring stack, including Grafana for dashboards and log aggregation. It includes alerting, querying, visualization, and monitoring features and works for both cloud and on-premise systems. The data from substrate-telemetry can be made available to Prometheus through exporters like this . Linux Best Practices Never use the root user. Always update the security patches for your OS. Enable and set up a firewall. Never allow password-based SSH, only use key-based access. Disable non-essential SSH subsystems (banner, motd, scp, X11 forwarding) and harden your SSH configuration ( reasonable guide to begin with ). Back up your storage regularly. Conclusions Validators should only run the Zukma Network/Zukma binary, and they should not listen on any port other than the configured p2p port. Validators should run on bare-metal machines, as opposed to VMs. This will prevent some of the availability issues with cloud providers, along with potential attacks from other VMs on the same hardware. The provisioning of the validator machine should be automated and defined in code. This code should be kept in private version control, reviewed, audited, and tested. Session keys should be generated and provided in a secure way. Zukma Network should be started at boot and restarted if stopped for any reason. Zukma Network should run as a non-root user. Recommended Reads Certus One's Knowledge Base Written by Zukma Team","title":"Secure your Validator"},{"location":"validator-guides/secure-validator/#secure-your-validator","text":"Validators in a Proof of Stake network are responsible for keeping the network in consensus and verifying state transitions. As the number of validators is limited, validators in the set are responsible for being online and faithfully executing their tasks. This primarily means that validators: - Must be highly available. - Must stay honest - Must have infrastructure that protects the validator's signing keys so that an attacker cannot take control and commit slashable behavior.","title":"SECURE YOUR VALIDATOR"},{"location":"validator-guides/secure-validator/#high-availability","text":"A typical technique that promises high availability is to the setup multiple replicas of a node on different servers. The idea is if the active validator's server goes down, many exact copies are ready and can pick up the work with zero downtime. Although such a setup may seem attractive at first glance, they are dangerous if not set up perfectly. This is because all inactive nodes, waiting on the sideline, must potentially use the exact same session key to continue the exact same work of the failed active validator. However, you should always isolate the session keys used by you to just a single node. Replicating session keys across multiple nodes could lead to equivocation slashes. Those slashes can make you lose significant amounts of your staked funds. The good news is that 100% uptime of your validator is not needed, as it has some buffer within eras to go offline for a bit of while and upgrade. For this reason, we advise that you only attempt a high availability setup if you're confident you know exactly what you're doing. Many expert validators on other substrate based networks have made mistakes in the past due to bad handling of their session keys. Remember, even if your validator goes offline for some time, the offline slash is much more forgiving than the equivocation slash. Read more on slashes in the staking deep-dive.","title":"High Availability"},{"location":"validator-guides/secure-validator/#key-management","text":"The keys that are of primary concern for validator infrastructure are the Session keys. These keys sign messages related to consensus. Although Session keys are not account keys and therefore cannot transfer funds, an attacker could use them to commit slashable behavior. Session keys are generated inside the node via RPC call. Session keys should be generated and kept within your client. When you generate new Session keys, you must submit an extrinsic (a Session certificate) from your Controller key telling the chain your new Session keys. Note Session keys can also be generated outside the client and inserted into the client's keystore via RPC. For most users, we recommend using the key generation functionality within the client.","title":"Key Management"},{"location":"validator-guides/secure-validator/#monitoring-tools","text":"Telemetry UI This tracks your node details including the version you are running, block height, CPU & memory usage, block propagation time, etc. Prometheus-based monitoring stack, including Grafana for dashboards and log aggregation. It includes alerting, querying, visualization, and monitoring features and works for both cloud and on-premise systems. The data from substrate-telemetry can be made available to Prometheus through exporters like this .","title":"Monitoring Tools"},{"location":"validator-guides/secure-validator/#linux-best-practices","text":"Never use the root user. Always update the security patches for your OS. Enable and set up a firewall. Never allow password-based SSH, only use key-based access. Disable non-essential SSH subsystems (banner, motd, scp, X11 forwarding) and harden your SSH configuration ( reasonable guide to begin with ). Back up your storage regularly.","title":"Linux Best Practices"},{"location":"validator-guides/secure-validator/#conclusions","text":"Validators should only run the Zukma Network/Zukma binary, and they should not listen on any port other than the configured p2p port. Validators should run on bare-metal machines, as opposed to VMs. This will prevent some of the availability issues with cloud providers, along with potential attacks from other VMs on the same hardware. The provisioning of the validator machine should be automated and defined in code. This code should be kept in private version control, reviewed, audited, and tested. Session keys should be generated and provided in a secure way. Zukma Network should be started at boot and restarted if stopped for any reason. Zukma Network should run as a non-root user.","title":"Conclusions"},{"location":"validator-guides/secure-validator/#recommended-reads","text":"Certus One's Knowledge Base Written by Zukma Team","title":"Recommended Reads"},{"location":"validator-guides/stop-validating/","text":"HOW TO STOP VALIDATING Warning Work in progress .","title":"Stop Validating"},{"location":"validator-guides/stop-validating/#how-to-stop-validating","text":"Warning Work in progress .","title":"HOW TO STOP VALIDATING"},{"location":"validator-guides/update-binaries/","text":"HOW TO UPDATE VALIDATOR BINARIES The following guide will teach you how to conduct a binary update for your validator. Binary updates are rare Zukma but essential from time to time to ensure that your validator can participate in the consensus mechanism and is able to function properly. Learn more about the reasons behind this update in the following section. Why is this update needed? (Announcement) Quote The anticipated launch of Exchange Swap on our Network has made a significant step forward. Today we like to inform you that the dev teams have made fantastic progress in the background, testing, and innovating on the Zukma Network. One outcome of the rigorous testing on Zukma was a significant improvement in our blockchain's underlying technology, namely the p2p network communication layer. The dev teams managed to enhance the standard substrate module to unleash the full potential of Exchange Swap on our EVM. So what does this mean for you? Well, this improvement renders us even more unique than other projects that simply adapt the substrate framework, and for our validator community, there is now some action to do. Since the P2P network layer is not part of the runtime, it cannot be updated automatically, meaning you need to download and install a new binary. This is not a fork because the old binaries will still work. However, the moment we update the runtime forklessly, your validators will have trouble interfacing with the new p2p network technology and won't be able to author blocks. To address any potential concerns, they won't suffer any slash penalties if they are not updated, but they will need to be updated to continue to author blocks. We shall release step-by-step instructions on how to update your validators accordingly, but for now, we would like to take the time to appreciate the outstanding efforts of our partners and development team. The Process Warning Make sure to update your OS to Ubuntu 21.10 since the new binaries are compiled for that Ubuntu version. You can follow our online guide to conduct the OS update. Other OS versions might work as well but are under your own risk. Step 1 - Pause / Chill your Validator Visit the substrate portal and navigate to the staking tab and select accounts. Click the Stop Button and sign the transaction accordingly. After the transaction was signed you should see the following validation screen. Success You successfully paused / chilled your validator and can proceed to step 2 Step 2 - Purge current Session Keys Navigate to the Developer Tab and select Extrinsic then select your controller account and the session pallet in the dropdown menu. The session pallet offers two extrinsics: PurgeKeys() SetKeys() Select PurgeKeys() and click hit Submit Transaction. Success You successfully purged your current session keys and can proceed to step 3 Step 3 - Execute Update Command on your Server Login to your server as root. Warning The following command will clean and delete the current binary and download and install a new but specific binary. If you are not sure about the version of your binary pls reach out to our validator community on Discord . service Zukma stop && wget https://download2.zukma.io/zukma/zukma_ubuntu_21_10-zukma-polkadot-v0.9.18-bdfbeb9e-980 && chmod 777 zukma_ubuntu_21_10-zukma-polkadot-v0.9.18-bdfbeb9e-980 && mv zukma_ubuntu_21_10-Zukma-polkadot-v0.9.18-bdfbeb9e-980 /usr/bin/zukma -f && runuser -l zukma -c 'zukma purge-chain --chain zukma -y' Success You successfully deleted and cleared your old binary and installed the new binary Step 4 - Start Validator Service on your Server Execute the following command to start your validator and the sync process. service zukma start && journalctl -f -u zukma Success You successfully started the new binary Since we cleared / purged the old binaries' data your validator need to download the full database / blocks again. This sync process should not take long thanks to the improvements in the P2P Network Layer. However, make sure to fully sync your validator before you restart your validator on the substrate portal. If your validator is not in sync, and you get elected to the active set you will miss opportunities to author blocks and might get chilled as a consequence. You can observe the progress either in the logs or on our telemetry UI : Telemetry UI Success You successfully completed step 4 Step 5 - Generate new Session Keys Login to your VPS server. Session keys are needed to associate your node with your controller account. To generate the session keys you can run the following command in your terminal: Hint Hit Ctrl + C To exit the logs showing up on your server curl -H \"Content-Type: application/json\" -d '{\"id\":1, \"jsonrpc\":\"2.0\", \"method\": \"author_rotateKeys\", \"params\":[]}' http://localhost:9933 The output will have a hex-encoded \"result\" field. The result is the concatenation of the four public keys. Save this result for a later step. Copy the session key. It will look like this: 0x13660593581b2e728ee32122636f8996c6fd9c22f33beaa05e2797899c5458b0c888149bf3c0b5ca7fb7296e69fefd85e4e3d5b76848db890207575e49031f37d846e78babf8051c123b498ffe6f12e712f97f6b2f3b54345ffe51145a16bb22187d415c2101b9883668ce93c46f7ba556b394c59781854737b6c941747c0964 Success You successfully generated your new session keys Step 6 - Restart Validator on Substrate Portal Visit the substrate portal and navigate to the staking tab and select accounts. Click the Session Key button and enter your key from the previous step. Finally, set Session Keys and sign the transaction and your validator should join the active set without any issues. Finally, click validate and set your validator preferences. Keep in mind that some users may nominate you because of your commission settings, so it's recommended to keep the former commission settings or inform your nominators that you plan to change the percentage. Success You successfully finished the update process. Congrats mate! Written by Zukma Team","title":"Update Binaries"},{"location":"validator-guides/update-binaries/#how-to-update-validator-binaries","text":"The following guide will teach you how to conduct a binary update for your validator. Binary updates are rare Zukma but essential from time to time to ensure that your validator can participate in the consensus mechanism and is able to function properly. Learn more about the reasons behind this update in the following section.","title":"HOW TO UPDATE VALIDATOR BINARIES"},{"location":"validator-guides/update-binaries/#why-is-this-update-needed-announcement","text":"Quote The anticipated launch of Exchange Swap on our Network has made a significant step forward. Today we like to inform you that the dev teams have made fantastic progress in the background, testing, and innovating on the Zukma Network. One outcome of the rigorous testing on Zukma was a significant improvement in our blockchain's underlying technology, namely the p2p network communication layer. The dev teams managed to enhance the standard substrate module to unleash the full potential of Exchange Swap on our EVM. So what does this mean for you? Well, this improvement renders us even more unique than other projects that simply adapt the substrate framework, and for our validator community, there is now some action to do. Since the P2P network layer is not part of the runtime, it cannot be updated automatically, meaning you need to download and install a new binary. This is not a fork because the old binaries will still work. However, the moment we update the runtime forklessly, your validators will have trouble interfacing with the new p2p network technology and won't be able to author blocks. To address any potential concerns, they won't suffer any slash penalties if they are not updated, but they will need to be updated to continue to author blocks. We shall release step-by-step instructions on how to update your validators accordingly, but for now, we would like to take the time to appreciate the outstanding efforts of our partners and development team.","title":"Why is this update needed? (Announcement)"},{"location":"validator-guides/update-binaries/#the-process","text":"Warning Make sure to update your OS to Ubuntu 21.10 since the new binaries are compiled for that Ubuntu version. You can follow our online guide to conduct the OS update. Other OS versions might work as well but are under your own risk.","title":"The Process"},{"location":"validator-guides/update-binaries/#step-1-pause-chill-your-validator","text":"Visit the substrate portal and navigate to the staking tab and select accounts. Click the Stop Button and sign the transaction accordingly. After the transaction was signed you should see the following validation screen. Success You successfully paused / chilled your validator and can proceed to step 2","title":"Step 1 - Pause / Chill your Validator"},{"location":"validator-guides/update-binaries/#step-2-purge-current-session-keys","text":"Navigate to the Developer Tab and select Extrinsic then select your controller account and the session pallet in the dropdown menu. The session pallet offers two extrinsics: PurgeKeys() SetKeys() Select PurgeKeys() and click hit Submit Transaction. Success You successfully purged your current session keys and can proceed to step 3","title":"Step 2 - Purge current Session Keys"},{"location":"validator-guides/update-binaries/#step-3-execute-update-command-on-your-server","text":"Login to your server as root. Warning The following command will clean and delete the current binary and download and install a new but specific binary. If you are not sure about the version of your binary pls reach out to our validator community on Discord . service Zukma stop && wget https://download2.zukma.io/zukma/zukma_ubuntu_21_10-zukma-polkadot-v0.9.18-bdfbeb9e-980 && chmod 777 zukma_ubuntu_21_10-zukma-polkadot-v0.9.18-bdfbeb9e-980 && mv zukma_ubuntu_21_10-Zukma-polkadot-v0.9.18-bdfbeb9e-980 /usr/bin/zukma -f && runuser -l zukma -c 'zukma purge-chain --chain zukma -y' Success You successfully deleted and cleared your old binary and installed the new binary","title":"Step 3 - Execute Update Command on your Server"},{"location":"validator-guides/update-binaries/#step-4-start-validator-service-on-your-server","text":"Execute the following command to start your validator and the sync process. service zukma start && journalctl -f -u zukma Success You successfully started the new binary Since we cleared / purged the old binaries' data your validator need to download the full database / blocks again. This sync process should not take long thanks to the improvements in the P2P Network Layer. However, make sure to fully sync your validator before you restart your validator on the substrate portal. If your validator is not in sync, and you get elected to the active set you will miss opportunities to author blocks and might get chilled as a consequence. You can observe the progress either in the logs or on our telemetry UI : Telemetry UI Success You successfully completed step 4","title":"Step 4 - Start Validator Service on your Server"},{"location":"validator-guides/update-binaries/#step-5-generate-new-session-keys","text":"Login to your VPS server. Session keys are needed to associate your node with your controller account. To generate the session keys you can run the following command in your terminal: Hint Hit Ctrl + C To exit the logs showing up on your server curl -H \"Content-Type: application/json\" -d '{\"id\":1, \"jsonrpc\":\"2.0\", \"method\": \"author_rotateKeys\", \"params\":[]}' http://localhost:9933 The output will have a hex-encoded \"result\" field. The result is the concatenation of the four public keys. Save this result for a later step. Copy the session key. It will look like this: 0x13660593581b2e728ee32122636f8996c6fd9c22f33beaa05e2797899c5458b0c888149bf3c0b5ca7fb7296e69fefd85e4e3d5b76848db890207575e49031f37d846e78babf8051c123b498ffe6f12e712f97f6b2f3b54345ffe51145a16bb22187d415c2101b9883668ce93c46f7ba556b394c59781854737b6c941747c0964 Success You successfully generated your new session keys","title":"Step 5 - Generate new Session Keys"},{"location":"validator-guides/update-binaries/#step-6-restart-validator-on-substrate-portal","text":"Visit the substrate portal and navigate to the staking tab and select accounts. Click the Session Key button and enter your key from the previous step. Finally, set Session Keys and sign the transaction and your validator should join the active set without any issues. Finally, click validate and set your validator preferences. Keep in mind that some users may nominate you because of your commission settings, so it's recommended to keep the former commission settings or inform your nominators that you plan to change the percentage. Success You successfully finished the update process. Congrats mate! Written by Zukma Team","title":"Step 6 - Restart Validator on Substrate Portal"},{"location":"validator-guides/validator-payout-overview/","text":"VALIDATOR PAYOUT OVERVIEW Era Points For every era (a period of time), validators are paid proportionally to the amount of era points they have collected. Era points are reward points earned for payable actions like: producing a block in the Chain. producing a reference to a previously unreferenced uncle block. producing a referenced uncle block. Note An uncle block is a Chain block that is valid in every regard but fails to become canonical/standard. This can happen when two or more validators produce two different blocks nearly simultaneously. Both blocks are valid productions and could act as an accurate reference for the next block producer. However, the chain decides on a strain of blocks that carry the most weight. The block that was valid but was discarded from the canon is called an uncle block. Since uncles are proper productions, the creation of uncles is getting rewarded. Payments occur at the end of every era. Payout Scheme No matter how much total stake is behind a validator, all validators split the block-authoring payout equally. However, the payout of a specific validator may differ based on era points, as described above. Although there is a probabilistic component to receiving era points, and they may be impacted slightly depending on factors such as network connectivity, well-behaving validators should generally average out to having similar era point totals over a large number of eras. Validators may also receive \"tips\" from senders as an incentive to include transactions in their produced blocks. Validators will receive 100% of these tips directly. Validators will receive staking rewards in the form of the native coins of that chain (ZEP for Zukma Network). For simplicity, the examples below will assume all validators have the same amount of era points, and received no tips. Validator Set Size (v): 4 ACTIVE SET Validator 1 Stake (v1): 18 coins Validator 2 Stake (v2): 9 coins Validator 3 Stake (v3): 8 coins Validator 4 Stake (v4): 7 coins PAYOUT END OF THE ERA Payout (p): 8 ZEP PAYOUT CALCULATION Payout for each validator (v1 to v4): Payout = p / v = 8 / 4 = 2 ZEP per validator in the active set Note that this is different than most other Proof-of-Stake systems such as Cosmos. As long as a validator is in the validator set, it will receive the same block reward as every other validator. Validator v1, who had 18 coins staked, received the same reward (2 coins) in this era as v4, with only seven tokens staked. Running Multiple Validators A single entity can run multiple validators. Running multiple validators may provide a better risk/reward ratio. Assuming you have enough ZEP, or enough stake nominates your validator to ensure that your validators remain in the validator set, running multiple validators will result in a higher return than running a single validator. For the following example, assume you have 18 ZEP to stake. For simplicity's sake, we will ignore nominators. As in the example above, running a single validator would net you 2 ZEP in this era. Note that while ZEP is used as an example, this same formula would apply to ZEP when running a validator on Zukma Network Validator Set Size (v): 4 ACTIVE SET Validator 1 Stake (v1): 18 coins <- YOUR VALIDATOR Validator 2 Stake (v2): 9 coins Validator 3 Stake (v3): 8 coins Validator 4 Stake (v4): 7 coins PAYOUT END OF THE ERA Payout (p): 8 ZEP PAYOUT CALCULATION Your Payout = p / v = 8 / 4 = 2 ZEP Running two validators, and splitting the stake equally, would result in the original validator v4 being kicked out of the validator set, as only the top v validators (as measured by stake) are selected to be in the validator set. More important, it would also double the reward that you get from each era. Validator Set Size (v): 4 ACTIVE SET Validator 1 Stake (v1): 9 coins <- YOUR FIRST VALIDATOR Validator 2 Stake (v2): 9 coins <- YOUR SECOND VALIDATOR Validator 3 Stake (v3): 9 coins Validator 4 Stake (v4): 8 coins PAYOUT END OF ERA Payout (p): 8 ZEP Your payout = (p / v) * 2 = (8 / 4) * 2 = 4 ZEP With enough stake, you could run more than two validators. However, each validator must have enough stake behind it to be in the validator set. The system is designed to favor equally-staked validators. This works out to be a dynamic, rather than static, equilibrium. Potential validators will run different numbers of validators and apply different amounts of stake to them as time goes on and in response to the actions of other validators on the network. Slashing Although the system pays rewards equally, slashes are relative to a validator's stake. Therefore, if you do have enough ZEP to run multiple validators, it is in your best interest to do so. Of course, a slash of 30% will be more ZEP for a validator with 18 ZEP staked than one with 9 ZEP staked. Running multiple validators does not absolve you of the consequences of misbehavior. The network punishes attacks that appear coordinated more severely than individual attacks. You should not, for example, run multiple validators hosted on the same infrastructure. A proper multi-validator configuration would ensure that they do not fail simultaneously. Nominators have the incentive to nominate the lowest-staked validator, as this will result in the lowest risk and highest reward. This is because while their vulnerability to slashing remains the same (since it is percentage-based), their rewards are higher since they will be a higher proportion of the total stake allocated to that validator. To clarify this, let us imagine two validators, JOHN and BOBBY. Assume both are in the active set, have commission set to 0%, and are well-behaved. The only difference is that BOBBY has 90 ZEP nominating it and JOHN only has 10. If you nominate BOBBY, it now has 90 + 10 = 100 ZEP, and you will get 10% of the staking rewards for the next era. If you nominate JOHN, it now has 10 + 10 = 20 ZEP nominating it, and you will get 50% of the staking rewards for the next era. In actuality, it would be pretty rare to see such a significant difference between the stake of validators, but the same principle holds even for more minor differences. If there is a 10% slash of either validator, you will lose 1 ZEP in each case. Nominators and Validator Payments Nominated stake allows you to \"vote\" for validators and share in the rewards (and slashing) without running a validator node yourself. Validators can choose to keep a percentage of the rewards due to their validator to \"reimburse\" themselves for the cost of running a validator node. Other than that, all rewards are shared based on the stake behind each validator. This includes the stake of the validator itself, plus any stake bonded by nominators. Note Validators set their preference as a percentage of the block reward, not an absolute number of ZEP. The block rewards are based on the total amount at stake, with the reward peaking when the amount staked is at 50% of the total supply. The commission is set as the amount taken by the validator; that is, 0% commission means that the validator does not receive any proportion of the rewards besides that owed to it from self-stake, and 100% commission means that the validator operator gets all rewards and gives none to its nominators. The following examples show the results of several different validator payment schemes and the split between nominator and validator stake. We will assume a single nominator for each validator. However, there can be numerous nominators for each validator. Rewards are still distributed proportionally - for example, if the total rewards to be given to nominators is 2 ZEP, and there are four nominators with equal stake bonded, each will receive 0.5 ZEP. Note also that a single nominator may stake different validators. Each validator in the example has selected a different validator payment (a percentage of the reward set aside directly for the validator). The validator's payment percentage (in ZEP, although the same calculations work) is listed in brackets ([]) next to each validator. Since the validator payment is public knowledge, having a low or non-existent validator payment may attract more stake from nominators, since they know they will receive a larger reward. Validator Set Size (v): 4 ACTIVE SET (One Nominator per Validator) Validator 1 Stake (v1) [20% commission]: 18 ZEP (9 ZEP self-stake, 9 ZEP nominator-stake) Validator 2 Stake (v2) [40% commission]: 9 ZEP (3 ZEP self-stake, 6 ZEP nominator-stake) Validator 3 Stake (v3) [10% commission]: 8 ZEP (4 ZEP self-stake, 4 ZEP nominator-stake) Validator 4 Stake (v4) [0% commission]: 6 ZEP (1 ZEP self-stake, 5 ZEP nominator-stake) TOTAL PAYOUT END OF ERA Payout (p): 8 DOT PAYOUT PER VALIDATOR Payout for each validator (v1 - v4): p / v = 8 / 4 = 2 ZEP --------------------------------------------------------------------------------------------------- REWARD CALCULATION - VALIDATOR 01 v1: (0.2 * 2) = 0.4 ZEP -> validator payment (2 - 0.4) = 1.6 ZEP -> shared between all stake (9 / 18) * 1.6 = 0.8 ZEP -> validator self-stake share (9 / 18) * 1.6 = 0.8 ZEP -> nominator stake share v1 validator total reward: 0.4 + 0.8 = 1.2 ZEP v1 nominator reward: 0.8 ZEP --------------------------------------------------------------------------------------------------- REWARD CALCULATION - VALIDATOR 02 v2: (0.4 * 2) = 0.8 ZEP -> validator payment (2 - 0.8) = 1.2 ZEP -> shared between all stake (3 / 9) * 1.2 = 0.4 ZEP -> validator self-stake share (6 / 9) * 1.2 = 0.8 ZEP -> nominator stake share v2 validator total reward: 0.8 + 0.4 = 1.2 ZEP v2 nominator reward: 0.8 ZEP --------------------------------------------------------------------------------------------------- REWARD CALCULATION - VALIDATOR 03 v3: (0.1 * 2) = 0.2 ZEP -> validator payment (2 - 0.2) = 1.8 ZEP -> shared between all stake (4 / 8) * 1.8 = 0.9 ZEP -> validator self-stake share (4 / 8) * 1.8 = 0.9 ZEP -> nominator stake share v3 validator total reward: 0.2 + 0.9 ZEP = 1.1 ZEP v3 nominator reward: 0.9 ZEP --------------------------------------------------------------------------------------------------- REWARD CALCULATION - VALIDATOR 03 v4: (0 * 2) = 0 ZEP -> validator payment (2 - 0) = 2.0 ZEP -> shared between all stake (1 / 6) * 2 = 0.33 ZEP -> validator self-stake share (5 / 6) * 2 = 1.67 ZEP -> nominator stake share v4 validator total reward: 0 + 0.33 ZEP = 0.33 ZEP v4 nominator reward: 1.67 ZEP Written by Zukma Team","title":"Validator Payout Overview"},{"location":"validator-guides/validator-payout-overview/#validator-payout-overview","text":"","title":"VALIDATOR PAYOUT OVERVIEW"},{"location":"validator-guides/validator-payout-overview/#era-points","text":"For every era (a period of time), validators are paid proportionally to the amount of era points they have collected. Era points are reward points earned for payable actions like: producing a block in the Chain. producing a reference to a previously unreferenced uncle block. producing a referenced uncle block. Note An uncle block is a Chain block that is valid in every regard but fails to become canonical/standard. This can happen when two or more validators produce two different blocks nearly simultaneously. Both blocks are valid productions and could act as an accurate reference for the next block producer. However, the chain decides on a strain of blocks that carry the most weight. The block that was valid but was discarded from the canon is called an uncle block. Since uncles are proper productions, the creation of uncles is getting rewarded. Payments occur at the end of every era.","title":"Era Points"},{"location":"validator-guides/validator-payout-overview/#payout-scheme","text":"No matter how much total stake is behind a validator, all validators split the block-authoring payout equally. However, the payout of a specific validator may differ based on era points, as described above. Although there is a probabilistic component to receiving era points, and they may be impacted slightly depending on factors such as network connectivity, well-behaving validators should generally average out to having similar era point totals over a large number of eras. Validators may also receive \"tips\" from senders as an incentive to include transactions in their produced blocks. Validators will receive 100% of these tips directly. Validators will receive staking rewards in the form of the native coins of that chain (ZEP for Zukma Network). For simplicity, the examples below will assume all validators have the same amount of era points, and received no tips. Validator Set Size (v): 4 ACTIVE SET Validator 1 Stake (v1): 18 coins Validator 2 Stake (v2): 9 coins Validator 3 Stake (v3): 8 coins Validator 4 Stake (v4): 7 coins PAYOUT END OF THE ERA Payout (p): 8 ZEP PAYOUT CALCULATION Payout for each validator (v1 to v4): Payout = p / v = 8 / 4 = 2 ZEP per validator in the active set Note that this is different than most other Proof-of-Stake systems such as Cosmos. As long as a validator is in the validator set, it will receive the same block reward as every other validator. Validator v1, who had 18 coins staked, received the same reward (2 coins) in this era as v4, with only seven tokens staked.","title":"Payout Scheme"},{"location":"validator-guides/validator-payout-overview/#running-multiple-validators","text":"A single entity can run multiple validators. Running multiple validators may provide a better risk/reward ratio. Assuming you have enough ZEP, or enough stake nominates your validator to ensure that your validators remain in the validator set, running multiple validators will result in a higher return than running a single validator. For the following example, assume you have 18 ZEP to stake. For simplicity's sake, we will ignore nominators. As in the example above, running a single validator would net you 2 ZEP in this era. Note that while ZEP is used as an example, this same formula would apply to ZEP when running a validator on Zukma Network Validator Set Size (v): 4 ACTIVE SET Validator 1 Stake (v1): 18 coins <- YOUR VALIDATOR Validator 2 Stake (v2): 9 coins Validator 3 Stake (v3): 8 coins Validator 4 Stake (v4): 7 coins PAYOUT END OF THE ERA Payout (p): 8 ZEP PAYOUT CALCULATION Your Payout = p / v = 8 / 4 = 2 ZEP Running two validators, and splitting the stake equally, would result in the original validator v4 being kicked out of the validator set, as only the top v validators (as measured by stake) are selected to be in the validator set. More important, it would also double the reward that you get from each era. Validator Set Size (v): 4 ACTIVE SET Validator 1 Stake (v1): 9 coins <- YOUR FIRST VALIDATOR Validator 2 Stake (v2): 9 coins <- YOUR SECOND VALIDATOR Validator 3 Stake (v3): 9 coins Validator 4 Stake (v4): 8 coins PAYOUT END OF ERA Payout (p): 8 ZEP Your payout = (p / v) * 2 = (8 / 4) * 2 = 4 ZEP With enough stake, you could run more than two validators. However, each validator must have enough stake behind it to be in the validator set. The system is designed to favor equally-staked validators. This works out to be a dynamic, rather than static, equilibrium. Potential validators will run different numbers of validators and apply different amounts of stake to them as time goes on and in response to the actions of other validators on the network.","title":"Running Multiple Validators"},{"location":"validator-guides/validator-payout-overview/#slashing","text":"Although the system pays rewards equally, slashes are relative to a validator's stake. Therefore, if you do have enough ZEP to run multiple validators, it is in your best interest to do so. Of course, a slash of 30% will be more ZEP for a validator with 18 ZEP staked than one with 9 ZEP staked. Running multiple validators does not absolve you of the consequences of misbehavior. The network punishes attacks that appear coordinated more severely than individual attacks. You should not, for example, run multiple validators hosted on the same infrastructure. A proper multi-validator configuration would ensure that they do not fail simultaneously. Nominators have the incentive to nominate the lowest-staked validator, as this will result in the lowest risk and highest reward. This is because while their vulnerability to slashing remains the same (since it is percentage-based), their rewards are higher since they will be a higher proportion of the total stake allocated to that validator. To clarify this, let us imagine two validators, JOHN and BOBBY. Assume both are in the active set, have commission set to 0%, and are well-behaved. The only difference is that BOBBY has 90 ZEP nominating it and JOHN only has 10. If you nominate BOBBY, it now has 90 + 10 = 100 ZEP, and you will get 10% of the staking rewards for the next era. If you nominate JOHN, it now has 10 + 10 = 20 ZEP nominating it, and you will get 50% of the staking rewards for the next era. In actuality, it would be pretty rare to see such a significant difference between the stake of validators, but the same principle holds even for more minor differences. If there is a 10% slash of either validator, you will lose 1 ZEP in each case.","title":"Slashing"},{"location":"validator-guides/validator-payout-overview/#nominators-and-validator-payments","text":"Nominated stake allows you to \"vote\" for validators and share in the rewards (and slashing) without running a validator node yourself. Validators can choose to keep a percentage of the rewards due to their validator to \"reimburse\" themselves for the cost of running a validator node. Other than that, all rewards are shared based on the stake behind each validator. This includes the stake of the validator itself, plus any stake bonded by nominators. Note Validators set their preference as a percentage of the block reward, not an absolute number of ZEP. The block rewards are based on the total amount at stake, with the reward peaking when the amount staked is at 50% of the total supply. The commission is set as the amount taken by the validator; that is, 0% commission means that the validator does not receive any proportion of the rewards besides that owed to it from self-stake, and 100% commission means that the validator operator gets all rewards and gives none to its nominators. The following examples show the results of several different validator payment schemes and the split between nominator and validator stake. We will assume a single nominator for each validator. However, there can be numerous nominators for each validator. Rewards are still distributed proportionally - for example, if the total rewards to be given to nominators is 2 ZEP, and there are four nominators with equal stake bonded, each will receive 0.5 ZEP. Note also that a single nominator may stake different validators. Each validator in the example has selected a different validator payment (a percentage of the reward set aside directly for the validator). The validator's payment percentage (in ZEP, although the same calculations work) is listed in brackets ([]) next to each validator. Since the validator payment is public knowledge, having a low or non-existent validator payment may attract more stake from nominators, since they know they will receive a larger reward. Validator Set Size (v): 4 ACTIVE SET (One Nominator per Validator) Validator 1 Stake (v1) [20% commission]: 18 ZEP (9 ZEP self-stake, 9 ZEP nominator-stake) Validator 2 Stake (v2) [40% commission]: 9 ZEP (3 ZEP self-stake, 6 ZEP nominator-stake) Validator 3 Stake (v3) [10% commission]: 8 ZEP (4 ZEP self-stake, 4 ZEP nominator-stake) Validator 4 Stake (v4) [0% commission]: 6 ZEP (1 ZEP self-stake, 5 ZEP nominator-stake) TOTAL PAYOUT END OF ERA Payout (p): 8 DOT PAYOUT PER VALIDATOR Payout for each validator (v1 - v4): p / v = 8 / 4 = 2 ZEP --------------------------------------------------------------------------------------------------- REWARD CALCULATION - VALIDATOR 01 v1: (0.2 * 2) = 0.4 ZEP -> validator payment (2 - 0.4) = 1.6 ZEP -> shared between all stake (9 / 18) * 1.6 = 0.8 ZEP -> validator self-stake share (9 / 18) * 1.6 = 0.8 ZEP -> nominator stake share v1 validator total reward: 0.4 + 0.8 = 1.2 ZEP v1 nominator reward: 0.8 ZEP --------------------------------------------------------------------------------------------------- REWARD CALCULATION - VALIDATOR 02 v2: (0.4 * 2) = 0.8 ZEP -> validator payment (2 - 0.8) = 1.2 ZEP -> shared between all stake (3 / 9) * 1.2 = 0.4 ZEP -> validator self-stake share (6 / 9) * 1.2 = 0.8 ZEP -> nominator stake share v2 validator total reward: 0.8 + 0.4 = 1.2 ZEP v2 nominator reward: 0.8 ZEP --------------------------------------------------------------------------------------------------- REWARD CALCULATION - VALIDATOR 03 v3: (0.1 * 2) = 0.2 ZEP -> validator payment (2 - 0.2) = 1.8 ZEP -> shared between all stake (4 / 8) * 1.8 = 0.9 ZEP -> validator self-stake share (4 / 8) * 1.8 = 0.9 ZEP -> nominator stake share v3 validator total reward: 0.2 + 0.9 ZEP = 1.1 ZEP v3 nominator reward: 0.9 ZEP --------------------------------------------------------------------------------------------------- REWARD CALCULATION - VALIDATOR 03 v4: (0 * 2) = 0 ZEP -> validator payment (2 - 0) = 2.0 ZEP -> shared between all stake (1 / 6) * 2 = 0.33 ZEP -> validator self-stake share (5 / 6) * 2 = 1.67 ZEP -> nominator stake share v4 validator total reward: 0 + 0.33 ZEP = 0.33 ZEP v4 nominator reward: 1.67 ZEP Written by Zukma Team","title":"Nominators and Validator Payments"},{"location":"validator-guides/validator/","text":"HOW TO SETUP A VALIDATOR The following guide will teach you how to set up a Zukma validator. The process of becoming a validator requires two steps. The first step is to set up a network node. The second step is to assign your node to your account and apply for validator candidacy. Network validators are the foundation of a decentralized proof-of-stake network because they are responsible for concluding on a consensus by creating new and validating already produced blocks. That said, network validators are the prime target for adversaries that aim to sabotage the network. The Zukma has many layers to protect the network from attacks. The first layer is the security of each validator itself. Another layer is the slashing mechanism that detects validator nodes that display abnormal or dangerous behavior and punishes them with slashes. A slash will, in all cases, lead to the loss of funds. Warning Hence the warning: Running a validator on a live network is a lot of responsibility! You will be accountable for your stake and the stake of your current nominators. If you make a mistake and get slashed, your money and your reputation will be at risk. However, running a validator can also be very rewarding, knowing that you contribute to the security of a decentralized network while growing your stash. Step 1 - Setup a Network Node Requirements You can operate a network node on a local computer, a professional server-rig in your basement, or on a remotely hosted virtual private server (VPS) in the clouds. It's up to you to choose the infrastructure you feel most comfortable with. What doesn't change are the requirements of a network node that operates as a validator. Validators should always be online and powerful enough to create and validate the authoring process of new blocks. If your validator is failing at one of these requirements, it will get punished by slashes. Tip The most common way for a beginner to run a validator is on a VPS running Linux. You may choose whatever VPS providers that you prefer. We benchmarked the transactions weights on the Zukma network on standard hardware. We recommend that validators run at least the standard hardware to ensure they can process all blocks in time. The following are not minimum requirements, but if you decide to run with less than this, beware that you might have a performance issue. Lower-end Hardware : 6GB ram, 60 GB Storage, 2 CPU , stable server uplink connection with fixed IP Ideal Hardware : 16GB ram, 300 GB Storage, 6 CPU, stable server uplink connection with fixed IP Info Anything between the lower-end and ideal hardware should be sufficient to run a validator on the Zukma network. Using Ubuntu 21.10: Update your Ubuntu sudo apt-get update Network Time Protocol (NTP) Client We currently require that the clocks of all validators on the network stay reasonably in sync. The NTP client is a piece of software that allows you to synchronize your server's clock with the clocks of the remaining servers connected to the blockchain. Info If you are using Ubuntu 18.04 / 19.04 / 20.04, NTP Client should be installed by default. You can check if your server is already running NTP by executing the following command: timedatectl If NTP is installed and running, you should see System clock synchronized: yes (or a similar message). Otherwise install the NTP client by running the following command: sudo apt-get install ntp NTP will be started automatically after install. You can query your NTP client for status information to verify that everything is working: sudo ntpq -p Warning Skipping this can result in the validator node missing block authorship opportunities. If the clock is out of sync (even by a small amount), the blocks produced by your validator may not get accepted by the network. Installing the Zukma network Binary Install and enable Chrony We learned in the previous step that the new versions of Ubuntu ship with the NTP client by default. However, Chrony is another time sync tool that delivers better and more stable performance. Therefore, we recommend installing and enabling Chrony on top of the NTP client to ensure synchronized clocks and uninterrupted validator operations. sudo apt install chrony sudo systemctl enable chrony Fundamental Security Measures Security is of utmost importance if you consider operating a successful validator on a live network. We will show you how to create a fundamental layer of protection by installing a firewall and a fail2ban service. Configure a Firewall The default firewall configuration tool for Ubuntu is UFW . UFW stands for uncomplicated firewall and helps ease IP-tables firewall configuration, and provides a user-friendly way to create an IPv4 or IPv6 host-based firewall. Configure firewall ports to allow SSH and Validator service to communicate. sudo ufw allow 22 sudo ufw allow 30333 sudo ufw allow ntp sudo ufw enable Setup Fail2Ban Fail2Ban is a tool that scans log files and bans IPs that show malicious signs for instance too many password failures, seeking for exploits, etc. Generally Fail2Ban is then used to update firewall rules to reject the IP addresses for a specified amount of time. It provides basic-level protection against distributed brute-force attacks. sudo apt install -y fail2ban && sudo systemctl enable fail2ban && sudo service fail2ban start Success Congratulations! You implemented a fundamental layer of protection. Install Zukma Validator binaries The following command will fetch / download the Zukma validator binaries and copy them to a specific folder. Check your ubuntu version and choose the correct file for it. check your ubuntu version and choose the correct file for it wget https://download.zukma.io/zukma/ FILE_NAME_FROM_ABOVE -O zukma && sudo chmod +x ./zukma && sudo mv ./zukma /usr/bin/zukma Warning Make sure that the link matches exactly and never use another source to download the binaries! Create User Account for Validator Operations For security reasons we recommend to run a validator as non-root user. For that we create a dedicated user account which will be used to run the validator. sudo adduser zukma Info when adding the new account you will be asked to provide a password and some additional information. Only the password is mandatory, the other parameters can be left blank. Create the Zukma Validator Service File In the next step, we will use Nano , a simple terminal-based text editor, to create a file that contains service instructions. The following command creates a file named zukma.service at the following location: lib/systemd/system/ sudo nano /lib/systemd/system/zukma.service Warning The following code-block contains the content that must be inserted into the Nano text editor! Make sure to change \"A Node Name\" and replace it your preferred name Content of the zukma.service file : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 [Unit] Description=zukma Validator After=network-online.target [Service] ExecStart=/usr/bin/zukma --port \"30333\" --name \" A Node Name \" --validator --chain zukma User=zukma Restart=always ExecStartPre=/bin/sleep 5 RestartSec=30s LimitNOFILE=8192 [Install] WantedBy=multi-user.target Hit \"ctrl+x\", then press \"y\" to confirm the saving of the file and then hit \"Enter\" to exit. Hint If you want to add a more ports to enable RPC calls, a websocket or monitoring, you can set it up by including the following flags in line 6. --prometheus-port --rpc-port and --ws-port then start the service sudo systemctl enable zukma && sudo service zukma start Success Your validator will now run as a systemd process so that it will automatically restart on server reboots or crashes (and helps to avoid to getting slashed!) For more information on systemd you can watch this quick YouTube Tutorial . Check if validator is started To ensure that the Zukma Validator process works please execute the following command: ps aux | grep zukma You should see a similar output: zukma 8108 9.9 21.0 1117976 419772 ? Ssl May17 601:17 /usr/bin/zukma --port 30333 --name \"A Node Name\" --validator --chain zukma Furthermore, you can monitor your validator's logs by executing the following command: journalctl -u zukma.service --follow To exit the 'follow' mode you need to hit Ctrl + C Reboot to be sure everything is restarted correctly: sudo reboot -h now Check if your node is appearing in the telemetry UI : Telemetry UI Info If you want to find your node here you must have changed the name parameter in the previous step ( --name \"A Node Name\" ) Success Congrats! If you checked and found your node on the telemetry page, you successfully set up your server to become a Zukma Validator! Part 2 - Assign the node to an account The second part of this guide will complete the validator setup by connecting your server with your Substrate account. Make sure you have some ZEP in your substrate wallet. In case you need ZEP please see the claim section or watch our YouTube Walkthrough . What are stash and controller accounts? The divison into two wallets or accounts is an additional security feature we implemented to protect your funds in case of fradulent attacks. Hint In short: The Stash-Account is where you keep all the funds you want to stake. We recommend to protect it's private key with a hardware wallet like Ledger or Trezor. The Controller-Account is used to control actions related to your staking However, you can start and operate a validator without hardware wallets. This may be a viable option on a but is certainly not recommended once liqudity is provided. The Stash Account will be used to bond/unbond your funds and to choose the address of the Controller Account. The Controller Account will be used to take actions on behalf of the bonded funds. However, the Controller Account can't move the bonded funds out of the Stash Account. Warning Never disclose your Keystore file or your 12/24 words seed phrase. Before we start with the creation of both accounts please consider to download the Polkadot{.js} browser extension is our recommended way to create substrate based accounts. Pokadot.js is very comparable with Meta Mask for Ethereum especially in terms of usability, security and functionality. Tip Download Pokadot.js browser extension Create the Controller Account Step 1: Open the Pokadot.js browser extension by clicking the logo on the top bar of your browser. You will see a browser popup, not unlike the one below. Step 2: Click the big plus button or select \"Create new account\" from the small plus icon in the top right. The Polkadot{.js} plugin will then use system randomness to make a new seed for you and display it to you in the form of twelve words. Step 3: You should back up these words as explained above. It is imperative to store the seed somewhere safe, secret, and secure. If you cannot access your account via Polkadot{.js} for some reason, you can re-enter your seed through the \"Add account menu\" by selecting \"Import account from pre-existing seed\". Step 4: Name your Account The account name is arbitrary and for your use only. It is not stored on the blockchain and will not be visible to other users who look at your address via a block explorer. If you're juggling multiple accounts, it helps to make this as descriptive and detailed as needed. Step 5: Enter Password You will use the password to encrypt this account's information. You will need to re-enter it when using the account for all outgoing transactions or sign a cryptographic message. Warning Note that this password does NOT protect your seed phrase. If someone knows the twelve words in your mnemonic seed, they still control your account even if they do not know the password. Hint Repeat this process to create your stash account Create Session Keys: Login to your VPS server. Session keys are needed to associate your node with your controller account. To generate the session keys you can run the following command in your terminal: curl -H \"Content-Type: application/json\" -d '{\"id\":1, \"jsonrpc\":\"2.0\", \"method\": \"author_rotateKeys\", \"params\":[]}' http://localhost:9933 The output will have a hex-encoded \"result\" field. The result is the concatenation of the four public keys. Save this result for a later step. Copy the session key. It will look like this: 0x13660593581b2e728ee32122636f8996c6fd9c22f33beaa05e2797899c5458b0c888149bf3c0b5ca7fb7296e69fefd85e4e3d5b76848db890207575e49031f37d846e78babf8051c123b498ffe6f12e712f97f6b2f3b54345ffe51145a16bb22187d415c2101b9883668ce93c46f7ba556b394c59781854737b6c941747c0964 Apply on Zukma Explorer Visit the substrate explorer Go to the Network Tab -> Staking -> Account Actions ( Link ) Hit the + Validator Button Fill in the form Stash account - Select your Stash account. In this example, we will bond 1000 ZEP, where the minimum bonding amount is 1. Make sure that your Stash account contains at least this much. You can, of course, stake more than this. Controller account - Select the Controller account created earlier. This account will also need a small amount of ZEP in order to start and stop validating. Value bonded - How much ZEP from the Stash account you want to bond/stake. Note that you do not need to bond all of the ZEP in that account. Also note that you can always bond more ZEP later. However, withdrawing any bonded amount requires the duration of the unbonding period. Payment destination - The account where the rewards from validating are sent. Payouts can go to any custom address. If you'd like to redirect payments to an account that is neither the controller nor the stash account, set one up. Note that it is extremely unsafe to set an exchange address as the recipient of the staking rewards. Paste the session key Here you will need to input the Sesssion Keys, which is the Hex output from the command we executed earlier. The keys will show as pending until applied at the start of a new session. The \"reward commission percentage\" is the commission percentage that you can declare against your validator's rewards. This is the rate that your validator will be commissioned with. !!! Note: setting a commission rate of 100% suggests that you do not want your validator to receive nominations. You can also determine if you would like to receive nominations with the \"allows new nominations\" option. Hit bond & validate Visit the Waiting Tab to see your validator waiting until the era finishes Success Alright mate! You are all set :D Written by Zukma Team","title":"Become a Validator"},{"location":"validator-guides/validator/#how-to-setup-a-validator","text":"The following guide will teach you how to set up a Zukma validator. The process of becoming a validator requires two steps. The first step is to set up a network node. The second step is to assign your node to your account and apply for validator candidacy. Network validators are the foundation of a decentralized proof-of-stake network because they are responsible for concluding on a consensus by creating new and validating already produced blocks. That said, network validators are the prime target for adversaries that aim to sabotage the network. The Zukma has many layers to protect the network from attacks. The first layer is the security of each validator itself. Another layer is the slashing mechanism that detects validator nodes that display abnormal or dangerous behavior and punishes them with slashes. A slash will, in all cases, lead to the loss of funds. Warning Hence the warning: Running a validator on a live network is a lot of responsibility! You will be accountable for your stake and the stake of your current nominators. If you make a mistake and get slashed, your money and your reputation will be at risk. However, running a validator can also be very rewarding, knowing that you contribute to the security of a decentralized network while growing your stash.","title":"HOW TO SETUP A VALIDATOR"},{"location":"validator-guides/validator/#step-1-setup-a-network-node","text":"","title":"Step 1 - Setup a Network Node"},{"location":"validator-guides/validator/#requirements","text":"You can operate a network node on a local computer, a professional server-rig in your basement, or on a remotely hosted virtual private server (VPS) in the clouds. It's up to you to choose the infrastructure you feel most comfortable with. What doesn't change are the requirements of a network node that operates as a validator. Validators should always be online and powerful enough to create and validate the authoring process of new blocks. If your validator is failing at one of these requirements, it will get punished by slashes. Tip The most common way for a beginner to run a validator is on a VPS running Linux. You may choose whatever VPS providers that you prefer. We benchmarked the transactions weights on the Zukma network on standard hardware. We recommend that validators run at least the standard hardware to ensure they can process all blocks in time. The following are not minimum requirements, but if you decide to run with less than this, beware that you might have a performance issue.","title":"Requirements"},{"location":"validator-guides/validator/#lower-end-hardware","text":"6GB ram, 60 GB Storage, 2 CPU , stable server uplink connection with fixed IP","title":"Lower-end Hardware :"},{"location":"validator-guides/validator/#ideal-hardware","text":"16GB ram, 300 GB Storage, 6 CPU, stable server uplink connection with fixed IP Info Anything between the lower-end and ideal hardware should be sufficient to run a validator on the Zukma network.","title":"Ideal Hardware :"},{"location":"validator-guides/validator/#using-ubuntu-2110","text":"","title":"Using Ubuntu 21.10:"},{"location":"validator-guides/validator/#update-your-ubuntu","text":"sudo apt-get update","title":"Update your Ubuntu"},{"location":"validator-guides/validator/#network-time-protocol-ntp-client","text":"We currently require that the clocks of all validators on the network stay reasonably in sync. The NTP client is a piece of software that allows you to synchronize your server's clock with the clocks of the remaining servers connected to the blockchain. Info If you are using Ubuntu 18.04 / 19.04 / 20.04, NTP Client should be installed by default. You can check if your server is already running NTP by executing the following command: timedatectl If NTP is installed and running, you should see System clock synchronized: yes (or a similar message). Otherwise install the NTP client by running the following command: sudo apt-get install ntp NTP will be started automatically after install. You can query your NTP client for status information to verify that everything is working: sudo ntpq -p Warning Skipping this can result in the validator node missing block authorship opportunities. If the clock is out of sync (even by a small amount), the blocks produced by your validator may not get accepted by the network.","title":"Network Time Protocol (NTP) Client"},{"location":"validator-guides/validator/#installing-the-zukma-network-binary","text":"","title":"Installing the Zukma network Binary"},{"location":"validator-guides/validator/#install-and-enable-chrony","text":"We learned in the previous step that the new versions of Ubuntu ship with the NTP client by default. However, Chrony is another time sync tool that delivers better and more stable performance. Therefore, we recommend installing and enabling Chrony on top of the NTP client to ensure synchronized clocks and uninterrupted validator operations. sudo apt install chrony sudo systemctl enable chrony","title":"Install and enable Chrony"},{"location":"validator-guides/validator/#fundamental-security-measures","text":"Security is of utmost importance if you consider operating a successful validator on a live network. We will show you how to create a fundamental layer of protection by installing a firewall and a fail2ban service. Configure a Firewall The default firewall configuration tool for Ubuntu is UFW . UFW stands for uncomplicated firewall and helps ease IP-tables firewall configuration, and provides a user-friendly way to create an IPv4 or IPv6 host-based firewall. Configure firewall ports to allow SSH and Validator service to communicate. sudo ufw allow 22 sudo ufw allow 30333 sudo ufw allow ntp sudo ufw enable Setup Fail2Ban Fail2Ban is a tool that scans log files and bans IPs that show malicious signs for instance too many password failures, seeking for exploits, etc. Generally Fail2Ban is then used to update firewall rules to reject the IP addresses for a specified amount of time. It provides basic-level protection against distributed brute-force attacks. sudo apt install -y fail2ban && sudo systemctl enable fail2ban && sudo service fail2ban start Success Congratulations! You implemented a fundamental layer of protection.","title":"Fundamental Security Measures"},{"location":"validator-guides/validator/#install-zukma-validator-binaries","text":"The following command will fetch / download the Zukma validator binaries and copy them to a specific folder. Check your ubuntu version and choose the correct file for it. check your ubuntu version and choose the correct file for it wget https://download.zukma.io/zukma/ FILE_NAME_FROM_ABOVE -O zukma && sudo chmod +x ./zukma && sudo mv ./zukma /usr/bin/zukma Warning Make sure that the link matches exactly and never use another source to download the binaries!","title":"Install Zukma Validator binaries"},{"location":"validator-guides/validator/#create-user-account-for-validator-operations","text":"For security reasons we recommend to run a validator as non-root user. For that we create a dedicated user account which will be used to run the validator. sudo adduser zukma Info when adding the new account you will be asked to provide a password and some additional information. Only the password is mandatory, the other parameters can be left blank.","title":"Create User Account for Validator Operations"},{"location":"validator-guides/validator/#create-the-zukma-validator-service-file","text":"In the next step, we will use Nano , a simple terminal-based text editor, to create a file that contains service instructions. The following command creates a file named zukma.service at the following location: lib/systemd/system/ sudo nano /lib/systemd/system/zukma.service Warning The following code-block contains the content that must be inserted into the Nano text editor! Make sure to change \"A Node Name\" and replace it your preferred name Content of the zukma.service file : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 [Unit] Description=zukma Validator After=network-online.target [Service] ExecStart=/usr/bin/zukma --port \"30333\" --name \" A Node Name \" --validator --chain zukma User=zukma Restart=always ExecStartPre=/bin/sleep 5 RestartSec=30s LimitNOFILE=8192 [Install] WantedBy=multi-user.target Hit \"ctrl+x\", then press \"y\" to confirm the saving of the file and then hit \"Enter\" to exit. Hint If you want to add a more ports to enable RPC calls, a websocket or monitoring, you can set it up by including the following flags in line 6. --prometheus-port --rpc-port and --ws-port then start the service sudo systemctl enable zukma && sudo service zukma start Success Your validator will now run as a systemd process so that it will automatically restart on server reboots or crashes (and helps to avoid to getting slashed!) For more information on systemd you can watch this quick YouTube Tutorial .","title":"Create the Zukma Validator Service File"},{"location":"validator-guides/validator/#check-if-validator-is-started","text":"To ensure that the Zukma Validator process works please execute the following command: ps aux | grep zukma You should see a similar output: zukma 8108 9.9 21.0 1117976 419772 ? Ssl May17 601:17 /usr/bin/zukma --port 30333 --name \"A Node Name\" --validator --chain zukma Furthermore, you can monitor your validator's logs by executing the following command: journalctl -u zukma.service --follow To exit the 'follow' mode you need to hit Ctrl + C","title":"Check if validator is started"},{"location":"validator-guides/validator/#reboot-to-be-sure-everything-is-restarted-correctly","text":"sudo reboot -h now Check if your node is appearing in the telemetry UI : Telemetry UI Info If you want to find your node here you must have changed the name parameter in the previous step ( --name \"A Node Name\" ) Success Congrats! If you checked and found your node on the telemetry page, you successfully set up your server to become a Zukma Validator!","title":"Reboot to be sure everything is restarted correctly:"},{"location":"validator-guides/validator/#part-2-assign-the-node-to-an-account","text":"The second part of this guide will complete the validator setup by connecting your server with your Substrate account. Make sure you have some ZEP in your substrate wallet. In case you need ZEP please see the claim section or watch our YouTube Walkthrough .","title":"Part 2 - Assign the node to an account"},{"location":"validator-guides/validator/#what-are-stash-and-controller-accounts","text":"The divison into two wallets or accounts is an additional security feature we implemented to protect your funds in case of fradulent attacks. Hint In short: The Stash-Account is where you keep all the funds you want to stake. We recommend to protect it's private key with a hardware wallet like Ledger or Trezor. The Controller-Account is used to control actions related to your staking However, you can start and operate a validator without hardware wallets. This may be a viable option on a but is certainly not recommended once liqudity is provided. The Stash Account will be used to bond/unbond your funds and to choose the address of the Controller Account. The Controller Account will be used to take actions on behalf of the bonded funds. However, the Controller Account can't move the bonded funds out of the Stash Account. Warning Never disclose your Keystore file or your 12/24 words seed phrase. Before we start with the creation of both accounts please consider to download the Polkadot{.js} browser extension is our recommended way to create substrate based accounts. Pokadot.js is very comparable with Meta Mask for Ethereum especially in terms of usability, security and functionality. Tip Download Pokadot.js browser extension","title":"What are stash and controller accounts?"},{"location":"validator-guides/validator/#create-the-controller-account","text":"Step 1: Open the Pokadot.js browser extension by clicking the logo on the top bar of your browser. You will see a browser popup, not unlike the one below. Step 2: Click the big plus button or select \"Create new account\" from the small plus icon in the top right. The Polkadot{.js} plugin will then use system randomness to make a new seed for you and display it to you in the form of twelve words. Step 3: You should back up these words as explained above. It is imperative to store the seed somewhere safe, secret, and secure. If you cannot access your account via Polkadot{.js} for some reason, you can re-enter your seed through the \"Add account menu\" by selecting \"Import account from pre-existing seed\". Step 4: Name your Account The account name is arbitrary and for your use only. It is not stored on the blockchain and will not be visible to other users who look at your address via a block explorer. If you're juggling multiple accounts, it helps to make this as descriptive and detailed as needed. Step 5: Enter Password You will use the password to encrypt this account's information. You will need to re-enter it when using the account for all outgoing transactions or sign a cryptographic message. Warning Note that this password does NOT protect your seed phrase. If someone knows the twelve words in your mnemonic seed, they still control your account even if they do not know the password. Hint Repeat this process to create your stash account","title":"Create the Controller Account"},{"location":"validator-guides/validator/#create-session-keys","text":"Login to your VPS server. Session keys are needed to associate your node with your controller account. To generate the session keys you can run the following command in your terminal: curl -H \"Content-Type: application/json\" -d '{\"id\":1, \"jsonrpc\":\"2.0\", \"method\": \"author_rotateKeys\", \"params\":[]}' http://localhost:9933 The output will have a hex-encoded \"result\" field. The result is the concatenation of the four public keys. Save this result for a later step. Copy the session key. It will look like this: 0x13660593581b2e728ee32122636f8996c6fd9c22f33beaa05e2797899c5458b0c888149bf3c0b5ca7fb7296e69fefd85e4e3d5b76848db890207575e49031f37d846e78babf8051c123b498ffe6f12e712f97f6b2f3b54345ffe51145a16bb22187d415c2101b9883668ce93c46f7ba556b394c59781854737b6c941747c0964","title":"Create Session Keys:"},{"location":"validator-guides/validator/#apply-on-zukma-explorer","text":"Visit the substrate explorer Go to the Network Tab -> Staking -> Account Actions ( Link ) Hit the + Validator Button Fill in the form Stash account - Select your Stash account. In this example, we will bond 1000 ZEP, where the minimum bonding amount is 1. Make sure that your Stash account contains at least this much. You can, of course, stake more than this. Controller account - Select the Controller account created earlier. This account will also need a small amount of ZEP in order to start and stop validating. Value bonded - How much ZEP from the Stash account you want to bond/stake. Note that you do not need to bond all of the ZEP in that account. Also note that you can always bond more ZEP later. However, withdrawing any bonded amount requires the duration of the unbonding period. Payment destination - The account where the rewards from validating are sent. Payouts can go to any custom address. If you'd like to redirect payments to an account that is neither the controller nor the stash account, set one up. Note that it is extremely unsafe to set an exchange address as the recipient of the staking rewards. Paste the session key Here you will need to input the Sesssion Keys, which is the Hex output from the command we executed earlier. The keys will show as pending until applied at the start of a new session. The \"reward commission percentage\" is the commission percentage that you can declare against your validator's rewards. This is the rate that your validator will be commissioned with. !!! Note: setting a commission rate of 100% suggests that you do not want your validator to receive nominations. You can also determine if you would like to receive nominations with the \"allows new nominations\" option. Hit bond & validate Visit the Waiting Tab to see your validator waiting until the era finishes Success Alright mate! You are all set :D Written by Zukma Team","title":"Apply on Zukma Explorer"},{"location":"what-to-try/account-generation/","text":"ACCOUNT GENERATION To start interacting with Zukma, you need a wallet or account that enables you to send transactions, participate in the chain governance, run a validator or nominate to earn interest. The following guide will show you how easy setting up a Zukma account is and what exact steps you need to take. If you encounter any issues or problems, please feel free to reach out to us on Telegram . Before we start, let's get some terms right, and let's spend a couple of seconds talking about the concept of keys. A standard wallet or account is composed out of two keys: The PUBLIC KEY (Wallet address) The PRIVATE KEY (The key that allows you to access and manage your funds) Your Zukma account follows the same rules. Therefore, we will continue with a section on key security to make you aware that You must keep your PRIVATE KEY, SEED PHRASE, or JSON KEYSTORE file secret at all times. Storing your key safely The only ways to access your account are via your secret seed or your account's JSON file in combination with a password. It would be best if you kept them both secure and private. If you share them with anyone, they will have full access to your account, including all of your funds. This information is a target for hackers and others with bad intentions. In this guide, we recommend the Polkadot{.js} browser plug-in as the best method to create your Zukma account. Tip Polkadot{.js} Browser Extension RECOMMENDED FOR MOST USERS The seed is your key to the account. Knowing the seed allows you to re-generate and control your account or anyone else who knows the seed. It is imperative to store the seed somewhere safe, secret, and secure. If you lose access to your account (i.e., forget the password for your account's JSON file), you can re-create it by entering the seed. This also means that somebody else can control your account if they have access to your seed. For maximum security, the seed should be written down on paper or another non-digital device and stored in a safe place. You may also want to protect your seed from physical damage (e.g., keeping it in a sealed plastic bag to prevent water damage, storing it in a fireproof safe, etching it in metal, etc.) We recommend that you keep multiple copies of the seed in geographically separate locations (e.g., one in your home safe and one in a safety deposit box at your bank). You should not store your seed on any kind of computer that has or may have access to the internet in the future. Storing your account's JSON file The JSON file is encrypted with a password, which means you can import it into any wallet which supports JSON imports, but to then use it, you need the password. You don't have to be as careful with your JSON file's storage as you would with your seed (i.e. it can be on a USB drive near you), but remember that in this case, your account is only as secure as the password you used to encrypt it. Do not use easy to guess or hard to remember passwords. It is good practice to use a mnemonic password of four to five words. These are nearly impossible for computers to guess due to the number of combinations possible but much more manageable for humans to remember. Polkadot{.js} Browser Extension Since Polkadot and Zukma share the same foundation, namely Substrate, the Polkadot{.js} browser extension is the recommended way to create your Zukma account. Polkadot{.js} Browser Extension for Chrome & Brave Polkadot{.js} Browser Extension for Firefox The Polkadot{.js} browser extension provides a reasonable balance of security and usability. It's comparable to MetaMask for Ethereum. It provides a separate local mechanism to generate your address and interact with Zukma. So let's start installing the Polkadot{.js} plugin to enable you to interact with Zukma. Create an Account Open the Polkadot{.js} browser extension by clicking the logo on the top bar of your browser. You will see a browser popup, not unlike the one below. Click the big plus button or select \"Create new account\" from the small plus icon in the top right. The Polkadot{.js} plugin will then use system randomness to make a new seed for you and display it to you in the form of twelve words. You should back up these words as explained above. It is imperative to store the seed somewhere safe, secret, and secure. If you cannot access your account via Polkadot{.js} for some reason, you can re-enter your seed through the \"Add account menu\" by selecting \"Import account from pre-existing seed\". Name your Account The account name is arbitrary and for your use only. It is not stored on the blockchain and will not be visible to other users who look at your address via a block explorer. If you're juggling multiple accounts, it helps to make this as descriptive and detailed as needed. Enter Password You will use the password to encrypt this account's information. You will need to re-enter it when using the account for all outgoing transactions or sign a cryptographic message. Warning Note that this password does NOT protect your seed phrase. If someone knows the twelve words in your mnemonic seed, they still control your account even if they do not know the password. Success Congrats! You managed to create a Zukma-Substrate Account with the Polkadot{.js} browser extention. Written by Zukma Team","title":"Create an Account"},{"location":"what-to-try/account-generation/#account-generation","text":"To start interacting with Zukma, you need a wallet or account that enables you to send transactions, participate in the chain governance, run a validator or nominate to earn interest. The following guide will show you how easy setting up a Zukma account is and what exact steps you need to take. If you encounter any issues or problems, please feel free to reach out to us on Telegram . Before we start, let's get some terms right, and let's spend a couple of seconds talking about the concept of keys. A standard wallet or account is composed out of two keys: The PUBLIC KEY (Wallet address) The PRIVATE KEY (The key that allows you to access and manage your funds) Your Zukma account follows the same rules. Therefore, we will continue with a section on key security to make you aware that You must keep your PRIVATE KEY, SEED PHRASE, or JSON KEYSTORE file secret at all times.","title":"ACCOUNT GENERATION"},{"location":"what-to-try/account-generation/#storing-your-key-safely","text":"The only ways to access your account are via your secret seed or your account's JSON file in combination with a password. It would be best if you kept them both secure and private. If you share them with anyone, they will have full access to your account, including all of your funds. This information is a target for hackers and others with bad intentions. In this guide, we recommend the Polkadot{.js} browser plug-in as the best method to create your Zukma account. Tip Polkadot{.js} Browser Extension RECOMMENDED FOR MOST USERS The seed is your key to the account. Knowing the seed allows you to re-generate and control your account or anyone else who knows the seed. It is imperative to store the seed somewhere safe, secret, and secure. If you lose access to your account (i.e., forget the password for your account's JSON file), you can re-create it by entering the seed. This also means that somebody else can control your account if they have access to your seed. For maximum security, the seed should be written down on paper or another non-digital device and stored in a safe place. You may also want to protect your seed from physical damage (e.g., keeping it in a sealed plastic bag to prevent water damage, storing it in a fireproof safe, etching it in metal, etc.) We recommend that you keep multiple copies of the seed in geographically separate locations (e.g., one in your home safe and one in a safety deposit box at your bank). You should not store your seed on any kind of computer that has or may have access to the internet in the future.","title":"Storing your key safely"},{"location":"what-to-try/account-generation/#storing-your-accounts-json-file","text":"The JSON file is encrypted with a password, which means you can import it into any wallet which supports JSON imports, but to then use it, you need the password. You don't have to be as careful with your JSON file's storage as you would with your seed (i.e. it can be on a USB drive near you), but remember that in this case, your account is only as secure as the password you used to encrypt it. Do not use easy to guess or hard to remember passwords. It is good practice to use a mnemonic password of four to five words. These are nearly impossible for computers to guess due to the number of combinations possible but much more manageable for humans to remember.","title":"Storing your account's JSON file"},{"location":"what-to-try/account-generation/#polkadotjs-browser-extension","text":"Since Polkadot and Zukma share the same foundation, namely Substrate, the Polkadot{.js} browser extension is the recommended way to create your Zukma account. Polkadot{.js} Browser Extension for Chrome & Brave Polkadot{.js} Browser Extension for Firefox The Polkadot{.js} browser extension provides a reasonable balance of security and usability. It's comparable to MetaMask for Ethereum. It provides a separate local mechanism to generate your address and interact with Zukma. So let's start installing the Polkadot{.js} plugin to enable you to interact with Zukma.","title":"Polkadot{.js} Browser Extension"},{"location":"what-to-try/account-generation/#create-an-account","text":"Open the Polkadot{.js} browser extension by clicking the logo on the top bar of your browser. You will see a browser popup, not unlike the one below. Click the big plus button or select \"Create new account\" from the small plus icon in the top right. The Polkadot{.js} plugin will then use system randomness to make a new seed for you and display it to you in the form of twelve words. You should back up these words as explained above. It is imperative to store the seed somewhere safe, secret, and secure. If you cannot access your account via Polkadot{.js} for some reason, you can re-enter your seed through the \"Add account menu\" by selecting \"Import account from pre-existing seed\".","title":"Create an Account"},{"location":"what-to-try/account-generation/#name-your-account","text":"The account name is arbitrary and for your use only. It is not stored on the blockchain and will not be visible to other users who look at your address via a block explorer. If you're juggling multiple accounts, it helps to make this as descriptive and detailed as needed.","title":"Name your Account"},{"location":"what-to-try/account-generation/#enter-password","text":"You will use the password to encrypt this account's information. You will need to re-enter it when using the account for all outgoing transactions or sign a cryptographic message. Warning Note that this password does NOT protect your seed phrase. If someone knows the twelve words in your mnemonic seed, they still control your account even if they do not know the password. Success Congrats! You managed to create a Zukma-Substrate Account with the Polkadot{.js} browser extention. Written by Zukma Team","title":"Enter Password"},{"location":"what-to-try/democracy/","text":"EXPLORING DEMOCRACY Zukma uses a sophisticated governance mechanism to evolve gracefully over time at the ultimate behest of its assembled stakeholders. The stated goal is to ensure that the majority of the stake can always command the network. To do this, we borrowed and adjusted various mechanisms from Polkadot, Kusama and Substrate, including an amorphous state-transition function stored on-chain and defined in a platform-neutral intermediate language (i.e. WebAssembly ) and several on-chain voting mechanisms such as referenda with adaptive super-majority thresholds and batch approval voting. Stake-weighted referenda must agree upon all changes to the protocol. Mechanism To make any changes to the network, the idea is to compose active coin holders and the council together to administrate a network upgrade decision. No matter whether the proposal is proposed by the public (coin holders) or the council, it finally will have to go through a referendum to let all holders, weighted by stake, make the decision. Referenda Referenda are straightforward, inclusive, stake-based voting schemes. Each referendum has a specific proposal associated with it that takes the form of a privileged function call in the runtime (that includes the most powerful call: set_code , which can switch out the entire code of the runtime, achieving what would otherwise require a \"hard fork\"). Referenda are discrete events, have a fixed period where voting happens and then are tallied, and the function call is made if the vote is approved. Referenda are always binary; your only options in voting are \"aye\" , \"nay\" , or abstaining entirely. Referenda can be started in one of several ways: Publicly submitted proposals; Proposals submitted by the Council, either through a majority or unanimously; Proposals submitted as part of the enactment of a prior referendum; Emergency proposals submitted by the Technical Committee and approved by the Council. All referenda have an enactment delay associated with them. This is the period between the referendum ending and, assuming the proposal was approved, the changes being enacted. For the first two ways that a referendum is launched, this is a fixed time. For Zukma, it is eight days. For the third type, it can be set as desired. Emergency proposals deal with significant problems with the network that need to be \"fast-tracked\". These will have a shorter enactment time. Proposing a Referendum Public referenda Anyone can propose a referendum by depositing the minimum amount of coins for a certain period (number of blocks). If someone agrees with the proposal, they may deposit the same amount of coins to support it - this action is called seconding. The proposal with the highest bonded support will be selected to be a referendum in the next voting cycle. Note Note that this may be different from the absolute number of seconds; for instance, three accounts bonding 20 ZEP each would \"outweigh\" ten accounts bonding aP single ZEP each. The bonded coins will be released once the proposal is tabled (that is, brought to a vote). There can be a maximum of 100 public proposals in the proposal queue. Council Referenda Unanimous Council - When all members of the council agree on a proposal, the council can move it to a referendum. This referendum will have a negative turnout bias (that is, the smaller the amount of stake voting, the smaller the amount necessary for it to pass - see \"Adaptive Quorum Biasing\", below). Majority Council - When agreement from only a simple majority of council members occurs, the referendum can also be voted upon, but it will be majority-carries (51% wins). There can only be one active referendum at any given time, except when there is also an emergency referendum in progress. Voting Timetable Every 7 days, a new referendum will come up for a vote, assuming at least one proposal in one of the queues. There is a queue for Council-approved proposals and a queue for publicly submitted proposals. The referendum to be voted upon alternates between the top proposal in the two queues. The \"top\" proposal is determined by the amount of stake bonded behind it. Suppose the given queue whose turn it is to create a referendum with no proposals (empty), and proposals are waiting in the other queue. In that case, the top proposal in the other queue will become a referendum. Multiple referenda cannot be voted upon in the same period, excluding emergency referenda. An emergency referendum co-occurring as a regular referendum (either public- or council-proposed) is the only time multiple referenda will be voted on at once. Voting on referendum To vote, a voter generally must lock their coins up for at least the enactment delay period beyond the end of the referendum. This ensures that some minimal economic buy-in to the result is needed and dissuades vote selling. It is possible to vote without locking at all, but your vote is worth a small fraction of an ordinary vote, given your stake. At the same time, holding only a small amount of coins does not mean that the holder cannot influence the referendum result, thanks to time-locking. You can read more about this at Voluntary Locking. Hint To learn more about voting on referenda, please check out our technical explainer video. Example: Bobby: Votes `No` with 10 ZEP for a 128 week lock period => 10 * 6 = 60 Votes Lucy: Votes `Yes` with 20 ZEP for a 4 week lock period => 20 * 1 = 20 Votes John: Votes `Yes` with 15 ZEP for a 8 week lock period => 15 * 2 = 30 Votes Even though combined both Luy and John vote with more ZEP than Bobby, the lock period for both of them is less than Bobby's, leading to their voting power counting as less. Tallying There are Three different scenarios depending on which entity proposed the proposal and whether all council members voted yes. We can use the following table for reference. Entity Metric Public Positive Turnout Bias (Super-Majority Approve) Council (Complete agreement) Negative Turnout Bias (Super-Majority Against) Council (Majority agreement) Simple Majority Also, we need the following information and apply one of the formulas listed below to calculate the voting result. For example, let's use the public proposal as an example, so the Super-Majority Approve formula will be applied. There is no strict quorum, but the super-majority required increases with lower turnout. approve - the number of aye votes against - the number of nay votes turnout - the total number of voting coins (does not include conviction) electorate - the total number of ZEP coins issued in the network Super-Majority Approve A positive turnout bias , whereby a heavy super-majority of aye votes is required to carry at low turnouts, but as turnout increases towards 100%, it becomes a simple majority-carries as below. Super-Majority Against A negative turnout bias , whereby a heavy super-majority of nay votes is required to reject at low turnouts, but as turnout increases towards 100%, it becomes a simple majority-carries as below. Simple Majority Majority-carries, a simple comparison of votes; if there are more aye votes than nay, then the proposal is carried, no matter how much stake votes on the proposal. To know more about where these above formulas come from, please read the democracy pallet . Example: Assume: - We only have 1.500 ZEP coins in total. - Public proposal Jane - 500 ZEP John - 100 ZEP Lilly - 150 ZEP JJ - 150 ZEP Ken - 600 ZEP Jane: Votes `Yes` for a 4 week lock period => 500 * 1 = 500 Votes John: Votes `Yes` for a 4 week lock period => 100 * 1 = 100 Votes JJ: Votes `No` for a 16 week lock period => 150 * 3 = 450 Votes approve = 600 against = 450 turnout = 750 electorate = 1500 Since the above example is a public referendum, Super-Majority Approve would be used to calculate the result. Super-Majority Approve requires more aye votes to pass the referendum when turnout is low, therefore, based on the above result, the referendum will be rejected. In addition, only the winning voter's coins are locked. If the voters on the losing side of the referendum believe that the outcome will have negative effects, their coins are transferrable so they will not be locked into the decision. Moreover, winning proposals are autonomously enacted only after some enactment period. Voluntary Locking Zukma utilizes an idea called Voluntary Locking that allows coin holders to increase their voting power by declaring how long they are willing to lock up their coins, hence, the number of votes for each coin holder will be calculated by the following formula: votes = coins * conviction_multiplier The conviction multiplier increases the vote multiplier by one every time the number of lock periods double. Lock Periods Vote Multiplier 0 0.1 1 1 2 2 4 3 8 4 16 5 32 6 The maximum number of \"doublings\" of the lock period is set to 6 (and thus 32 lock periods in total), and one lock period equals 8 days on Zukma. Only doublings are allowed; you cannot lock for, say, 24 periods and increase your conviction by 5.5, for instance. While a coin is locked, you can still use it for voting and staking; you are only prohibited from transferring these coins to another account. Votes are still \"counted\" at the same time (at the end of the voting period), no matter for how long the coins are locked. Adaptive Quorum Biasing Zukma uses Polkadot's concept called \"Adaptive Quorum Biasing\", which functions as a lever that the council can use to alter the effective super-majority required to make it easier or more difficult for a proposal to pass in the case that there is no clear majority of voting power backing it or against it. Let's use the above image as an example. If a publicly submitted referendum only has a 25% turnout, the tally of \"aye\" votes has to reach 66% for it to pass since we applied Positive Turnout Bias .` In contrast, when it has a 75% turnout, the tally of \"aye\" votes has to reach 54%, which means that the super-majority required decreases as the turnout increases. When the council proposes a new proposal through unanimous consent, the referendum would be put to a vote using \"Negative Turnout Bias\". In this case, it is easier to pass this proposal with low turnout and requires a super-majority to reject. As more coin holders participate in voting, the bias approaches a plain majority carries. Referring to the above image, when a referendum only has 25% turnout, the tally of \"aye\" votes has to reach 34% for it to pass. In short, when the turnout rate is low, a super-majority is required to reject the proposal, which means a lower threshold of \"aye\" votes have to be reached, but as turnout increases towards 100%, it becomes a simple majority. All three tallying mechanisms - majority carries, super-majority approve, and super-majority against - equate to a simple majority-carries system at 100% turnout. Council Hint Video explainer on Council To represent passive stakeholders, Zukma uses the idea of a \"council\". The council is an on-chain entity comprising several actors, each represented as an on-chain account. On Zukma, the council will consist of 19 seats. Along with controlling the treasury, the council is called upon primarily for three tasks of governance: proposing sensible referenda, cancelling uncontroversially dangerous or malicious referenda, and electing the technical committee. For a referendum to be proposed by the council, a strict majority of members must be in favor, with no member exercising a veto. Vetoes may be exercised only once by a member for any single proposal; if, after a cool-down period, the proposal is resubmitted, they may not veto it a second time. Council motions which pass with a 3/5 (60%) super-majority - but without reaching unanimous support - will move to a public referendum under a neutral, majority-carries voting scheme. In the case that all members of the council vote in favor of a motion, the vote is considered unanimous and becomes a referendum with negative adaptive quorum biasing. Canceling A proposal can be canceled if the technical committee unanimously agrees to do so, or if Root origin (e.g. sudo) triggers this functionality. A canceled proposal's deposit is burned. Additionally, a two-thirds majority of the council can cancel a referendum. This may function as a last-resort if there is an issue found late in a referendum's proposal such as a bug in the code of the runtime that the proposal would institute. If the cancellation is controversial enough that the council cannot get a two-thirds majority, then it will be left to the stakeholders en masse to determine the fate of the proposal. Blacklisting A proposal can be blacklisted by Sudo Pallet . A blacklisted proposal and its related referendum (if any) is immediately canceled. Additionally, a blacklisted proposal's hash cannot re-appear in the proposal queue. Blacklisting is useful when removing erroneous proposals that could be submitted with the same hash, i.e. proposal #2 in which the submitter used plain text to make a suggestion. Upon seeing their proposal removed, a submitter who is not properly introduced to the democracy system of Zukma might be tempted to re-submit the same proposal. That said, this is far from a fool-proof method of preventing invalid proposals from being submitted - a single changed character in a proposal's text will also change the hash of the proposal, rendering the per-hash blacklist invalid. How to become a council member? All stakeholders are free to signal their approval of any of the registered candidates. Council elections are handled by the same Phragm\u00e9n election process that selects validators from the available pool based on nominations. However, coin holders' votes for councillors are isolated from any of the nominations they may have on validators. Council terms last for 24 days on Zukma. At the end of each term, Phragm\u00e9n election algorithm runs and the result will choose the new councillors based on the vote configurations of all voters. The election also chooses a set number of runners up (currently 19 on Zukma) that will remain in the queue with their votes intact. As opposed to a \"first-past-the-post\" electoral system, where voters can only vote for a single candidate from a list, a Phragm\u00e9n election is a more expressive way to include each voters' views. coin holders can treat it as a way to support as many candidates as they want. The election algorithm will find a fair subset of the candidates that most closely matches the expressed indications of the electorate as a whole. Let's take a look at the example below. Round 1 Coin Holders Candidates A B C D E John x x x x Alice x Bob x x x Kelvin x x Total 2 1 3 2 2 The above example shows that candidate C wins the election in round 1, while candidates A, B, D & E keep remaining on the candidates' list for the next round. Round 2 Coin Holders Candidates A B C D E John x x Alice x x Bob x x x x Kelvin x x Total 4 4 0 1 1 For the top-N (say 4 in this example) runners-up, they can remain and their votes persist until the next election. After round 2, even though candidates A & B get the same number of votes in this round, candidate A gets elected because after adding the older unused approvals, it is higher than B. Technical Committee The Technical Committee is one of the three chambers of Zukma governance (along with the Council and the Referendum chamber). The Technical Committee is composed of the teams that have successfully implemented or specified either a Zukma runtime. Teams are added or removed from the Technical Committee via a simple majority vote of the Council. The Technical Committee can, along with the Council, produce emergency referenda, which are fast-tracked for voting and implementation. These are used for emergency bug fixes or rapid implementation of new but battle-tested features into the runtime. Fast-tracked referenda are the only type of referenda that can be active alongside another active referendum. Thus, with fast-tracked referenda it is possible to have two active referendums at the same time. Voting on one does not prevent a user from voting on the other. Freqently Asked Quesitons How can I appeal to the council to enact a change on my behalf? In some circumstances, you may want to appeal to the on-chain council to enact a change on your behalf. One example of this circumstance is the case of lost or locked funds when the funds were lost due to a human interface error (such as inputting an address for another network). When these circumstances can be proven beyond a reasonable doubt to be an error, the council may consider a governance motion to correct it. The first step to appeal to the council is to get in contact with the councillors. There is no singular place where you are guaranteed to grab every councillor's ear with your message. However, there are a handful of good places to start where you can get the attention of some of them. Our Telegram is one such place. After creating an account and joining our telegram, you can post a well-thought-through message here that lays down your case and provides justification for why you think the council should consider enacting a change to the protocol on your behalf. At some point you will likely need a place for a longer-form discussion. When you write a post on telegram make sure you present all the evidence for your circumstances and state clearly what kind of change you would suggest to the councillors to enact. Remember - the councillors do not need to make the change, it is your responsibility to make a strong case for why the change should be made. Written by Zukma Team","title":"Explore the Governance"},{"location":"what-to-try/democracy/#exploring-democracy","text":"Zukma uses a sophisticated governance mechanism to evolve gracefully over time at the ultimate behest of its assembled stakeholders. The stated goal is to ensure that the majority of the stake can always command the network. To do this, we borrowed and adjusted various mechanisms from Polkadot, Kusama and Substrate, including an amorphous state-transition function stored on-chain and defined in a platform-neutral intermediate language (i.e. WebAssembly ) and several on-chain voting mechanisms such as referenda with adaptive super-majority thresholds and batch approval voting. Stake-weighted referenda must agree upon all changes to the protocol.","title":"EXPLORING DEMOCRACY"},{"location":"what-to-try/democracy/#mechanism","text":"To make any changes to the network, the idea is to compose active coin holders and the council together to administrate a network upgrade decision. No matter whether the proposal is proposed by the public (coin holders) or the council, it finally will have to go through a referendum to let all holders, weighted by stake, make the decision.","title":"Mechanism"},{"location":"what-to-try/democracy/#referenda","text":"Referenda are straightforward, inclusive, stake-based voting schemes. Each referendum has a specific proposal associated with it that takes the form of a privileged function call in the runtime (that includes the most powerful call: set_code , which can switch out the entire code of the runtime, achieving what would otherwise require a \"hard fork\"). Referenda are discrete events, have a fixed period where voting happens and then are tallied, and the function call is made if the vote is approved. Referenda are always binary; your only options in voting are \"aye\" , \"nay\" , or abstaining entirely. Referenda can be started in one of several ways: Publicly submitted proposals; Proposals submitted by the Council, either through a majority or unanimously; Proposals submitted as part of the enactment of a prior referendum; Emergency proposals submitted by the Technical Committee and approved by the Council. All referenda have an enactment delay associated with them. This is the period between the referendum ending and, assuming the proposal was approved, the changes being enacted. For the first two ways that a referendum is launched, this is a fixed time. For Zukma, it is eight days. For the third type, it can be set as desired. Emergency proposals deal with significant problems with the network that need to be \"fast-tracked\". These will have a shorter enactment time.","title":"Referenda"},{"location":"what-to-try/democracy/#proposing-a-referendum","text":"","title":"Proposing a Referendum"},{"location":"what-to-try/democracy/#public-referenda","text":"Anyone can propose a referendum by depositing the minimum amount of coins for a certain period (number of blocks). If someone agrees with the proposal, they may deposit the same amount of coins to support it - this action is called seconding. The proposal with the highest bonded support will be selected to be a referendum in the next voting cycle. Note Note that this may be different from the absolute number of seconds; for instance, three accounts bonding 20 ZEP each would \"outweigh\" ten accounts bonding aP single ZEP each. The bonded coins will be released once the proposal is tabled (that is, brought to a vote). There can be a maximum of 100 public proposals in the proposal queue.","title":"Public referenda"},{"location":"what-to-try/democracy/#council-referenda","text":"Unanimous Council - When all members of the council agree on a proposal, the council can move it to a referendum. This referendum will have a negative turnout bias (that is, the smaller the amount of stake voting, the smaller the amount necessary for it to pass - see \"Adaptive Quorum Biasing\", below). Majority Council - When agreement from only a simple majority of council members occurs, the referendum can also be voted upon, but it will be majority-carries (51% wins). There can only be one active referendum at any given time, except when there is also an emergency referendum in progress.","title":"Council Referenda"},{"location":"what-to-try/democracy/#voting-timetable","text":"Every 7 days, a new referendum will come up for a vote, assuming at least one proposal in one of the queues. There is a queue for Council-approved proposals and a queue for publicly submitted proposals. The referendum to be voted upon alternates between the top proposal in the two queues. The \"top\" proposal is determined by the amount of stake bonded behind it. Suppose the given queue whose turn it is to create a referendum with no proposals (empty), and proposals are waiting in the other queue. In that case, the top proposal in the other queue will become a referendum. Multiple referenda cannot be voted upon in the same period, excluding emergency referenda. An emergency referendum co-occurring as a regular referendum (either public- or council-proposed) is the only time multiple referenda will be voted on at once.","title":"Voting Timetable"},{"location":"what-to-try/democracy/#voting-on-referendum","text":"To vote, a voter generally must lock their coins up for at least the enactment delay period beyond the end of the referendum. This ensures that some minimal economic buy-in to the result is needed and dissuades vote selling. It is possible to vote without locking at all, but your vote is worth a small fraction of an ordinary vote, given your stake. At the same time, holding only a small amount of coins does not mean that the holder cannot influence the referendum result, thanks to time-locking. You can read more about this at Voluntary Locking. Hint To learn more about voting on referenda, please check out our technical explainer video. Example: Bobby: Votes `No` with 10 ZEP for a 128 week lock period => 10 * 6 = 60 Votes Lucy: Votes `Yes` with 20 ZEP for a 4 week lock period => 20 * 1 = 20 Votes John: Votes `Yes` with 15 ZEP for a 8 week lock period => 15 * 2 = 30 Votes Even though combined both Luy and John vote with more ZEP than Bobby, the lock period for both of them is less than Bobby's, leading to their voting power counting as less.","title":"Voting on referendum"},{"location":"what-to-try/democracy/#tallying","text":"There are Three different scenarios depending on which entity proposed the proposal and whether all council members voted yes. We can use the following table for reference. Entity Metric Public Positive Turnout Bias (Super-Majority Approve) Council (Complete agreement) Negative Turnout Bias (Super-Majority Against) Council (Majority agreement) Simple Majority Also, we need the following information and apply one of the formulas listed below to calculate the voting result. For example, let's use the public proposal as an example, so the Super-Majority Approve formula will be applied. There is no strict quorum, but the super-majority required increases with lower turnout. approve - the number of aye votes against - the number of nay votes turnout - the total number of voting coins (does not include conviction) electorate - the total number of ZEP coins issued in the network","title":"Tallying"},{"location":"what-to-try/democracy/#super-majority-approve","text":"A positive turnout bias , whereby a heavy super-majority of aye votes is required to carry at low turnouts, but as turnout increases towards 100%, it becomes a simple majority-carries as below.","title":"Super-Majority Approve"},{"location":"what-to-try/democracy/#super-majority-against","text":"A negative turnout bias , whereby a heavy super-majority of nay votes is required to reject at low turnouts, but as turnout increases towards 100%, it becomes a simple majority-carries as below.","title":"Super-Majority Against"},{"location":"what-to-try/democracy/#simple-majority","text":"Majority-carries, a simple comparison of votes; if there are more aye votes than nay, then the proposal is carried, no matter how much stake votes on the proposal. To know more about where these above formulas come from, please read the democracy pallet . Example: Assume: - We only have 1.500 ZEP coins in total. - Public proposal Jane - 500 ZEP John - 100 ZEP Lilly - 150 ZEP JJ - 150 ZEP Ken - 600 ZEP Jane: Votes `Yes` for a 4 week lock period => 500 * 1 = 500 Votes John: Votes `Yes` for a 4 week lock period => 100 * 1 = 100 Votes JJ: Votes `No` for a 16 week lock period => 150 * 3 = 450 Votes approve = 600 against = 450 turnout = 750 electorate = 1500 Since the above example is a public referendum, Super-Majority Approve would be used to calculate the result. Super-Majority Approve requires more aye votes to pass the referendum when turnout is low, therefore, based on the above result, the referendum will be rejected. In addition, only the winning voter's coins are locked. If the voters on the losing side of the referendum believe that the outcome will have negative effects, their coins are transferrable so they will not be locked into the decision. Moreover, winning proposals are autonomously enacted only after some enactment period.","title":"Simple Majority"},{"location":"what-to-try/democracy/#voluntary-locking","text":"Zukma utilizes an idea called Voluntary Locking that allows coin holders to increase their voting power by declaring how long they are willing to lock up their coins, hence, the number of votes for each coin holder will be calculated by the following formula: votes = coins * conviction_multiplier The conviction multiplier increases the vote multiplier by one every time the number of lock periods double. Lock Periods Vote Multiplier 0 0.1 1 1 2 2 4 3 8 4 16 5 32 6 The maximum number of \"doublings\" of the lock period is set to 6 (and thus 32 lock periods in total), and one lock period equals 8 days on Zukma. Only doublings are allowed; you cannot lock for, say, 24 periods and increase your conviction by 5.5, for instance. While a coin is locked, you can still use it for voting and staking; you are only prohibited from transferring these coins to another account. Votes are still \"counted\" at the same time (at the end of the voting period), no matter for how long the coins are locked.","title":"Voluntary Locking"},{"location":"what-to-try/democracy/#adaptive-quorum-biasing","text":"Zukma uses Polkadot's concept called \"Adaptive Quorum Biasing\", which functions as a lever that the council can use to alter the effective super-majority required to make it easier or more difficult for a proposal to pass in the case that there is no clear majority of voting power backing it or against it. Let's use the above image as an example. If a publicly submitted referendum only has a 25% turnout, the tally of \"aye\" votes has to reach 66% for it to pass since we applied Positive Turnout Bias .` In contrast, when it has a 75% turnout, the tally of \"aye\" votes has to reach 54%, which means that the super-majority required decreases as the turnout increases. When the council proposes a new proposal through unanimous consent, the referendum would be put to a vote using \"Negative Turnout Bias\". In this case, it is easier to pass this proposal with low turnout and requires a super-majority to reject. As more coin holders participate in voting, the bias approaches a plain majority carries. Referring to the above image, when a referendum only has 25% turnout, the tally of \"aye\" votes has to reach 34% for it to pass. In short, when the turnout rate is low, a super-majority is required to reject the proposal, which means a lower threshold of \"aye\" votes have to be reached, but as turnout increases towards 100%, it becomes a simple majority. All three tallying mechanisms - majority carries, super-majority approve, and super-majority against - equate to a simple majority-carries system at 100% turnout.","title":"Adaptive Quorum Biasing"},{"location":"what-to-try/democracy/#council","text":"Hint Video explainer on Council To represent passive stakeholders, Zukma uses the idea of a \"council\". The council is an on-chain entity comprising several actors, each represented as an on-chain account. On Zukma, the council will consist of 19 seats. Along with controlling the treasury, the council is called upon primarily for three tasks of governance: proposing sensible referenda, cancelling uncontroversially dangerous or malicious referenda, and electing the technical committee. For a referendum to be proposed by the council, a strict majority of members must be in favor, with no member exercising a veto. Vetoes may be exercised only once by a member for any single proposal; if, after a cool-down period, the proposal is resubmitted, they may not veto it a second time. Council motions which pass with a 3/5 (60%) super-majority - but without reaching unanimous support - will move to a public referendum under a neutral, majority-carries voting scheme. In the case that all members of the council vote in favor of a motion, the vote is considered unanimous and becomes a referendum with negative adaptive quorum biasing.","title":"Council"},{"location":"what-to-try/democracy/#canceling","text":"A proposal can be canceled if the technical committee unanimously agrees to do so, or if Root origin (e.g. sudo) triggers this functionality. A canceled proposal's deposit is burned. Additionally, a two-thirds majority of the council can cancel a referendum. This may function as a last-resort if there is an issue found late in a referendum's proposal such as a bug in the code of the runtime that the proposal would institute. If the cancellation is controversial enough that the council cannot get a two-thirds majority, then it will be left to the stakeholders en masse to determine the fate of the proposal.","title":"Canceling"},{"location":"what-to-try/democracy/#blacklisting","text":"A proposal can be blacklisted by Sudo Pallet . A blacklisted proposal and its related referendum (if any) is immediately canceled. Additionally, a blacklisted proposal's hash cannot re-appear in the proposal queue. Blacklisting is useful when removing erroneous proposals that could be submitted with the same hash, i.e. proposal #2 in which the submitter used plain text to make a suggestion. Upon seeing their proposal removed, a submitter who is not properly introduced to the democracy system of Zukma might be tempted to re-submit the same proposal. That said, this is far from a fool-proof method of preventing invalid proposals from being submitted - a single changed character in a proposal's text will also change the hash of the proposal, rendering the per-hash blacklist invalid.","title":"Blacklisting"},{"location":"what-to-try/democracy/#how-to-become-a-council-member","text":"All stakeholders are free to signal their approval of any of the registered candidates. Council elections are handled by the same Phragm\u00e9n election process that selects validators from the available pool based on nominations. However, coin holders' votes for councillors are isolated from any of the nominations they may have on validators. Council terms last for 24 days on Zukma. At the end of each term, Phragm\u00e9n election algorithm runs and the result will choose the new councillors based on the vote configurations of all voters. The election also chooses a set number of runners up (currently 19 on Zukma) that will remain in the queue with their votes intact. As opposed to a \"first-past-the-post\" electoral system, where voters can only vote for a single candidate from a list, a Phragm\u00e9n election is a more expressive way to include each voters' views. coin holders can treat it as a way to support as many candidates as they want. The election algorithm will find a fair subset of the candidates that most closely matches the expressed indications of the electorate as a whole. Let's take a look at the example below. Round 1 Coin Holders Candidates A B C D E John x x x x Alice x Bob x x x Kelvin x x Total 2 1 3 2 2 The above example shows that candidate C wins the election in round 1, while candidates A, B, D & E keep remaining on the candidates' list for the next round. Round 2 Coin Holders Candidates A B C D E John x x Alice x x Bob x x x x Kelvin x x Total 4 4 0 1 1 For the top-N (say 4 in this example) runners-up, they can remain and their votes persist until the next election. After round 2, even though candidates A & B get the same number of votes in this round, candidate A gets elected because after adding the older unused approvals, it is higher than B.","title":"How to become a council member?"},{"location":"what-to-try/democracy/#technical-committee","text":"The Technical Committee is one of the three chambers of Zukma governance (along with the Council and the Referendum chamber). The Technical Committee is composed of the teams that have successfully implemented or specified either a Zukma runtime. Teams are added or removed from the Technical Committee via a simple majority vote of the Council. The Technical Committee can, along with the Council, produce emergency referenda, which are fast-tracked for voting and implementation. These are used for emergency bug fixes or rapid implementation of new but battle-tested features into the runtime. Fast-tracked referenda are the only type of referenda that can be active alongside another active referendum. Thus, with fast-tracked referenda it is possible to have two active referendums at the same time. Voting on one does not prevent a user from voting on the other.","title":"Technical Committee"},{"location":"what-to-try/democracy/#freqently-asked-quesitons","text":"","title":"Freqently Asked Quesitons"},{"location":"what-to-try/democracy/#how-can-i-appeal-to-the-council-to-enact-a-change-on-my-behalf","text":"In some circumstances, you may want to appeal to the on-chain council to enact a change on your behalf. One example of this circumstance is the case of lost or locked funds when the funds were lost due to a human interface error (such as inputting an address for another network). When these circumstances can be proven beyond a reasonable doubt to be an error, the council may consider a governance motion to correct it. The first step to appeal to the council is to get in contact with the councillors. There is no singular place where you are guaranteed to grab every councillor's ear with your message. However, there are a handful of good places to start where you can get the attention of some of them. Our Telegram is one such place. After creating an account and joining our telegram, you can post a well-thought-through message here that lays down your case and provides justification for why you think the council should consider enacting a change to the protocol on your behalf. At some point you will likely need a place for a longer-form discussion. When you write a post on telegram make sure you present all the evidence for your circumstances and state clearly what kind of change you would suggest to the councillors to enact. Remember - the councillors do not need to make the change, it is your responsibility to make a strong case for why the change should be made. Written by Zukma Team","title":"How can I appeal to the council to enact a change on my behalf?"},{"location":"what-to-try/identity/","text":"SET AN IDENTITY TO GAIN TRUST Zukma provides a naming system that allows participants to add personal information to their on-chain account and subsequently ask for verification of this information by registrars. Setting an Identity Users can set an identity by registering through default fields such as legal name, display name, website, Twitter handle, Riot handle, etc. along with some extra, custom fields for which they would like attestations (see Judgements). Users must reserve funds in a bond to store their information on chain: 0.033333, and 0.008333 per each field beyond the legal name. These funds are locked, not spent - they are returned when the identity is cleared. The easiest way to create a on-chain identiy is to click the gear icon next to your account on the Substrate Explorer App and select \"Set on-chain identity\". A pop-up window will appear, offering the default fields. Judgement After a user injects their information on chain, they can request judgement from a registrar. Users declare a maximum fee that they are willing to pay for judgement, and registrars whose fee is below that amount can provide a judgement. When a registrar provides judgement, they can select up to six levels of confidence in their attestation: Unknown: The default value, no judgement made yet. Reasonable: The data appears reasonable, but no in-depth checks (e.g. formal KYC process) were performed. Known Good: The registrar has certified that the information is correct. Out of Date: The information used to be good, but is now out of date. Low Quality: The information is low quality or imprecise, but can be fixed with an update. Erroneous: The information is erroneous and may indicate malicious intent. A seventh state, \"fee paid\", is for when a user has requested judgement and it is in progress. Information that is in this state or \"erroneous\" is \"sticky\" and cannot be modified; it can only be removed by the complete removal of the identity. Registrars gain trust by performing proper due diligence and would presumably be replaced for issuing faulty judgements. To be judged after submitting your identity information, go to the \" Extrinsics UI \" and select the identity pallet , then requestJudgement . For the reg_index put the index of the registrar you want to be judged by, and for the max_fee put the maximum you're willing to pay for these confirmations Hint If you don't know which registrar to pick, first check the available registrars by going to \" Chain State UI \" and selecting identity.registrars() to get the full list. Requesting a Judgement Requesting judgement follows the same process. Select one of the registrars from the query you made above. This will make your identity go from \"unjudged\" to \"waiting\" At this point, direct contact with the registrar is required - the contact info is in their identity as shown above. Each registrar will have their own set of procedures to verify your identity and values, and only once you've satisfied their requirements will the process continue. Once the registrar has confirmed the identity, a green checkmark should appear next to your account name with the appropriate confidence level. Warning Note that changing even a single field's value after you've been verified will un-verify your account and you will need to start the judgement process anew. However, you can still change fields while the judgement is going on - it's up to the registrar to keep an eye on the changes. Cancel a Judgement You may decide that you do not want to be judged by a registrar (for instance, because you realize you entered incorrect data or selected the wrong registrar). In this case, after submitting the request for judgement but before your identity has been judged, you can issue a call to cancel the judgement using an extrinsic. To do this, first, go to the \" Extrinsics UI \" and select the identity pallet , then cancelRequest . Ensure that you are calling this from the correct account (the one for which you initially requested judgement). For the reg_index , put the index of the registrar from which you requested judgement. Submit the transaction, and the requested judgement will be cancelled. Registars Registrars can set a fee for their services and limit their attestation to certain fields. For example, a registrar could charge 1 ZEP to verify one's legal name, email, and GPG key. When a user requests judgement, they will pay this fee to the registrar who provides the judgement on those claims. Users set a maximum fee they are willing to pay and only registrars below this amount would provide judgement. Becoming a Registar To become a registrar, submit a pre-image and proposal into Democracy, then wait for people to vote on it. For best results, write a post about your identity and intentions beforehand, and once the proposal is in the queue ask people to second it so that it gets ahead in the referendum queue. Here's how to submit a proposal to become a registrar: Go to the Democracy tab, select \"Submit preimage\", and input the information for this motion - notably which account you're nominating to be a registrar in the identity. setRegistrar function. Copy the preimage hash. Submit the preimage by signing a transaction. Next, select \"Submit Proposal\" and enter the previously copied preimage hash. The locked balance field needs to be at least 100 ZEP. You can find out the minimum by querying the chain state under Chain State -> Constants -> democracy -> minimumDeposit . Clearing and Killing an Identity Clearing : Users can clear their identity information and have their deposit returned. Clearing an identity also clears all sub accounts and returns their deposits. To clear an identity: Navigate to the Accounts UI. Click the three dots corresponding to the account you want to clear and select Set on-chain identity . Select Clear Identity , and sign and submit the transaction. Killing : The Council can kill an identity that it deems erroneous. This results in a slash of the deposit. Written by Zukma Team","title":"Set an Identity"},{"location":"what-to-try/identity/#set-an-identity-to-gain-trust","text":"Zukma provides a naming system that allows participants to add personal information to their on-chain account and subsequently ask for verification of this information by registrars.","title":"SET AN IDENTITY TO GAIN TRUST"},{"location":"what-to-try/identity/#setting-an-identity","text":"Users can set an identity by registering through default fields such as legal name, display name, website, Twitter handle, Riot handle, etc. along with some extra, custom fields for which they would like attestations (see Judgements). Users must reserve funds in a bond to store their information on chain: 0.033333, and 0.008333 per each field beyond the legal name. These funds are locked, not spent - they are returned when the identity is cleared. The easiest way to create a on-chain identiy is to click the gear icon next to your account on the Substrate Explorer App and select \"Set on-chain identity\". A pop-up window will appear, offering the default fields.","title":"Setting an Identity"},{"location":"what-to-try/identity/#judgement","text":"After a user injects their information on chain, they can request judgement from a registrar. Users declare a maximum fee that they are willing to pay for judgement, and registrars whose fee is below that amount can provide a judgement. When a registrar provides judgement, they can select up to six levels of confidence in their attestation: Unknown: The default value, no judgement made yet. Reasonable: The data appears reasonable, but no in-depth checks (e.g. formal KYC process) were performed. Known Good: The registrar has certified that the information is correct. Out of Date: The information used to be good, but is now out of date. Low Quality: The information is low quality or imprecise, but can be fixed with an update. Erroneous: The information is erroneous and may indicate malicious intent. A seventh state, \"fee paid\", is for when a user has requested judgement and it is in progress. Information that is in this state or \"erroneous\" is \"sticky\" and cannot be modified; it can only be removed by the complete removal of the identity. Registrars gain trust by performing proper due diligence and would presumably be replaced for issuing faulty judgements. To be judged after submitting your identity information, go to the \" Extrinsics UI \" and select the identity pallet , then requestJudgement . For the reg_index put the index of the registrar you want to be judged by, and for the max_fee put the maximum you're willing to pay for these confirmations Hint If you don't know which registrar to pick, first check the available registrars by going to \" Chain State UI \" and selecting identity.registrars() to get the full list.","title":"Judgement"},{"location":"what-to-try/identity/#requesting-a-judgement","text":"Requesting judgement follows the same process. Select one of the registrars from the query you made above. This will make your identity go from \"unjudged\" to \"waiting\" At this point, direct contact with the registrar is required - the contact info is in their identity as shown above. Each registrar will have their own set of procedures to verify your identity and values, and only once you've satisfied their requirements will the process continue. Once the registrar has confirmed the identity, a green checkmark should appear next to your account name with the appropriate confidence level. Warning Note that changing even a single field's value after you've been verified will un-verify your account and you will need to start the judgement process anew. However, you can still change fields while the judgement is going on - it's up to the registrar to keep an eye on the changes.","title":"Requesting a Judgement"},{"location":"what-to-try/identity/#cancel-a-judgement","text":"You may decide that you do not want to be judged by a registrar (for instance, because you realize you entered incorrect data or selected the wrong registrar). In this case, after submitting the request for judgement but before your identity has been judged, you can issue a call to cancel the judgement using an extrinsic. To do this, first, go to the \" Extrinsics UI \" and select the identity pallet , then cancelRequest . Ensure that you are calling this from the correct account (the one for which you initially requested judgement). For the reg_index , put the index of the registrar from which you requested judgement. Submit the transaction, and the requested judgement will be cancelled.","title":"Cancel a Judgement"},{"location":"what-to-try/identity/#registars","text":"Registrars can set a fee for their services and limit their attestation to certain fields. For example, a registrar could charge 1 ZEP to verify one's legal name, email, and GPG key. When a user requests judgement, they will pay this fee to the registrar who provides the judgement on those claims. Users set a maximum fee they are willing to pay and only registrars below this amount would provide judgement.","title":"Registars"},{"location":"what-to-try/identity/#becoming-a-registar","text":"To become a registrar, submit a pre-image and proposal into Democracy, then wait for people to vote on it. For best results, write a post about your identity and intentions beforehand, and once the proposal is in the queue ask people to second it so that it gets ahead in the referendum queue. Here's how to submit a proposal to become a registrar: Go to the Democracy tab, select \"Submit preimage\", and input the information for this motion - notably which account you're nominating to be a registrar in the identity. setRegistrar function. Copy the preimage hash. Submit the preimage by signing a transaction. Next, select \"Submit Proposal\" and enter the previously copied preimage hash. The locked balance field needs to be at least 100 ZEP. You can find out the minimum by querying the chain state under Chain State -> Constants -> democracy -> minimumDeposit .","title":"Becoming a Registar"},{"location":"what-to-try/identity/#clearing-and-killing-an-identity","text":"Clearing : Users can clear their identity information and have their deposit returned. Clearing an identity also clears all sub accounts and returns their deposits. To clear an identity: Navigate to the Accounts UI. Click the three dots corresponding to the account you want to clear and select Set on-chain identity . Select Clear Identity , and sign and submit the transaction. Killing : The Council can kill an identity that it deems erroneous. This results in a slash of the deposit. Written by Zukma Team","title":"Clearing and Killing an Identity"},{"location":"what-to-try/nominator/","text":"STAKING: BECOME A NOMINATOR If you are looking for a \"set-it-and-forget-it\" approach to leverage your ZEP coins, then becoming a Zukma nominator is the way to go. As a nominator, you are participating in the staking system of Zukma. Nominators use a specified amount of their funds to \"vote\" for Zukma validators. Validators are network nodes that participate in the consensus and block authoring process. Your job as a nominator is to appoint (stake) your ZEP to elect the active set of validators. The active validators list consists of validators that received the most ZEP as \"votes\". If your chosen validator makes it to the active set, he will earn rewards and ideally share them with all of his nominators. The main difference between a Validator and a Nominator is the active participation in the network. Validators engage in the block production and finality mechanisms, whereas nominators take a more passive role with the above mentioned \"set-it-and-forget-it\" approach. Being a nominator does not require running a node of your own or worrying about online uptime. However, a good nominator performs due diligence on the validators that they elect. When looking for validators to nominate, a nominator should pay attention to their reward percentage for nominating a specific validator - as well as the risk that they bear of being slashed if the validator gets slashed. Setting up Controller and Stash Accounts Info In this guide, we use the terms \"account\" and \"wallet\" interchangeably. Nominators are recommended to set up two separate stash and controller accounts. Explanation and reasoning for generating distinct accounts for this purpose is elaborated in the keys section of the Wiki. You can generate your stash and controller account via any of the recommended methods that are detailed on the account generation page . Hint Payouts can go to any custom address. If you'd like to redirect payments to an account that is neither the controller nor the stash account, set one up. Note that it is extremely unsafe to set an exchange address as the recipient of the staking rewards. Using Zukma Substrate Explorer Step 1: Bond your coins On the Substrate Explorer UI navigate to the \"Staking\" tab (within the \"Network\" menu). The \"Staking Overview\" subsection will show you all the active validators and their information: (1) their identities (2) the amount of ZEP that are staking for them (3) amount that is their own provided stake (4) how much they charge in commission (5) the era points they've earned in the current era (6) and the last block number that they produced. Attention What does oversubscribed mean? Maximum number of Validators a Nominator is able to stake/delegate to is 16. Validators can receive up to 256 nominations before they are oversubscribed. (76,800 nominations will receive rewards) Once oversubscribed, the amount of ZEP nominated is deciding whether you'll receive rewards or not. If you click on the (7) chart button, it will take you to the \"Validator Stats\" page for that validator that shows you more detailed and historical information about the validator's stake, rewards, and slashes. The Account actions subsection allows you to stake and nominate. Pick Account actions underneath Network > Staking , then click the + Nominator button. You will see a modal window that looks like the below: Select a value bonded that is less than the total amount of ZEP you have, so you have some leftover to pay transaction fees. Transaction fees are currently at least 0.01 ZEP, but they are dynamic based on various factors, including a load of recent blocks. Choose whatever payment destination makes sense to you. If you're unsure, you can choose \"Stash account (increase amount at stake)\" to simply accrue the rewards into the amount you're staking and earn compound interest. Step 2: Nominate a Validator You are now bonded. Being bonded means your tokens are locked and could be slashed if the validators you nominate misbehave. All bonded funds can now be distributed to up to 16 validators. Be careful about the validators you choose since you will be slashed if your validator commits an offense. Click on Nominate on an account you've bonded, and you will be presented with another popup asking you to select some validators. Select them, confirm the transaction, and you're done - you are now nominating. Your nominations will become active in the next era. Eras last 6 hours on Zukma - depending on when you do this, your nominations may become active almost immediately, or you may have to wait nearly the entire 6 hours before your nominations are active. You can check how far along Zukma is in the current era on the Staking page. Assuming at least one of your nominations ends up in the active validator set, you will start to get rewards allocated to you. To claim them (i.e., add them to your account), you must manually claim them. You can do it yourself or have the validator you staked to initiate a claim. This is to help optimize the effectiveness and storage of payouts on Zukma. See the Claiming Rewards section of the Staking wiki page for more details. Success Congrats! You successfully staked ZEP on the substrate side of the Zukma Network Step 3: Stop Nominating At some point, you might decide to stop nominating one or more validators. You can always change who you're nominating, but you cannot withdraw your coins unless you unbond them. Detailed instructions are available here. Written by Zukma Team","title":"Become a Nominator"},{"location":"what-to-try/nominator/#staking-become-a-nominator","text":"If you are looking for a \"set-it-and-forget-it\" approach to leverage your ZEP coins, then becoming a Zukma nominator is the way to go. As a nominator, you are participating in the staking system of Zukma. Nominators use a specified amount of their funds to \"vote\" for Zukma validators. Validators are network nodes that participate in the consensus and block authoring process. Your job as a nominator is to appoint (stake) your ZEP to elect the active set of validators. The active validators list consists of validators that received the most ZEP as \"votes\". If your chosen validator makes it to the active set, he will earn rewards and ideally share them with all of his nominators. The main difference between a Validator and a Nominator is the active participation in the network. Validators engage in the block production and finality mechanisms, whereas nominators take a more passive role with the above mentioned \"set-it-and-forget-it\" approach. Being a nominator does not require running a node of your own or worrying about online uptime. However, a good nominator performs due diligence on the validators that they elect. When looking for validators to nominate, a nominator should pay attention to their reward percentage for nominating a specific validator - as well as the risk that they bear of being slashed if the validator gets slashed.","title":"STAKING: BECOME A NOMINATOR"},{"location":"what-to-try/nominator/#setting-up-controller-and-stash-accounts","text":"Info In this guide, we use the terms \"account\" and \"wallet\" interchangeably. Nominators are recommended to set up two separate stash and controller accounts. Explanation and reasoning for generating distinct accounts for this purpose is elaborated in the keys section of the Wiki. You can generate your stash and controller account via any of the recommended methods that are detailed on the account generation page . Hint Payouts can go to any custom address. If you'd like to redirect payments to an account that is neither the controller nor the stash account, set one up. Note that it is extremely unsafe to set an exchange address as the recipient of the staking rewards.","title":"Setting up Controller and Stash Accounts"},{"location":"what-to-try/nominator/#using-zukma-substrate-explorer","text":"","title":"Using Zukma Substrate Explorer"},{"location":"what-to-try/nominator/#step-1-bond-your-coins","text":"On the Substrate Explorer UI navigate to the \"Staking\" tab (within the \"Network\" menu). The \"Staking Overview\" subsection will show you all the active validators and their information: (1) their identities (2) the amount of ZEP that are staking for them (3) amount that is their own provided stake (4) how much they charge in commission (5) the era points they've earned in the current era (6) and the last block number that they produced. Attention What does oversubscribed mean? Maximum number of Validators a Nominator is able to stake/delegate to is 16. Validators can receive up to 256 nominations before they are oversubscribed. (76,800 nominations will receive rewards) Once oversubscribed, the amount of ZEP nominated is deciding whether you'll receive rewards or not. If you click on the (7) chart button, it will take you to the \"Validator Stats\" page for that validator that shows you more detailed and historical information about the validator's stake, rewards, and slashes. The Account actions subsection allows you to stake and nominate. Pick Account actions underneath Network > Staking , then click the + Nominator button. You will see a modal window that looks like the below: Select a value bonded that is less than the total amount of ZEP you have, so you have some leftover to pay transaction fees. Transaction fees are currently at least 0.01 ZEP, but they are dynamic based on various factors, including a load of recent blocks. Choose whatever payment destination makes sense to you. If you're unsure, you can choose \"Stash account (increase amount at stake)\" to simply accrue the rewards into the amount you're staking and earn compound interest.","title":"Step 1: Bond your coins"},{"location":"what-to-try/nominator/#step-2-nominate-a-validator","text":"You are now bonded. Being bonded means your tokens are locked and could be slashed if the validators you nominate misbehave. All bonded funds can now be distributed to up to 16 validators. Be careful about the validators you choose since you will be slashed if your validator commits an offense. Click on Nominate on an account you've bonded, and you will be presented with another popup asking you to select some validators. Select them, confirm the transaction, and you're done - you are now nominating. Your nominations will become active in the next era. Eras last 6 hours on Zukma - depending on when you do this, your nominations may become active almost immediately, or you may have to wait nearly the entire 6 hours before your nominations are active. You can check how far along Zukma is in the current era on the Staking page. Assuming at least one of your nominations ends up in the active validator set, you will start to get rewards allocated to you. To claim them (i.e., add them to your account), you must manually claim them. You can do it yourself or have the validator you staked to initiate a claim. This is to help optimize the effectiveness and storage of payouts on Zukma. See the Claiming Rewards section of the Staking wiki page for more details. Success Congrats! You successfully staked ZEP on the substrate side of the Zukma Network","title":"Step 2: Nominate a Validator"},{"location":"what-to-try/nominator/#step-3-stop-nominating","text":"At some point, you might decide to stop nominating one or more validators. You can always change who you're nominating, but you cannot withdraw your coins unless you unbond them. Detailed instructions are available here. Written by Zukma Team","title":"Step 3: Stop Nominating"},{"location":"what-to-try/treasury/","text":"SPEND THE TREASURY The Treasury is a pot of funds collected through transaction fees, slashing, staking inefficiencies, etc. The funds held in the Treasury can be spent by making a spending proposal that, if approved by the Council, will enter a waiting period before distribution. This waiting period is known as the budget period, and its duration is subject to governance, with the current default set to 6 days. The Treasury attempts to spend as many proposals in the queue as it can without running out of funds. If the Treasury ends a budget period without spending all of its funds, it suffers a burn of a percentage of its funds -- thereby causing deflationary pressure. This percentage is currently 0.2% on Zukma, with the amount currently going to Society rather than being burned. When a stakeholder wishes to propose a spend from the Treasury, they must reserve a deposit of at least 5% of the proposed spend (see below for variations). This deposit will be slashed if the proposal is rejected, and returned if it is accepted. Proposals may consist of (but are not limited to): Infrastructure deployment and continued operation. Network security operations (monitoring services, continuous auditing). Ecosystem provisions (collaborations with friendly chains). Marketing activities (advertising, paid features, collaborations). Community events and outreach (meetups, pizza parties, hackerspaces). Software development (wallets and wallet integration, clients and client upgrades). The Treasury is ultimately controlled by the Council, and how the funds will be spent is up to their judgment. Funding the Treasury The Treasury is funded from different sources: Slashing : When a validator is slashed for any reason, the slashed amount is sent to the Treasury with a reward going to the entity that reported the validator (another validator). The reward is taken from the slash amount and varies per offence and number of reporters. Transaction fees : A portion of each block's transaction fees goes to the Treasury, with the remainder going to the block author. Staking inefficiency : Inflation is designed to be 20% in the first year, and the ideal staking ratio is set at 50%, meaning half of all ZEP should be locked in staking. - Any deviation from this ratio will cause a proportional amount of the inflation to go to the Treasury. In other words, if 50% of all ZEP are staked, then 100% of the inflation goes to the validators as reward. If the staking rate is greater than or less than 50%, then the validators will receive less, with the remainder going to the Treasury. Creating a Treasury Proposal The proposer has to deposit 5% of the requested amount or 0.067 ZEP (whichever is higher) as an anti-spam measure. This amount is burned if the proposal is rejected, or refunded otherwise. These values are subject to governance so they may change in the future. Please note that there is no way for a user to revoke a treasury proposal after it has been submitted. The Council will either accept or reject the proposal, and if the proposal is rejected, the bonded funds are burned. Announcing the Proposal To minimize storage on chain, proposals don't contain contextual information. When a user submits a proposal, they will probably need to find an off-chain way to explain the proposal. Most discussion takes place on Discord. Spreading the word about the proposal's explanation is ultimately up to the proposer - the recommended way is using our official channels like Discord or Telegram. Creating the Proposal One way to create the proposal is to use the Substrate Explorer App . From the website, use the Governance tab and select the Treasury, then click on submit proposal and enter the desired amount and recipient. The system will automatically take the required deposit, picking the higher of the two values mentioned above. Once created, your proposal will become visible in the Treasury screen and the Council can start voting on it. Hint Remember that the proposal has no metadata, so it's up to the proposer to create a description and purpose that the Council could study and base their votes on. At this point, a Council member can create a motion to accept or to reject the treasury proposal. It is possible that one motion to accept and another motion to reject are both created. The proportions to accept and reject Council proposals vary between accept or reject, and possibly depend on which network the Treasury is implemented. The threshold for accepting a treasury proposal is at least three-fifths of the Council. On the other hand, the threshold for rejecting a proposal is at least one-half of the Council. Tipping Next to the proposals process, a separate system for making tips exists for the Treasury. Tips can be suggested by anyone and are supported by members of the Council. Tips do not have any definite value; the final value of the tip is decided based on the median of all tips issued by the tippers. Currently, the tippers are the same as the members of the Council. However, being a tipper is not the direct responsibility of the Council, and at some point the Council and the tippers may be different groups of accounts. A tip will enter a closing phase when more than a half plus one of the tipping group have endorsed a tip. During that timeframe, the other members of the tipping group can still issue their tips, but do not have to. Once the window closes, anyone can call the close_tip extrinsic, and the tip will be paid out. There are two types of tips: public and tipper-initiated. With public tips, a small bond is required to place them. This bond depends on the tip message length, and a fixed bond constant defined on chain, currently 0.166. Public tips carry a finder's fee of 20% which is paid out from the total amount. Tipper-initiated tips, i.e. tips that a Council member published, do not have a finder's fee or a bond. To better understand the process a tip goes through until it is paid out, let's consider an example. Example Bob has done something great for Zukma. Alice has noticed this and decides to report Bob as deserving a tip from the Treasury. The Council is composed of three members Charlie, Dave, and Eve. Alice begins the process by issuing the report_awesome extrinsic. This extrinsic requires two arguments, a reason and the address to tip. Alice submits Bob's address with the reason being a UTF-8 encoded URL to a post on Discord that explains her reasoning for why Bob deserves the tip. As mentioned above, Alice must also lock up a deposit for making this report. The deposit is the base deposit as set in the chain's parameter list plus the additional deposit per byte contained in the reason. This is why Alice submitted a URL as the reason instead of the explanation directly, it was cheaper for her to do so. For her trouble, Alice is able to claim the eventual finder's fee if the tip is approved by the tippers. Since the tipper group is the same as the Council, the Council must now collectively (but also independently) decide on the value of the tip that Bob deserves. Charlie, Dave, and Eve all review the report and make tips according to their personal valuation of the benefit Bob has provided to Zukma. Charlie tips 1 ZEP. Dave tips 3 ZEP. Eve tips 10 ZEP. The tip could have been closed out with only two of the three tippers. Once more than half of the tippers group have issued tip valuations, the countdown to close the tip will begin. In this case, the third tipper issued their tip before the end of the closing period, so all three were able to make their tip valuations known. Now the actual tip that will be paid out to Bob is the median of these tips, so Bob will be paid out 3 ZEP from the Treasury. In order for Bob to be paid his tip, some account must call the close_tip extrinsic at the end of the closing period for the tip. This extrinsic may be called by anyone. Bounties Spending There are practical limits to Council Members curation capabilities when it comes to treasury proposals: Council members likely do not have the expertise to make a proper assessment of the activities described in all proposals. Even if individual Councillors have that expertise, it is highly unlikely that a majority of members are capable in such diverse topics. Bounties Spending proposals aim to delegate the curation activity of spending proposals to experts called Curators: They can be defined as addresses with agency over a portion of the Treasury with the goal of fixing a bug or vulnerability, developing a strategy, or monitoring a set of tasks related to a specific topic: all for the benefit of the Zukma ecosystem. A proposer can submit a bounty proposal for the Council to pass, with a curator to be defined later, whose background and expertise is such that they are capable of determining when the task is complete. Curators are selected by the Council after the bounty proposal passes, and need to add an upfront payment to take the position. This deposit can be used to punish them if they act maliciously. However, if they are successful in their task of getting someone to complete the bounty work, they will receive their deposit back and part of the bounty reward. When submitting the value of the bounty, the proposer includes a reward for curators willing to invest their time and expertise in the task: this amount is included in the total value of the bounty. In this sense, the curator's fee can be defined as the result of subtracting the value paid to the bounty rewardee from the total value of the bounty. In general terms, curators are expected to have a well-balanced track record related to the issues the bounty tries to resolve: they should be at least knowledgeable on the topics the bounty touches, and show project management skills or experience. These recommendations ensure an effective use of the mechanism. A Bounty Spending is a reward for a specified body of work - or specified set of objectives - that needs to be executed for a predefined treasury amount to be paid out. The responsibility of assigning a payout address once the specified set of objectives is completed is delegated to the curator. After the Council has activated a bounty, it delegates the work that requires expertise to the curator who gets to close the active bounty. Closing the active bounty enacts a delayed payout to the payout address and a payout of the curator fee. The delay phase allows the Council to act if any issues arise. To minimize storage on chain in the same way as any proposal, bounties don't contain contextual information. When a user submits a bounty spending proposal, they will probably need to find an off-chain way to explain the proposal (any of the available community forums serve this purpose). We will provide a template that can help as a checklist of all needed information for the Council to make an informed decision. The bounty has a predetermined duration of 90 days with the possibility of being extended by the curator. Aiming to maintain flexibility on the task\u2019s curation, the curator will be able to create sub-bounties for more granularity and allocation in the next iteration of the mechanism. Creating a Bounty Proposal Anyone can create a Bounty proposal using Substrate Explorer App : Users are able to submit a proposal on the dedicated Bounty section under Governance. The development of a robust user interface to view and manage bounties in the Substrate Explorer App is still under development and it will serve Council members, Curators and Beneficiaries of the bounties, as well as all users observing the on-chain treasury governance. For now, the help of a Councillor is needed to open a bounty proposal as a motion to be voted. To submit a bounty, please visit Substrate Explorer App and click on the governance tab in the options bar on the top of the site. After, click on Bounties and find the button + Add Bounty on the upper-right side of the interface. Complete the bounty title, the requested allocation (including curator's fee) and confirm the call. After this, a Council member will need to assist you to pass the bounty proposal for vote as a motion. You can contact the Council by joining our Discord server and publishing a short description of your bounty, with a link to one of the forums for contextual information. A bounty can be cancelled by deleting the earmark for a specific treasury amount or be closed if the tasks have been completed. On the opposite side, the 90 days life of a bounty can be extended by amending the expiry block number of the bounty to stay active. Closing a Bounty The curator can close the bounty once they approve the completion of its tasks. The curator should make sure to set up the payout address on the active bounty beforehand. Closing the Active bounty enacts a delayed payout to the payout address and a payout of the curator fee. A bounty can be closed by using the extrinsics tab and selecting the Treasury pallet, then Award_bounty , making sure the right bounty is to be closed and finally sign the transaction. It is important to note that those who received a reward after the bounty is completed, must claim the specific amount of the payout from the payout address, by calling Claim_bounty after the curator closed the allocation. FAQ What prevents the Treasury from being captured by a majority of the council? The majority of the Council can decide the outcome of a treasury spend proposal. In an adversarial mindset, we may consider the possibility that the Council may at some point go rogue and attempt to steal all of the treasury funds. It is a possibility that the treasury pot becomes so great, that a large financial incentive would present itself. For one, the Treasury has deflationary pressure due to the burn that is suffered every spend period. The burn aims to incentivize the complete spend of all treasury funds at every burn period, so ideally the treasury pot doesn't have time to accumulate mass amounts of wealth. However, it is the case that the burn on the Treasury could be so little that it does not matter. However, it is the case on Zukma that the Council is composed of mainly well-known members of the community. Remember, the Council is voted in by the ZEP holders, so they must do some campaigning or otherwise be recognized to earn votes. In the scenario of an attack, the Council members would lose their social credibility. Furthermore, members of the Council are usually externally motivated by the proper operation of the chain. This external motivation is either because they run businesses that depend on the chain, or they have direct financial gain (through their holdings) of the token value remaining steady. Concretely, there are a couple on-chain methods that resist this kind of attack. One, the Council majority may not be the token majority of the chain. This means that the token majority could vote to replace the Council if they attempted this attack - or even reverse the treasury spend. They would do this through a normal referendum. Two, there are time delays to treasury spends. They are only enacted every spend period. This means that there will be some time to observe this attack is taking place. The time delay then allows chain participants time to respond. The response may take the form of governance measures or - in the most extreme cases a liquidation of their holdings and a migration to a minority fork. However, the possibility of this scenario is quite low. Further Reading Substrate's Treasury Pallet - The Rust implementation of the Treasury ( Docs ) Written by Zukma Team","title":"Use the Treasury"},{"location":"what-to-try/treasury/#spend-the-treasury","text":"The Treasury is a pot of funds collected through transaction fees, slashing, staking inefficiencies, etc. The funds held in the Treasury can be spent by making a spending proposal that, if approved by the Council, will enter a waiting period before distribution. This waiting period is known as the budget period, and its duration is subject to governance, with the current default set to 6 days. The Treasury attempts to spend as many proposals in the queue as it can without running out of funds. If the Treasury ends a budget period without spending all of its funds, it suffers a burn of a percentage of its funds -- thereby causing deflationary pressure. This percentage is currently 0.2% on Zukma, with the amount currently going to Society rather than being burned. When a stakeholder wishes to propose a spend from the Treasury, they must reserve a deposit of at least 5% of the proposed spend (see below for variations). This deposit will be slashed if the proposal is rejected, and returned if it is accepted. Proposals may consist of (but are not limited to): Infrastructure deployment and continued operation. Network security operations (monitoring services, continuous auditing). Ecosystem provisions (collaborations with friendly chains). Marketing activities (advertising, paid features, collaborations). Community events and outreach (meetups, pizza parties, hackerspaces). Software development (wallets and wallet integration, clients and client upgrades). The Treasury is ultimately controlled by the Council, and how the funds will be spent is up to their judgment.","title":"SPEND THE TREASURY"},{"location":"what-to-try/treasury/#funding-the-treasury","text":"The Treasury is funded from different sources: Slashing : When a validator is slashed for any reason, the slashed amount is sent to the Treasury with a reward going to the entity that reported the validator (another validator). The reward is taken from the slash amount and varies per offence and number of reporters. Transaction fees : A portion of each block's transaction fees goes to the Treasury, with the remainder going to the block author. Staking inefficiency : Inflation is designed to be 20% in the first year, and the ideal staking ratio is set at 50%, meaning half of all ZEP should be locked in staking. - Any deviation from this ratio will cause a proportional amount of the inflation to go to the Treasury. In other words, if 50% of all ZEP are staked, then 100% of the inflation goes to the validators as reward. If the staking rate is greater than or less than 50%, then the validators will receive less, with the remainder going to the Treasury.","title":"Funding the Treasury"},{"location":"what-to-try/treasury/#creating-a-treasury-proposal","text":"The proposer has to deposit 5% of the requested amount or 0.067 ZEP (whichever is higher) as an anti-spam measure. This amount is burned if the proposal is rejected, or refunded otherwise. These values are subject to governance so they may change in the future. Please note that there is no way for a user to revoke a treasury proposal after it has been submitted. The Council will either accept or reject the proposal, and if the proposal is rejected, the bonded funds are burned.","title":"Creating a Treasury Proposal"},{"location":"what-to-try/treasury/#announcing-the-proposal","text":"To minimize storage on chain, proposals don't contain contextual information. When a user submits a proposal, they will probably need to find an off-chain way to explain the proposal. Most discussion takes place on Discord. Spreading the word about the proposal's explanation is ultimately up to the proposer - the recommended way is using our official channels like Discord or Telegram.","title":"Announcing the Proposal"},{"location":"what-to-try/treasury/#creating-the-proposal","text":"One way to create the proposal is to use the Substrate Explorer App . From the website, use the Governance tab and select the Treasury, then click on submit proposal and enter the desired amount and recipient. The system will automatically take the required deposit, picking the higher of the two values mentioned above. Once created, your proposal will become visible in the Treasury screen and the Council can start voting on it. Hint Remember that the proposal has no metadata, so it's up to the proposer to create a description and purpose that the Council could study and base their votes on. At this point, a Council member can create a motion to accept or to reject the treasury proposal. It is possible that one motion to accept and another motion to reject are both created. The proportions to accept and reject Council proposals vary between accept or reject, and possibly depend on which network the Treasury is implemented. The threshold for accepting a treasury proposal is at least three-fifths of the Council. On the other hand, the threshold for rejecting a proposal is at least one-half of the Council.","title":"Creating the Proposal"},{"location":"what-to-try/treasury/#tipping","text":"Next to the proposals process, a separate system for making tips exists for the Treasury. Tips can be suggested by anyone and are supported by members of the Council. Tips do not have any definite value; the final value of the tip is decided based on the median of all tips issued by the tippers. Currently, the tippers are the same as the members of the Council. However, being a tipper is not the direct responsibility of the Council, and at some point the Council and the tippers may be different groups of accounts. A tip will enter a closing phase when more than a half plus one of the tipping group have endorsed a tip. During that timeframe, the other members of the tipping group can still issue their tips, but do not have to. Once the window closes, anyone can call the close_tip extrinsic, and the tip will be paid out. There are two types of tips: public and tipper-initiated. With public tips, a small bond is required to place them. This bond depends on the tip message length, and a fixed bond constant defined on chain, currently 0.166. Public tips carry a finder's fee of 20% which is paid out from the total amount. Tipper-initiated tips, i.e. tips that a Council member published, do not have a finder's fee or a bond. To better understand the process a tip goes through until it is paid out, let's consider an example.","title":"Tipping"},{"location":"what-to-try/treasury/#example","text":"Bob has done something great for Zukma. Alice has noticed this and decides to report Bob as deserving a tip from the Treasury. The Council is composed of three members Charlie, Dave, and Eve. Alice begins the process by issuing the report_awesome extrinsic. This extrinsic requires two arguments, a reason and the address to tip. Alice submits Bob's address with the reason being a UTF-8 encoded URL to a post on Discord that explains her reasoning for why Bob deserves the tip. As mentioned above, Alice must also lock up a deposit for making this report. The deposit is the base deposit as set in the chain's parameter list plus the additional deposit per byte contained in the reason. This is why Alice submitted a URL as the reason instead of the explanation directly, it was cheaper for her to do so. For her trouble, Alice is able to claim the eventual finder's fee if the tip is approved by the tippers. Since the tipper group is the same as the Council, the Council must now collectively (but also independently) decide on the value of the tip that Bob deserves. Charlie, Dave, and Eve all review the report and make tips according to their personal valuation of the benefit Bob has provided to Zukma. Charlie tips 1 ZEP. Dave tips 3 ZEP. Eve tips 10 ZEP. The tip could have been closed out with only two of the three tippers. Once more than half of the tippers group have issued tip valuations, the countdown to close the tip will begin. In this case, the third tipper issued their tip before the end of the closing period, so all three were able to make their tip valuations known. Now the actual tip that will be paid out to Bob is the median of these tips, so Bob will be paid out 3 ZEP from the Treasury. In order for Bob to be paid his tip, some account must call the close_tip extrinsic at the end of the closing period for the tip. This extrinsic may be called by anyone.","title":"Example"},{"location":"what-to-try/treasury/#bounties-spending","text":"There are practical limits to Council Members curation capabilities when it comes to treasury proposals: Council members likely do not have the expertise to make a proper assessment of the activities described in all proposals. Even if individual Councillors have that expertise, it is highly unlikely that a majority of members are capable in such diverse topics. Bounties Spending proposals aim to delegate the curation activity of spending proposals to experts called Curators: They can be defined as addresses with agency over a portion of the Treasury with the goal of fixing a bug or vulnerability, developing a strategy, or monitoring a set of tasks related to a specific topic: all for the benefit of the Zukma ecosystem. A proposer can submit a bounty proposal for the Council to pass, with a curator to be defined later, whose background and expertise is such that they are capable of determining when the task is complete. Curators are selected by the Council after the bounty proposal passes, and need to add an upfront payment to take the position. This deposit can be used to punish them if they act maliciously. However, if they are successful in their task of getting someone to complete the bounty work, they will receive their deposit back and part of the bounty reward. When submitting the value of the bounty, the proposer includes a reward for curators willing to invest their time and expertise in the task: this amount is included in the total value of the bounty. In this sense, the curator's fee can be defined as the result of subtracting the value paid to the bounty rewardee from the total value of the bounty. In general terms, curators are expected to have a well-balanced track record related to the issues the bounty tries to resolve: they should be at least knowledgeable on the topics the bounty touches, and show project management skills or experience. These recommendations ensure an effective use of the mechanism. A Bounty Spending is a reward for a specified body of work - or specified set of objectives - that needs to be executed for a predefined treasury amount to be paid out. The responsibility of assigning a payout address once the specified set of objectives is completed is delegated to the curator. After the Council has activated a bounty, it delegates the work that requires expertise to the curator who gets to close the active bounty. Closing the active bounty enacts a delayed payout to the payout address and a payout of the curator fee. The delay phase allows the Council to act if any issues arise. To minimize storage on chain in the same way as any proposal, bounties don't contain contextual information. When a user submits a bounty spending proposal, they will probably need to find an off-chain way to explain the proposal (any of the available community forums serve this purpose). We will provide a template that can help as a checklist of all needed information for the Council to make an informed decision. The bounty has a predetermined duration of 90 days with the possibility of being extended by the curator. Aiming to maintain flexibility on the task\u2019s curation, the curator will be able to create sub-bounties for more granularity and allocation in the next iteration of the mechanism.","title":"Bounties Spending"},{"location":"what-to-try/treasury/#creating-a-bounty-proposal","text":"Anyone can create a Bounty proposal using Substrate Explorer App : Users are able to submit a proposal on the dedicated Bounty section under Governance. The development of a robust user interface to view and manage bounties in the Substrate Explorer App is still under development and it will serve Council members, Curators and Beneficiaries of the bounties, as well as all users observing the on-chain treasury governance. For now, the help of a Councillor is needed to open a bounty proposal as a motion to be voted. To submit a bounty, please visit Substrate Explorer App and click on the governance tab in the options bar on the top of the site. After, click on Bounties and find the button + Add Bounty on the upper-right side of the interface. Complete the bounty title, the requested allocation (including curator's fee) and confirm the call. After this, a Council member will need to assist you to pass the bounty proposal for vote as a motion. You can contact the Council by joining our Discord server and publishing a short description of your bounty, with a link to one of the forums for contextual information. A bounty can be cancelled by deleting the earmark for a specific treasury amount or be closed if the tasks have been completed. On the opposite side, the 90 days life of a bounty can be extended by amending the expiry block number of the bounty to stay active.","title":"Creating a Bounty Proposal"},{"location":"what-to-try/treasury/#closing-a-bounty","text":"The curator can close the bounty once they approve the completion of its tasks. The curator should make sure to set up the payout address on the active bounty beforehand. Closing the Active bounty enacts a delayed payout to the payout address and a payout of the curator fee. A bounty can be closed by using the extrinsics tab and selecting the Treasury pallet, then Award_bounty , making sure the right bounty is to be closed and finally sign the transaction. It is important to note that those who received a reward after the bounty is completed, must claim the specific amount of the payout from the payout address, by calling Claim_bounty after the curator closed the allocation.","title":"Closing a Bounty"},{"location":"what-to-try/treasury/#faq","text":"","title":"FAQ"},{"location":"what-to-try/treasury/#what-prevents-the-treasury-from-being-captured-by-a-majority-of-the-council","text":"The majority of the Council can decide the outcome of a treasury spend proposal. In an adversarial mindset, we may consider the possibility that the Council may at some point go rogue and attempt to steal all of the treasury funds. It is a possibility that the treasury pot becomes so great, that a large financial incentive would present itself. For one, the Treasury has deflationary pressure due to the burn that is suffered every spend period. The burn aims to incentivize the complete spend of all treasury funds at every burn period, so ideally the treasury pot doesn't have time to accumulate mass amounts of wealth. However, it is the case that the burn on the Treasury could be so little that it does not matter. However, it is the case on Zukma that the Council is composed of mainly well-known members of the community. Remember, the Council is voted in by the ZEP holders, so they must do some campaigning or otherwise be recognized to earn votes. In the scenario of an attack, the Council members would lose their social credibility. Furthermore, members of the Council are usually externally motivated by the proper operation of the chain. This external motivation is either because they run businesses that depend on the chain, or they have direct financial gain (through their holdings) of the token value remaining steady. Concretely, there are a couple on-chain methods that resist this kind of attack. One, the Council majority may not be the token majority of the chain. This means that the token majority could vote to replace the Council if they attempted this attack - or even reverse the treasury spend. They would do this through a normal referendum. Two, there are time delays to treasury spends. They are only enacted every spend period. This means that there will be some time to observe this attack is taking place. The time delay then allows chain participants time to respond. The response may take the form of governance measures or - in the most extreme cases a liquidation of their holdings and a migration to a minority fork. However, the possibility of this scenario is quite low.","title":"What prevents the Treasury from being captured by a majority of the council?"},{"location":"what-to-try/treasury/#further-reading","text":"Substrate's Treasury Pallet - The Rust implementation of the Treasury ( Docs ) Written by Zukma Team","title":"Further Reading"}]}